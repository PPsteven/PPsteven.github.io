<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>算法笔记:《剑指 offer》 | 软微9133</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="剑指Offer，刷题" />
  
  
  
  
  <meta name="description" content="用言简意赅的方法记录 《剑指》，作为复习《剑指offer》的笔记">
<meta name="keywords" content="剑指Offer，刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记:《剑指 Offer》">
<meta property="og:url" content="http:&#x2F;&#x2F;ppsteven.github.io&#x2F;2020&#x2F;05&#x2F;14&#x2F;jz-offer-solution&#x2F;index.html">
<meta property="og:site_name" content="软微9133">
<meta property="og:description" content="用言简意赅的方法记录 《剑指》，作为复习《剑指offer》的笔记">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200512123358.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200703134155.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200703145136.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200513113239.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200513113538.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200704123005.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200514214717.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200514215522.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200704150131.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200704162344.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200705160832.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200705211833.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pic.leetcode-cn.com&#x2F;dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200707205301.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200708172711.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200710162955.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200710162955.png">
<meta property="og:updated_time" content="2020-07-10T12:25:09.945Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200512123358.png">
  
    <link rel="alternate" href="/atom.xml" title="软微9133" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li> <a class="main-nav-link" href="/link">我的关注</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-jz-offer-solution" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      算法笔记:《剑指 Offer》
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/05/14/jz-offer-solution/" class="article-date">
	  <time datetime="2020-05-14T12:13:20.000Z" itemprop="datePublished">2020-05-14</time>
	</a>

      
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      
	<a class="article-edit" target="_blank" rel="noopener" href="https://github.com/ppsteven/blog/edit/master/source/_posts/jz-offer-solution.md">
	<span id="edit">编辑</span>
	</span>
	</a>


    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>用言简意赅的方法记录 《剑指》，作为复习《剑指offer》的笔记</p>
<a id="more"></a>

<h2 id="面试题03-数据中的重复数字"><a href="#面试题03-数据中的重复数字" class="headerlink" title="面试题03. 数据中的重复数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03. 数据中的重复数字</a></h2><h3 id="Best-Answer【利用下表法】"><a href="#Best-Answer【利用下表法】" class="headerlink" title="Best Answer【利用下表法】"></a>Best Answer【利用下表法】</h3><ul>
<li><p>解题思路：</p>
<p>利用 <code>nums 里的所有数字都在 0～n-1 的范围内</code> 这一条件，表示 <code>每个数字都只有一个坑位，一个坑位上不能有两个数字</code> </p>
<blockquote>
<p>时间复杂度 O(n) 空间复杂度O(1)</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">           <span class="keyword">while</span> i != nums[i]:</span><br><span class="line">               <span class="keyword">if</span> nums[i] == nums[nums[i]]: <span class="keyword">return</span> nums[i]</span><br><span class="line">               <span class="comment"># 原地交换</span></span><br><span class="line">               temp = nums[i]</span><br><span class="line">               nums[i] = nums[nums[i]]</span><br><span class="line">               nums[temp] = temp</span><br></pre></td></tr></table></figure>

<ul>
<li><p>交换数组的时候，需要注意利用 python 便捷的交换方式存在陷阱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确方法一：</span></span><br><span class="line">temp = nums[i]</span><br><span class="line">nums[i] = nums[nums[i]]</span><br><span class="line">nums[temp] = temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确方法二：</span></span><br><span class="line">nums[nums[i]] , nums[i] = nums[i] , nums[nums[i]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误方式：</span></span><br><span class="line">nums[i], nums[nums[i]] = nums[nums[i]], nums[i]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Other-Answer【哈希表法】"><a href="#Other-Answer【哈希表法】" class="headerlink" title="Other Answer【哈希表法】"></a>Other Answer【哈希表法】</h3><ul>
<li><p>解题思路：<code>哈希表</code></p>
<blockquote>
<p>时间复杂度 O(n) 空间复杂度O(n)</p>
</blockquote>
<p>Python的实现哈希表的方式是通过 <code>字典</code> 和 <code>集合</code> 的方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于集合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       s = set()</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">           <span class="keyword">if</span> i <span class="keyword">in</span> s: <span class="keyword">return</span> i</span><br><span class="line">           <span class="keyword">else</span>: s.add(i)</span><br><span class="line"><span class="comment"># 基于字典</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       s = dict()</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">           <span class="keyword">if</span> i <span class="keyword">in</span> s: <span class="keyword">return</span> i</span><br><span class="line">           <span class="keyword">else</span>: s[i] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04. 二维数组中的查找</a></h2><blockquote>
<p>同 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></p>
</blockquote>
<h3 id="Best-Answer【左下-右上元素移动法】"><a href="#Best-Answer【左下-右上元素移动法】" class="headerlink" title="Best Answer【左下/右上元素移动法】"></a>Best Answer【左下/右上元素移动法】</h3><ul>
<li><p>解题思路：</p>
<p>左下、右上角的特点是，排除式查找。</p>
<blockquote>
<p>时间复杂度 O(行高+列宽) 空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 以右上角为例</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target: i += <span class="number">1</span> <span class="comment"># 比目标值小，向下一行查找</span></span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span> <span class="comment"># 比目标值大，向上一行查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Other-Answer-【双折半查找】"><a href="#Other-Answer-【双折半查找】" class="headerlink" title="Other Answer 【双折半查找】"></a>Other Answer 【双折半查找】</h3><ul>
<li><p>解题思路 <code>折半法</code></p>
<blockquote>
<p>参考：<a href="https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318" target="_blank" rel="noopener">https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318</a></p>
<p>时间复杂度：O(logM + logN) 复杂度最坏情况为O(M * logN)</p>
</blockquote>
<p>二维数组分为上下左右四个边界top，bottom，left，right：</p>
<ul>
<li>根据上边界折半查找——确定 right 范围</li>
<li>根据下边界折半查找——确定 left 范围</li>
<li>根据左边界折半查找——确定 top 范围</li>
<li>根据右边界折半查找——确定 bottom 范围</li>
</ul>
<p>最直接的方法，代码量大，考察基本功</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(array[<span class="number">0</span>]) - <span class="number">1</span> </span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        bottom = len(array) - <span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right <span class="keyword">or</span> top &lt; bottom):</span><br><span class="line">             <span class="comment"># 对上边界进行折半，可以缩小右边界</span></span><br><span class="line">             l = left</span><br><span class="line">             r = right</span><br><span class="line">             <span class="keyword">while</span> (l &lt;= r):</span><br><span class="line">                  mid = (l+r) // <span class="number">2</span></span><br><span class="line">                  <span class="keyword">if</span> array[top][mid] == target:</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                  <span class="keyword">elif</span> array[top][mid] &gt; target:</span><br><span class="line">                       r = mid - <span class="number">1</span></span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                       l = mid + <span class="number">1</span></span><br><span class="line">             <span class="keyword">if</span> (mid &lt; right):</span><br><span class="line">                  right = mid</span><br><span class="line">             top += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 对下边界进行折半，可以缩小左边界</span></span><br><span class="line">             l = left</span><br><span class="line">             r = right</span><br><span class="line">             <span class="keyword">while</span> (l &lt;= r):</span><br><span class="line">                  mid = (l + r) // <span class="number">2</span> </span><br><span class="line">                  <span class="keyword">if</span> array[bottom][mid] == target:</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                  <span class="keyword">elif</span> array[bottom][mid] &gt; target:</span><br><span class="line">                       r = mid - <span class="number">1</span> </span><br><span class="line">                  <span class="keyword">else</span>: </span><br><span class="line">                       l = mid + <span class="number">1</span> </span><br><span class="line">             <span class="keyword">if</span> (mid &gt; left):</span><br><span class="line">                 left = mid </span><br><span class="line">             bottom -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 对左边界进行折半，可以缩小下边界</span></span><br><span class="line">             t = top</span><br><span class="line">             b = bottom</span><br><span class="line">             <span class="keyword">while</span> (t &lt;= b):</span><br><span class="line">                 mid = (t + b) // <span class="number">2</span> </span><br><span class="line">                 <span class="keyword">if</span> array[mid][left] == target:</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                 <span class="keyword">elif</span> array[mid][left] &gt; target:</span><br><span class="line">                      b = mid - <span class="number">1</span> </span><br><span class="line">                 <span class="keyword">else</span>: </span><br><span class="line">                      t = mid + <span class="number">1</span> </span><br><span class="line">             <span class="keyword">if</span> (t &lt; mid):</span><br><span class="line">                 t = mid</span><br><span class="line">             left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 对右边界进行折半，可以缩小上边界</span></span><br><span class="line">             t = top</span><br><span class="line">             b = bottom</span><br><span class="line">             <span class="keyword">while</span> (t &lt;= b):</span><br><span class="line">                mid = (t + b) // <span class="number">2</span> </span><br><span class="line">                <span class="keyword">if</span> array[mid][right] == target:</span><br><span class="line">                     <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> array[mid][right] &gt; target:</span><br><span class="line">                     b = mid - <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                     t = mid + <span class="number">1</span> </span><br><span class="line">             <span class="keyword">if</span> (b &gt; mid):</span><br><span class="line">                 b = mid </span><br><span class="line">             right -= <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ret = Solution().Find(<span class="number">7</span>,[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>]])</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure>

<h2 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05. 替换空格</a></h2><ul>
<li>解题思路： <code>字符串相关操作</code></li>
</ul>
<h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h2><ul>
<li><p>递归法</p>
<p>递归是由计算机帮助实现 “栈” 结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.next) + [head.val]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据结构——栈 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            stack.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">       <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></h2><h3 id="Best-Answer"><a href="#Best-Answer" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路:</p>
<ul>
<li><p>数据结构——二叉树</p>
<p>根据 pre 确定 根节点</p>
<p>根据 vin 确定左右子树的大小</p>
</li>
<li><p>递归编程</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200512123358.png" style="zoom:50%;" />

<ul>
<li><p>注意点</p>
<p>需要根据中序遍历结果，确定左子树长度  <code>tin.index(value)</code> </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">          self.val = x</span><br><span class="line">          self.left = <span class="literal">None</span></span><br><span class="line">          self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">0</span> :</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span> :</span><br><span class="line">           <span class="keyword">return</span> TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        value = pre[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(value)</span><br><span class="line">        <span class="comment"># 截取左子树</span></span><br><span class="line">        preLeft = pre[<span class="number">1</span>:tin.index(value) + <span class="number">1</span>] <span class="comment"># 先序遍历，从第二个开始截图 左子树长度的 数组</span></span><br><span class="line">        tinLeft = tin[:tin.index(value)] <span class="comment"># 中序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 截取右子树</span></span><br><span class="line">        preRight = pre[tin.index(value) + <span class="number">1</span>:] <span class="comment"># 先序遍历， 左子树后的数组元素是 右子树</span></span><br><span class="line">        tinRight = tin[tin.index(value) + <span class="number">1</span>:] <span class="comment"># 中序遍历</span></span><br><span class="line"></span><br><span class="line">        root.left = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        root.right = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sol = Solution().reConstructBinaryTree([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br><span class="line">    print(sol)</span><br></pre></td></tr></table></figure>



<h2 id="面试题09-用两个栈实现一个队列"><a href="#面试题09-用两个栈实现一个队列" class="headerlink" title="面试题09. 用两个栈实现一个队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现一个队列</a></h2><h3 id="Best-Answer-1"><a href="#Best-Answer-1" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路:<br><strong>栈是后进先出(LIFO)，队列是先进先出(FIFO)。</strong><br>可以使用2个栈来表示，一个表示入栈，还有一个表示出栈，出栈的顺序与入栈的顺序相反。</p>
<p>第一个栈弹出后压入第二个栈就可以了</p>
</li>
<li><p>python 栈 &amp; 队列 实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 栈实现</span></span><br><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">1</span>) <span class="comment"># 入栈</span></span><br><span class="line">stack.pop() <span class="comment"># 出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 队列实现</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line">queue = deque([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]) </span><br><span class="line">queue.append(<span class="string">'D'</span>) <span class="comment"># 入队</span></span><br><span class="line">queue.popleft() <span class="comment"># 出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># item = [] 这样的用法是错误的，因为此时有两个栈实例都会使用此变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.item = [] </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.item.append(node)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        v = self.item.pop()</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.item)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.length &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图解</p>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/fu-zhu-zhan-python3-c-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/fu-zhu-zhan-python3-c-by-z1m/</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200703134155.png" alt=""></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># s1 用于存储，相当于仓库; s2 用于输出</span></span><br><span class="line">        self.s1, self.s2 = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.s1.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.s2: <span class="keyword">return</span> self.s2.pop() </span><br><span class="line">        <span class="keyword">while</span> self.s1: <span class="comment"># 如果 s1 为空，尝试把 s2 数据换过来</span></span><br><span class="line">            self.s2.append(self.s1.pop())</span><br><span class="line">        <span class="keyword">if</span> self.s2: <span class="keyword">return</span> self.s2.pop() <span class="comment"># 再次尝试取数据</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="面试10-I-斐波那契数列【动态规划经典】"><a href="#面试10-I-斐波那契数列【动态规划经典】" class="headerlink" title="面试10- I. 斐波那契数列【动态规划经典】"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试10- I. 斐波那契数列【动态规划经典】</a></h2><h2 id="面试10-II-青蛙跳台阶问题【动态规划经典】"><a href="#面试10-II-青蛙跳台阶问题【动态规划经典】" class="headerlink" title="面试10- II. 青蛙跳台阶问题【动态规划经典】"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">面试10- II. 青蛙跳台阶问题【动态规划经典】</a></h2><h3 id="Best-Answer【动态规划】"><a href="#Best-Answer【动态规划】" class="headerlink" title="Best Answer【动态规划】"></a>Best Answer【动态规划】</h3><ul>
<li><p>解题思路：<code>动态规划</code>动态规划解析：</p>
<blockquote>
<p>作者：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener">jyd</a></p>
<p>时间复杂度：O(n) 空间复杂度O(n)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200703145136.png" alt=""></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        fibArr = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            fibArr.append(fibArr[i - <span class="number">1</span>] + fibArr[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> fibArr[n] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>



<h3 id="Other-Answer-【循环求余法】"><a href="#Other-Answer-【循环求余法】" class="headerlink" title="Other Answer 【循环求余法】"></a>Other Answer 【循环求余法】</h3><ul>
<li><p>解题速率：<code>动态规划的改进</code> </p>
<blockquote>
<p>作者：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener">jyd</a></p>
<p>时间复杂度：O(n)   <strong>空间复杂度O(1)</strong></p>
</blockquote>
<p>动态规划的空间复杂度 O(n) ，可以不存储中间结果。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<h3 id="Other-Answer【分治法-记忆化搜索】"><a href="#Other-Answer【分治法-记忆化搜索】" class="headerlink" title="Other Answer【分治法+记忆化搜索】"></a>Other Answer【分治法+记忆化搜索】</h3><ul>
<li><p>解题思路： <code>分治法</code> + <code>记忆化搜索</code></p>
<p>传统的分治法会产生大量重复计算，一定会超时。通过将结果固定下来可以加快运算速度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">F</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> memory: <span class="keyword">return</span> memory[n]</span><br><span class="line">            value = F(n<span class="number">-1</span>) + F(n<span class="number">-2</span>)</span><br><span class="line">            memory[n] = value </span><br><span class="line">            <span class="keyword">return</span> memory[n]</span><br><span class="line">        memory = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> F(n) % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题11-旋转数组的最小数字【中高难】"><a href="#面试题11-旋转数组的最小数字【中高难】" class="headerlink" title="面试题11. 旋转数组的最小数字【中高难】"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11. 旋转数组的最小数字【中高难】</a></h2><h3 id="Best-Answer【变形二分查找】"><a href="#Best-Answer【变形二分查找】" class="headerlink" title="Best Answer【变形二分查找】"></a>Best Answer【变形二分查找】</h3><ul>
<li><p>解题思路：</p>
<blockquote>
<p>时间复杂度O(n)  空间复杂度 O(1) </p>
</blockquote>
<p>变形的二分查找，但是有一些坑</p>
<p>a. 正确情况下的二分查找</p>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200513113239.png" style="zoom: 67%;" />

<p>b. 特殊情况</p>
<p>当出现重复数字情形的时候，<strong>直接缩小左边界（因为最小值总是在右侧出现）</strong></p>
<p>情形4 可以适应非递增数列的最小值为队首元素的情形。最后的代码非常巧妙</p>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200513113538.png" style="zoom:67%;" />

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(rotateArray) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right: <span class="comment"># 不能是 &lt;=</span></span><br><span class="line">            <span class="comment"># 加入特殊情况，非递减数组的最小值就是队首</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[left] &lt; rotateArray[right]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[left]</span><br><span class="line">            mid = (left + right) // <span class="number">2</span> </span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt; rotateArray[left]:</span><br><span class="line">                 left = mid + <span class="number">1</span>  <span class="comment"># 一般都是在右侧，所以放心加1</span></span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                 right = mid <span class="comment"># 此时 mid 可能是最小值，不能排除</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                 left += <span class="number">1</span>  <span class="comment"># 巧妙避免了offer书上说的坑点（1 0 1 1 1）</span></span><br><span class="line">        <span class="keyword">return</span> rotateArray[left]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二分法解题需要考虑的情况</p>
<ul>
<li><p><code>while left &lt;= right</code> 是错误的</p>
<p>实例：[2,2,2,0,1]  </p>
<p>错误输出 2 ，实际上是 0</p>
</li>
<li><p><code>right = mid</code> 提现了最小值一般是在右侧</p>
</li>
<li><p>考虑到存在有序的情况，单独处理</p>
</li>
</ul>
</li>
</ul>
<h3 id="Other-Answer-【直接搜索】"><a href="#Other-Answer-【直接搜索】" class="headerlink" title="Other Answer 【直接搜索】"></a>Other Answer 【直接搜索】</h3><blockquote>
<p>时间复杂度： O(n)  空间复杂度: O(1)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i<span class="number">-1</span>] &gt; rotateArray[i]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i]</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h2 id="面试题12-矩阵中的路径"><a href="#面试题12-矩阵中的路径" class="headerlink" title="面试题12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12. 矩阵中的路径</a></h2><h3 id="Best-Answer-2"><a href="#Best-Answer-2" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li>解题思路:  <code>DFS 深度搜索</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, word)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 已经找到</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= i &lt;= len(board) - <span class="number">1</span> <span class="keyword">and</span> \</span><br><span class="line">               <span class="number">0</span> &lt;= j &lt;= len(board[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> \</span><br><span class="line">               board[i][j] == word[<span class="number">0</span>]): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            flag.append((i, j)) <span class="comment"># 加入访问过的节点</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> dirction:</span><br><span class="line">                ni, nj = i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> (ni, nj) <span class="keyword">not</span> <span class="keyword">in</span> flag: <span class="comment"># 判断有无走过</span></span><br><span class="line">                     <span class="keyword">if</span> dfs(ni, nj, word[<span class="number">1</span>:]): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            flag.remove((i, j)) <span class="comment"># 走完一定要回溯回状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        dirction = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">        flag = []  <span class="comment"># 标记走过的格子</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, word): </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重点元素：</p>
<blockquote>
<ul>
<li><p>终止条件 <code>if not word: return True</code> 不能漏掉</p>
</li>
<li><p>访问过的节点矩阵：两种实现方法  <strong>邻接矩阵表示法、稀疏矩阵标识方式</strong></p>
<p> <code>flags = [[0]*ncol for _ in range(nrow)]</code>  ，通过设置 <code>flags[j][i] = True</code></p>
<p><code>flags = [(1, 2), (3,4)]</code></p>
</li>
<li><p>一定要注意结束后 <code>回溯状态</code></p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Graceful-Answer-【精妙写法】"><a href="#Graceful-Answer-【精妙写法】" class="headerlink" title="Graceful Answer 【精妙写法】"></a>Graceful Answer 【精妙写法】</h3><blockquote>
<p>参考自: <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/" target="_blank" rel="noopener">Krahets-Leetcode 题解</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> \</span><br><span class="line">               <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">               board[i][j] != word[k]: </span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 判断都放在这里</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp, board[i][j] = board[i][j], <span class="string">'/'</span> <span class="comment"># 直接修改原矩阵</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = tmp</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">面试题13. 机器人的运动范围</a></h2><h3 id="My-Answer【DFS-深度搜索改进】"><a href="#My-Answer【DFS-深度搜索改进】" class="headerlink" title="My Answer【DFS 深度搜索改进】"></a>My Answer【DFS 深度搜索改进】</h3><ul>
<li><p>解题思路：<code>DFS 深度搜索</code> + <code>剪枝</code></p>
<p>上一题同样是 <code>DFS</code> 算法，其中提到一定要注意 <code>状态回溯</code> 。本题则不同，因为是求的  <strong><em>最多访问到的格子</em></strong>，    <strong><em>最多访问的路径</em></strong>  。所以 辅助矩阵 <code>visited</code> 是记录访问到的格子，最后返回的结果也是 <code>len(visited)</code></p>
<ul>
<li>终止条件： <code>下标越界、题目条件限制、节点已访问</code></li>
<li>计算节点位数和的方法可以尝试 <code>memory</code> 记忆矩阵做缓存</li>
<li>剪枝体现在：根据题意，只需要访问 <code>右</code>、<code>下</code> 两个方向即可。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal_digit</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> memory:</span><br><span class="line">                ret = sum([int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> str(x)])</span><br><span class="line">                memory[x] = ret</span><br><span class="line">            <span class="keyword">return</span> memory[x]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;=n: <span class="keyword">return</span>  <span class="comment"># 下表越界</span></span><br><span class="line">            <span class="keyword">if</span> cal_digit(i) + cal_digit(j)&gt; k: <span class="keyword">return</span> <span class="comment"># 题目条件限制 </span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">return</span> <span class="comment"># 节点已访问过</span></span><br><span class="line">            visited.append((i, j))</span><br><span class="line">            dfs(i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(i, j + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        visited = []</span><br><span class="line">        memory = &#123;&#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>

<p>计算位数的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 循环取余</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_digit</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> memory:</span><br><span class="line">        ret, y = <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">while</span> y:</span><br><span class="line">            ret += y % <span class="number">10</span></span><br><span class="line">            y = y // <span class="number">10</span></span><br><span class="line">        memory[x] = ret</span><br><span class="line">    <span class="keyword">return</span> memory[x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_digit</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> memory:</span><br><span class="line">       ret = sum([int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> str(x)])</span><br><span class="line">       memory[x] = ret</span><br><span class="line">    <span class="keyword">return</span> memory[x]</span><br></pre></td></tr></table></figure>

<h3 id="Best-Answer【DFS-深度搜索】"><a href="#Best-Answer【DFS-深度搜索】" class="headerlink" title="Best Answer【DFS 深度搜索】"></a>Best Answer【DFS 深度搜索】</h3><ul>
<li><p>解题思路：<code>DFS 搜索</code> + <code>数位和计算方式改进</code></p>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">Krahets-解题</a></p>
<p><a href="https://krahets.gitee.io/" target="_blank" rel="noopener">Krahets’s Blog</a> 这个大神些的东西，真的比原书的作者写的解法好，而且是python版</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200704123005.png" alt=""></p>
<p>数位和增量公式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_x + <span class="number">1</span> <span class="keyword">if</span> (x + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> s_x - <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200514214717.png" alt=""> </p>
<p><strong>代码如下【很精妙的写法】：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, si, sj)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj) \</span><br><span class="line">                     + dfs(i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Best-Answer-【BFS-广度搜索】"><a href="#Best-Answer-【BFS-广度搜索】" class="headerlink" title="Best Answer 【BFS 广度搜索】"></a>Best Answer 【BFS 广度搜索】</h3><p>解题思路：<code>BFS 广度搜索</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        queue, visited,  = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i, j, si, sj = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))</span><br><span class="line">            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))</span><br><span class="line">        <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>



<h2 id="面试题14-I-剪绳子【非常经典】"><a href="#面试题14-I-剪绳子【非常经典】" class="headerlink" title="面试题14- I. 剪绳子【非常经典】"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14- I. 剪绳子【非常经典】</a></h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/" target="_blank" rel="noopener">腐烂的橘子🍊</a></p>
</blockquote>
<h3 id="Answer-01-【暴力法】"><a href="#Answer-01-【暴力法】" class="headerlink" title="Answer 01 【暴力法】"></a>Answer 01 【暴力法】</h3><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200514215522.png" style="zoom: 50%;" />

<p>下面我们手算一下 $F(4)$ 的取值是从 $F(3)\times1, 3 \times 1;F(2)\times 2, 2\times 2;F(1)\times3, 1\times3$ 中挑选出最大的值。可以归纳出如下递归函数</p>
<p>$$<br>F(n)=max(i\times(n-i),i\times F(n-i)),i=1,2,…,n-2<br>$$</p>
<p>暴力法存在大量计算一定会<strong>超时</strong>，所以一般暴力法都是搭配 <code>记忆化矩阵</code> 一起 <code>食用</code></p>
<h3 id="Answer-02-【记忆化搜索】【自顶向下】"><a href="#Answer-02-【记忆化搜索】【自顶向下】" class="headerlink" title="Answer 02 【记忆化搜索】【自顶向下】"></a>Answer 02 【记忆化搜索】【自顶向下】</h3><ul>
<li><p>解题思路：<strong>记忆化技术（自顶向下）</strong></p>
<p>递归函数中存在大量重复的计算，记忆化技术，可以帮助缩小时间，通过计算机验证</p>
<blockquote>
<p>时间复杂度 $O(n^2)$  空间复杂度 $O(n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> memory: <span class="keyword">return</span> memory[n]</span><br><span class="line">            res = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                res = max(res, f(i) * (n - i), i * (n - i))</span><br><span class="line">            memory[n] = res</span><br><span class="line">            <span class="keyword">return</span> memory[n]</span><br><span class="line">        memory = &#123;<span class="number">1</span>: <span class="number">1</span>&#125; <span class="comment"># 可以将终止条件设置在 记忆化矩阵中</span></span><br><span class="line">        <span class="keyword">return</span> f(n)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="Best-Answer-【动态规划】【自底向上】"><a href="#Best-Answer-【动态规划】【自底向上】" class="headerlink" title="Best Answer 【动态规划】【自底向上】"></a>Best Answer 【动态规划】【自底向上】</h3><ul>
<li><p><strong>解题思路：动态规划（自底向上）(推荐方法)</strong></p>
<blockquote>
<p>时间复杂度 <code>O(n)</code> 空间复杂度 O(n)</p>
</blockquote>
<p>动态规划的核心是，设定边界条件 和 状态转移方程 。</p>
<p>建议一维动态数组 <code>dp</code> :</p>
<ul>
<li>边界条件：$dp[1] = dp[2] = 1$ ，表示长度为 2 的绳子最大乘积为 1；</li>
<li>状态转移方程： $dp[i] = max(dp[i], max((i-j)<em>j, j</em>dp[i-j]))$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200704150131.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        d = [ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        d[<span class="number">1</span>], d[<span class="number">2</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            res = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                res = max(res, j * (i - j), j * d[i-j])</span><br><span class="line">            d[i] = res</span><br><span class="line">        <span class="keyword">return</span> d[n]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Best-Answer-【动态规划空间优化】【自底向上】"><a href="#Best-Answer-【动态规划空间优化】【自底向上】" class="headerlink" title="Best Answer 【动态规划空间优化】【自底向上】"></a>Best Answer 【动态规划空间优化】【自底向上】</h3><blockquote>
<p>同 面试题10-I 斐波那契数列一样。同样可以针对空间复杂度优化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作者：z1m</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Best-Answer-【数学推导】"><a href="#Best-Answer-【数学推导】" class="headerlink" title="Best Answer 【数学推导】"></a>Best Answer 【数学推导】</h3><p>这一部分属于数据公式的证明，可以参考如下教程，比较清晰</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/" target="_blank" rel="noopener">面试题14- I. 剪绳子（数学推导 / 贪心思想，清晰图解）</a></p>
</blockquote>
<h2 id="面试题15-二进制中的1"><a href="#面试题15-二进制中的1" class="headerlink" title="面试题15-二进制中的1"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15-二进制中的1</a></h2><ul>
<li><p>解题思路：<code>位操作</code></p>
<ul>
<li><p>原码、反码、补码相关概念。 原码 取反 + 1 ==&gt; 补码</p>
<blockquote>
<p>教程：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></p>
</blockquote>
</li>
<li><p>相关位运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n &amp; 1 # n &amp; 1 验证最后一位是否是1</span><br><span class="line">n &gt;&gt; 1 # 等价于 n // 2 </span><br><span class="line">n &amp; (n - 1) #</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="My-Answer-【无符号位】【逐位判断】"><a href="#My-Answer-【无符号位】【逐位判断】" class="headerlink" title="My Answer 【无符号位】【逐位判断】"></a>My Answer 【无符号位】【逐位判断】</h3><blockquote>
<p>时间复杂度 $O(log_2n)$ 空间复杂度 $O(1)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="Graceful-Answer【无符号】【技巧法】"><a href="#Graceful-Answer【无符号】【技巧法】" class="headerlink" title="Graceful Answer【无符号】【技巧法】"></a>Graceful Answer【无符号】【技巧法】</h3><ul>
<li><p>解题思路：技巧： <code>n &amp; (n - 1)</code></p>
<ul>
<li>$(n - 1)$ 二进制最右边的 1变成0，0变成1</li>
<li>$n\times(n - 1)$ 二进制最右边的 1 变成 0，其余保持不变 。每一次 $n\times(n - 1)$都会消去一个0，直到消完为止。</li>
</ul>
<blockquote>
<p>时间复杂度 $O(M),M 代表数字N中1的个数$ 空间复杂度: $O(1)$</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200704162344.png" style="zoom: 50%;" />

  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题16. 数值的整数次方</a></h2><h3 id="Best-Answer-【递归法】【快速幂】"><a href="#Best-Answer-【递归法】【快速幂】" class="headerlink" title="Best Answer 【递归法】【快速幂】"></a>Best Answer 【递归法】【快速幂】</h3><ul>
<li><p>解题思路：<code>快速幂</code></p>
<p>二分推导：</p>
<ul>
<li>当 n 为偶数： $x^n=x^{n/2}\times x^{n/2}$</li>
<li>当 n 为奇数： $x^n=x^{n/2}\times x^{n/2}\times x$</li>
</ul>
<blockquote>
<p>时间复杂度为 $O(log_2n)$ 空间复杂度 $O(1)$</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">""" 分治法: 递归版 """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"0 is not invalid"</span>)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 这个特别容易漏</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> x </span><br><span class="line"></span><br><span class="line">        postivate_n = abs(n)</span><br><span class="line">        temp = self.myPow(x, postivate_n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        res = temp * temp * (x <span class="keyword">if</span> postivate_n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure>



<h3 id="Graceful-Answer-【数学递推法】【快速幂】"><a href="#Graceful-Answer-【数学递推法】【快速幂】" class="headerlink" title="Graceful Answer 【数学递推法】【快速幂】"></a>Graceful Answer 【数学递推法】【快速幂】</h3><ul>
<li><p>解题思路： <code>数据递推法</code> + <code>位运算</code></p>
<p>举例 $n = 9$ ，用二进制可表示为 $n = 9 = 1001_b$<br>$$<br>x^9 = 1\times x^{2^0} \times x^{2^3}<br>$$<br>这里，发现 $x^{2^0} = x$， 此时公式就变成<br>$$<br>x^9 = 1\times y \times y^3<br>$$<br>可以发现，只要对应二进制位为 0 的话，就不乘上去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        pos_n = abs(n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pos_n:</span><br><span class="line">            res = res * (x <span class="keyword">if</span> (pos_n &amp; <span class="number">1</span>) <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">            pos_n = pos_n &gt;&gt; <span class="number">1</span></span><br><span class="line">            x = x * x</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17. 打印从1到最大的n位数</a></h2><h3 id="Simple-Answer【简单版本】"><a href="#Simple-Answer【简单版本】" class="headerlink" title="Simple Answer【简单版本】"></a>Simple Answer【简单版本】</h3><ul>
<li><p>题解，本题对于 <code>Python</code>并不是一道简单的题目。难点是如何处理  <code>大数情况</code> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">1</span>, <span class="number">10</span>**n))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Hard-Answer-【大数版本】【全排列】"><a href="#Hard-Answer-【大数版本】【全排列】" class="headerlink" title="Hard Answer 【大数版本】【全排列】"></a>Hard Answer 【大数版本】【全排列】</h3><ul>
<li><p>解题思路：<code>全排列</code></p>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/" target="_blank" rel="noopener">面试题17. 打印从 1 到最大的 n 位数（分治算法 / 全排列，清晰图解）</a></p>
<p>时间复杂度  $O(10^n)$  空间复杂度 $O(1)$</p>
</blockquote>
<p>首先实现简单的实现  两个数字<code>0~9</code> 的全排列。可以通过 <code>递归</code> 去实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用递归实现 全排列问题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; [int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n: <span class="comment"># 终止条件：已固定完所有位</span></span><br><span class="line">                res.append(<span class="string">''</span>.join(num)) <span class="comment"># 拼接 num 并添加至 res 尾部</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 遍历 0 - 9</span></span><br><span class="line">                num[x] = str(i) <span class="comment"># 固定第 x 位为 i</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位</span></span><br><span class="line">        </span><br><span class="line">        num = [<span class="string">'0'</span>] * n <span class="comment"># 起始数字定义为 n 个 0 组成的字符列表</span></span><br><span class="line">        res = [] <span class="comment"># 数字字符串列表</span></span><br><span class="line">        dfs(<span class="number">0</span>) <span class="comment"># 开启全排列递归</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    res = printNumbers(<span class="number">2</span>)</span><br><span class="line">    print(res)</span><br><span class="line"><span class="comment"># output:  </span></span><br><span class="line"><span class="comment"># ['00', '01', '02', '03', '04', '05', ...., '97', '98', '99']</span></span><br></pre></td></tr></table></figure>

<p>接下来，需要对 <code>全排列</code> 做一下优化，去除多余的 0 和 从1开始输出</p>
<p>这样的改进，感觉就是修复逻辑漏洞一样，比较考察是否细心，这里就比较见仁见智了。这里我参考的是 <a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener">Krahets</a> 给的解法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n: <span class="comment"># 这一步复杂筛选和生产数字序列</span></span><br><span class="line">                s = <span class="string">''</span>.join(self.num)[self.digit:] <span class="comment"># '0001' =&gt; '1'</span></span><br><span class="line">                <span class="keyword">if</span> s == <span class="string">'0'</span>: <span class="keyword">return</span> <span class="comment"># 只处理 ’0000‘ 全零的这一情况</span></span><br><span class="line">                <span class="keyword">if</span> self.digit + self.nine == n : self.digit -= <span class="number">1</span></span><br><span class="line">                self.res.append(s)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 这一步复杂生产 '00', '01', '02' 这样的序列 </span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">9</span>: self.nine += <span class="number">1</span></span><br><span class="line">                self.num[x] = str(i)</span><br><span class="line">                dfs(x + <span class="number">1</span>)</span><br><span class="line">        self.num = [<span class="string">'0'</span>] * n</span><br><span class="line">        self.digit = n - <span class="number">1</span> <span class="comment"># 代表是从最后一位开始</span></span><br><span class="line">        self.nine = <span class="number">0</span> <span class="comment"># 记录是不是从 9</span></span><br><span class="line">        self.res = []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    res = Solution().printNumbers(<span class="number">2</span>)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></h2><h3 id="My-Answer【单指针】"><a href="#My-Answer【单指针】" class="headerlink" title="My Answer【单指针】"></a>My Answer【单指针】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">""" 单指针法 """</span></span><br><span class="line">        <span class="comment"># 删除头结点</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.next</span><br><span class="line">        </span><br><span class="line">        temp = head</span><br><span class="line">        <span class="comment"># 非头结点</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">and</span> temp.next:</span><br><span class="line">            <span class="keyword">if</span> temp.next.val == val <span class="keyword">and</span> temp.next:</span><br><span class="line">                temp.next = temp.next.next</span><br><span class="line">            temp = temp.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>



<h3 id="My-Answer【双指针】【较为清晰】"><a href="#My-Answer【双指针】【较为清晰】" class="headerlink" title="My Answer【双指针】【较为清晰】"></a>My Answer【双指针】【较为清晰】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">""" 双指针法 """</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.next <span class="comment"># 如果正好是头结点</span></span><br><span class="line">        pre, cur = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, cur = pre.next, cur.next</span><br></pre></td></tr></table></figure>



<h3 id="Other-Answer-【递归】"><a href="#Other-Answer-【递归】" class="headerlink" title="Other Answer 【递归】"></a>Other Answer 【递归】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        head.next = self.deleteNode(head.next, val)</span><br><span class="line">        <span class="keyword">return</span> head.next <span class="keyword">if</span> head.val == val <span class="keyword">else</span> head</span><br></pre></td></tr></table></figure>



<h2 id="面试题19-正则表达式匹配【困难】"><a href="#面试题19-正则表达式匹配【困难】" class="headerlink" title="面试题19. 正则表达式匹配【困难】"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">面试题19. 正则表达式匹配【困难】</a></h2><p>本题的 【Hard】模式，正是因为考虑的情形比较多，很容易一些小细节漏做。尽管整理的时候已经是二次刷题了，但是还是花了 <code>1H</code> 调试+重写才成功</p>
<h3 id="My-Answer-【递归法】"><a href="#My-Answer-【递归法】" class="headerlink" title="My Answer 【递归法】"></a>My Answer 【递归法】</h3><ul>
<li><p>解题思路：<code>递归法</code></p>
<p>考虑到的极端情况</p>
<ul>
<li>ab &lt;–&gt; ab</li>
<li>ab &lt;–&gt; .*</li>
<li>ab* 的时候，b 零次的信息很容易漏掉</li>
<li>终止条件： <code>if not p: return not a</code></li>
<li>判断相等逻辑： <code>p[0] in {s[i], &#39;.&#39;}</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># ab &lt;--&gt; a* 带星号的一定要先处理，不然在 s='' p='*b'的时候会出错</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">             <span class="keyword">if</span> self.isMatch(s, p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 零次情况考虑到</span></span><br><span class="line">             i = <span class="number">0</span></span><br><span class="line">             <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;: <span class="comment"># aaab a*b</span></span><br><span class="line">                <span class="keyword">if</span> self.isMatch(s[i+<span class="number">1</span>:], p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;: <span class="comment"># ab &lt;--&gt; ab</span></span><br><span class="line">             <span class="keyword">return</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>于此，我们又发现可以改进的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;: <span class="comment"># aaab a*b</span></span><br><span class="line">     <span class="keyword">if</span> self.isMatch(s[i+<span class="number">1</span>:], p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>可以列一张表，看到这里的 <code>while</code> 循环是不必要的，因为递归程序会帮我们一次次最终走到 <code>* 三次</code> 的情况，不需要我们自己显式的去写出，而且就算写出了，程序也走不到。</p>
<table>
<thead>
<tr>
<th></th>
<th>s</th>
<th>p</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>原始</td>
<td>aaab</td>
<td>a*b</td>
<td><em>True</em></td>
</tr>
<tr>
<td>* 零次</td>
<td>aaab</td>
<td>b</td>
<td>False</td>
</tr>
<tr>
<td>* 一次</td>
<td>aab</td>
<td>b</td>
<td>False–&gt; * 二次</td>
</tr>
<tr>
<td>* 二次</td>
<td>ab</td>
<td>b</td>
<td>False–&gt;* 三次</td>
</tr>
<tr>
<td>* 三次</td>
<td>b</td>
<td>b</td>
<td>True</td>
</tr>
</tbody></table>
<p>改进的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># ab &lt;--&gt; a* 带星号的一定要先处理，不然在 s='' p='*b'的时候会出错</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">             <span class="keyword">if</span> self.isMatch(s, p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 零次情况考虑到</span></span><br><span class="line">             <span class="keyword">if</span> p <span class="keyword">and</span> s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125; <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p): <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;: <span class="comment"># ab &lt;--&gt; ab</span></span><br><span class="line">             <span class="keyword">return</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Graceful-Answer【递归法】【大神代码】"><a href="#Graceful-Answer【递归法】【大神代码】" class="headerlink" title="Graceful Answer【递归法】【大神代码】"></a>Graceful Answer【递归法】【大神代码】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作者：z1m</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字母是否匹配</span></span><br><span class="line">        first_match = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;)</span><br><span class="line">        <span class="comment"># 如果 p 第二个字母是 *</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">            first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h3 id="Graceful-Answer-【倒查递归】【大神代码】"><a href="#Graceful-Answer-【倒查递归】【大神代码】" class="headerlink" title="Graceful Answer 【倒查递归】【大神代码】"></a>Graceful Answer 【倒查递归】【大神代码】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       倒查递归，思路参考</span></span><br><span class="line"><span class="string">       https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">       1. 正则串是 正常字符串匹配/. s[:n-2] p[:m-2]</span></span><br><span class="line"><span class="string">       2. 正则串带 * </span></span><br><span class="line"><span class="string">             a. 先直接去除 c* s,p[:m-2] </span></span><br><span class="line"><span class="string">             b. 如果匹配*前的字符串， s[:n-1] p</span></span><br><span class="line"><span class="string">       3、 正常字符串 不匹配 直接返回False</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> p : <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">       <span class="keyword">if</span> s <span class="keyword">and</span> p[<span class="number">-1</span>] <span class="keyword">in</span> &#123;s[<span class="number">-1</span>], <span class="string">'.'</span>&#125;: </span><br><span class="line">           <span class="keyword">return</span> self.isMatch(s[:<span class="number">-1</span>], p[:<span class="number">-1</span>])</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> p[<span class="number">-1</span>] == <span class="string">'*'</span>:</span><br><span class="line">           <span class="keyword">return</span> self.isMatch(s, p[:<span class="number">-2</span>]) <span class="keyword">or</span> \</span><br><span class="line">                  bool(s <span class="keyword">and</span> p[<span class="number">-2</span>] <span class="keyword">in</span> &#123;s[<span class="number">-1</span>], <span class="string">'.'</span>&#125; <span class="keyword">and</span> self.isMatch(s[:<span class="number">-1</span>], p))</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="Graceful-Answer-【动态规划】"><a href="#Graceful-Answer-【动态规划】" class="headerlink" title="Graceful Answer 【动态规划】"></a>Graceful Answer 【动态规划】</h3><p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200705160832.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作者：z1m</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 边界条件，考虑 s 或 p 分别为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> len(p) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m, n = len(s) + <span class="number">1</span>, len(p) + <span class="number">1</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            j = c - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][c] = dp[<span class="number">0</span>][c - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            i = r - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                j = c - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'.'</span>:</span><br><span class="line">                    dp[r][c] = dp[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:       <span class="comment"># ‘*’前面的字符匹配s[i] 或者为'.'</span></span><br><span class="line">                    <span class="keyword">if</span> p[j - <span class="number">1</span>] == s[i] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[r][c] = dp[r - <span class="number">1</span>][c] <span class="keyword">or</span> dp[r][c - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:                       <span class="comment"># ‘*’匹配了0次前面的字符</span></span><br><span class="line">                        dp[r][c] = dp[r][c - <span class="number">2</span>] </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[r][c] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="面试题21-调整数组顺序使奇数位于偶数前面"><a href="#面试题21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21. 调整数组顺序使奇数位于偶数前面</a></h2><h3 id="Best-Answer【快排思路】【首尾双指针】"><a href="#Best-Answer【快排思路】【首尾双指针】" class="headerlink" title="Best Answer【快排思路】【首尾双指针】"></a>Best Answer【快排思路】【首尾双指针】</h3><ul>
<li><p>解题思路： <code>快排思想</code></p>
<p>主要变动的是在判断的依据上</p>
<blockquote>
<p>时间复杂度 $O(n)$   空间复杂度 $O(1)$</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums) - <span class="number">1</span> </span><br><span class="line">        temp = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            nums[right] = nums[left]</span><br><span class="line">        nums[right] = temp</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<p>更加简单一点的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/mian-shi-ti-21-diao-zheng-shu-zu-shun-xu-shi-qi-4/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>: j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h3 id="Best-Answer-【首端快慢指针】"><a href="#Best-Answer-【首端快慢指针】" class="headerlink" title="Best Answer 【首端快慢指针】"></a>Best Answer 【首端快慢指针】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 首端快慢指针</span></span><br><span class="line">        i, j, size = <span class="number">-1</span>, <span class="number">-1</span>, len(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; size - <span class="number">1</span>: </span><br><span class="line">             i += <span class="number">1</span></span><br><span class="line">             <span class="keyword">if</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>: <span class="comment"># 找到奇数</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h3 id="Simple-Answer-【辅助数组】"><a href="#Simple-Answer-【辅助数组】" class="headerlink" title="Simple Answer 【辅助数组】"></a>Simple Answer 【辅助数组】</h3><blockquote>
<p>时间复杂度 $O(n)$   空间复杂度 $O(n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        num1, num2 = [], []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: num1.append(n)</span><br><span class="line">            <span class="keyword">else</span>: num2.append(n)</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br></pre></td></tr></table></figure>



<h2 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h2><h3 id="Simple-Answer【辅助数组】"><a href="#Simple-Answer【辅助数组】" class="headerlink" title="Simple Answer【辅助数组】"></a>Simple Answer【辅助数组】</h3><blockquote>
<p>时间复杂度 $O(n)$  空间复杂度 $O(n)$ </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        arr = []</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head)</span><br><span class="line">            head = head.next </span><br><span class="line">        return arr[-1*k]</span><br></pre></td></tr></table></figure>



<h3 id="Best-Answer-【双指针】"><a href="#Best-Answer-【双指针】" class="headerlink" title="Best Answer 【双指针】"></a>Best Answer 【双指针】</h3><ul>
<li>解题思路： <code>双指</code> ，<code>两步走</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        h1, h2 = head, head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k): <span class="comment"># h1 先走 k 步</span></span><br><span class="line">            h1 = h1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> h1: <span class="comment"># h1 走完</span></span><br><span class="line">            h1 = h1.next</span><br><span class="line">            h2 = h2.next <span class="comment"># 此时 h2 走了 n-k 步，即倒数第k个节点</span></span><br><span class="line">        <span class="keyword">return</span> h2</span><br></pre></td></tr></table></figure>



<h2 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a></h2><h3 id="My-Answer-1-【双指针头尾交换】"><a href="#My-Answer-1-【双指针头尾交换】" class="headerlink" title="My Answer 1 【双指针头尾交换】"></a>My Answer 1 【双指针头尾交换】</h3><blockquote>
<p>图参考：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/" target="_blank" rel="noopener">【反转链表】：双指针，递归，妖魔化的双指针</a></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200705211833.png" style="zoom: 50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">""" 双指针"""</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur_next_bak = cur.next <span class="comment"># 因为cur.next 马上要指向前节点，这里做个备份</span></span><br><span class="line">            cur.next = pre</span><br><span class="line"></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur_next_bak</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>



<h3 id="My-Answer-2【递归】【理解有点难度】"><a href="#My-Answer-2【递归】【理解有点难度】" class="headerlink" title="My Answer 2【递归】【理解有点难度】"></a>My Answer 2【递归】【理解有点难度】</h3><blockquote>
<p>动图来自：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/" target="_blank" rel="noopener">动画演示+多种解法 面试题24. 反转链表</a></p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        </span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>



<h3 id="My-Answer-3【辅助空间】"><a href="#My-Answer-3【辅助空间】" class="headerlink" title="My Answer 3【辅助空间】"></a>My Answer 3【辅助空间】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node = ListNode(head.val)</span><br><span class="line">            node.next = ret</span><br><span class="line">            ret = node</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



<h2 id="面试题25-合并两个排序的链表【经典】"><a href="#面试题25-合并两个排序的链表【经典】" class="headerlink" title="面试题25. 合并两个排序的链表【经典】"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表【经典】</a></h2><h3 id="Best-Answer-3"><a href="#Best-Answer-3" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li>引入一个头节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        sortedList = ListNode(<span class="literal">None</span>) <span class="comment"># 伪节点</span></span><br><span class="line">        head = sortedList</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l2.val &gt; l1.val:</span><br><span class="line">                node = ListNode(l1.val)</span><br><span class="line">                sortedList.next = node</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = ListNode(l2.val)</span><br><span class="line">                sortedList.next = node</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            sortedList = sortedList.next</span><br><span class="line">        sortedList.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2 <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>



<h2 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></h2><h3 id="Best-Answer-【递归】"><a href="#Best-Answer-【递归】" class="headerlink" title="Best Answer 【递归】"></a>Best Answer 【递归】</h3><ul>
<li>解题技巧<ul>
<li>在  return 中，加入<code>bool(A and B)</code> 来代替 <code>if not A and not B: return False</code> ，显得更加简洁</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B: <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">and</span> A.val != B.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 头结点匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> recur(A.left, B.left) <span class="keyword">and</span> recur(A.right, B.right)</span><br><span class="line">        <span class="keyword">return</span> bool(A <span class="keyword">and</span> B) <span class="keyword">and</span>  <span class="comment"># 空树不是任意一个树的子节点\ </span></span><br><span class="line">               (recur(A, B) <span class="keyword">or</span> recur(A.left, B) <span class="keyword">or</span> recur(A.right, B))</span><br></pre></td></tr></table></figure>



<h2 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></h2><h3 id="Best-Answer【递归】"><a href="#Best-Answer【递归】" class="headerlink" title="Best  Answer【递归】"></a>Best  Answer【递归】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></h2><h3 id="Best-Answer-【递归】-1"><a href="#Best-Answer-【递归】-1" class="headerlink" title="Best Answer 【递归】"></a>Best Answer 【递归】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compareTree</span><span class="params">(treeA, treeB)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> treeA <span class="keyword">and</span> <span class="keyword">not</span> treeB: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> treeA <span class="keyword">or</span> <span class="keyword">not</span> treeB: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> treeA.val != treeB.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> compareTree(treeA.left, treeB.right) <span class="keyword">and</span> \</span><br><span class="line">                   compareTree(treeA.right, treeB.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> compareTree(root.left, root.right)</span><br></pre></td></tr></table></figure>



<h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></h2><p>My Answer 【寻找规律】</p>
<ul>
<li><p>解题思路：</p>
<p>可以通过观察，发现每次 横向移动的时候，移动的长度会减一。纵向移动同样如此。</p>
<p>如一个 $3 \times 3$ 的矩阵，规律为：向右移动3次，向下移动2次，向左移动2次，向上移动1次，向右移动1次。</p>
<p>我们给横向移动设置初始值值 3，纵向移动 2。每次移动完了就减一。</p>
<blockquote>
<p>这里需要考虑终止条件的位置：一定是在移动之前检查本方向是否已终止</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        xlen, ylen = len(matrix[<span class="number">0</span>]), len(matrix) - <span class="number">1</span></span><br><span class="line">        x, y = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        direction = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)] <span class="comment"># 右下左上</span></span><br><span class="line">        dflag = <span class="number">0</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> xlen: <span class="keyword">break</span> <span class="comment"># 在横向移动之前，检查能否移动，不能的话一定是代表结束</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(xlen): <span class="comment"># 横向打印</span></span><br><span class="line">                x = x + direction[dflag][<span class="number">0</span>]</span><br><span class="line">                y = y + direction[dflag][<span class="number">1</span>]</span><br><span class="line">                ret.append(matrix[y][x])</span><br><span class="line">            </span><br><span class="line">            xlen -= <span class="number">1</span></span><br><span class="line">            dflag = (dflag + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ylen: <span class="keyword">break</span> <span class="comment"># 在纵向向移动之前，检查能否移动，不能的话一定是代表结束</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(ylen): <span class="comment"># 横向打印</span></span><br><span class="line">                x = x + direction[dflag][<span class="number">0</span>]</span><br><span class="line">                y = y + direction[dflag][<span class="number">1</span>]</span><br><span class="line">                ret.append(matrix[y][x])</span><br><span class="line">            ylen -= <span class="number">1</span></span><br><span class="line">            dflag = (dflag + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题30-包含min函数的栈【思路经典】"><a href="#面试题30-包含min函数的栈【思路经典】" class="headerlink" title="面试题30. 包含min函数的栈【思路经典】"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈【思路经典】</a></h2><h3 id="Best-Answer-4"><a href="#Best-Answer-4" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li>解题思路：<code>辅助栈</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">            self.B.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span><br><span class="line">            self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="面试题31-栈的压入、弹出序列"><a href="#面试题31-栈的压入、弹出序列" class="headerlink" title="面试题31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></h2><h3 id="Best-Answer-【模拟法】"><a href="#Best-Answer-【模拟法】" class="headerlink" title="Best Answer 【模拟法】"></a>Best Answer 【模拟法】</h3><ul>
<li>解题思路：<br>由于题目中假定了两个队列长度相等，栈内元素不同。这一假设大大简化了问题的复杂程度</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed: List[int], popped: List[int])</span> -&gt; bool:</span></span><br><span class="line">        tempList = []</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> pushed:</span><br><span class="line">            tempList.append(each)</span><br><span class="line">            <span class="keyword">while</span> tempList <span class="keyword">and</span> tempList[<span class="number">-1</span>] == popped[<span class="number">0</span>]:</span><br><span class="line">                tempList.pop()</span><br><span class="line">                popped = popped[<span class="number">1</span>:]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> popped <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></h2><h3 id="Best-Answer【经典算法】【二叉树的层次遍历】"><a href="#Best-Answer【经典算法】【二叉树的层次遍历】" class="headerlink" title="Best Answer【经典算法】【二叉树的层次遍历】"></a>Best Answer【经典算法】【二叉树的层次遍历】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root : <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, queue = queue[<span class="number">0</span>], queue[<span class="number">1</span>:]</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 利用 collection.deque 实现队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root : <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></h2><h3 id="Best-Answer-【层次遍历升级】"><a href="#Best-Answer-【层次遍历升级】" class="headerlink" title="Best Answer 【层次遍历升级】"></a>Best Answer 【层次遍历升级】</h3><ul>
<li><p>解题思路：</p>
<p>核心解决的就是层与层的区分</p>
<ul>
<li>通过标记层号解决</li>
<li>通过queue的长度来区分层</li>
</ul>
</li>
<li><p>【标记层号】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, level = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> level &gt; len(res) - <span class="number">1</span>: res.append([])</span><br><span class="line">            res[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append((node.left, level + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append((node.right, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>【根据queue长度】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            _res = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                _res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(_res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题32-III-从上到下打印二叉树-III"><a href="#面试题32-III-从上到下打印二叉树-III" class="headerlink" title="面试题32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III（层序遍历 BFS / 双端队列，清晰图解）</a> </p>
</blockquote>
<h3 id="Best-Answer-5"><a href="#Best-Answer-5" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：</p>
<ul>
<li><p><code>层次遍历</code> + <code>双端队列</code> </p>
<p>在奇偶层节点加入上，奇数层从左端加入，偶数层在右端加入 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp.appendleft()</span><br><span class="line">temp.append()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            temp = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> len(res) &amp; <span class="number">1</span> == <span class="number">0</span>: temp.append(node.val)</span><br><span class="line">                <span class="keyword">else</span>: temp.appendleft(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(list(temp))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>层次遍历</code> + <code>奇偶逻辑分开</code> （略）</p>
<p>在出队的时候，奇数层从左端出队，偶数层从右端出队</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.popleft()</span><br><span class="line">queue.pop()</span><br></pre></td></tr></table></figure>
</li>
<li><p>仅对 <code>面试题32-II</code> 的顺序进行调整 （略）</p>
</li>
</ul>
</li>
</ul>
<h2 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a></h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列（递归分治 / 单调栈，清晰图解）</a></p>
</blockquote>
<h3 id="Best-Answer-6"><a href="#Best-Answer-6" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：<code>递归分治</code></p>
<ul>
<li>判断当前根是否存在错误 ，即 <code>是否符合  左 &lt; 根 &lt; 右</code></li>
<li><code>self.verifyPostorder(postorder[: m])</code> 判断左子树是否正确</li>
<li><code>self.verifyPostorder(postorder[m : -1])</code> 判断右子树是否正确</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200707205301.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断是否符合 左&lt;根&lt;右</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root: <span class="keyword">break</span></span><br><span class="line">        m = i <span class="comment"># m 为右子树的第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, len(postorder) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &lt; root: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 右子树出现了比根节点小的节点。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.verifyPostorder(postorder[: m]) <span class="keyword">and</span> \</span><br><span class="line">               self.verifyPostorder(postorder[m : <span class="number">-1</span>])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h2><p>待整理</p>
<h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></h2><p>待整理</p>
<h2 id="面试题36-二叉搜索树与双向链表【困难】"><a href="#面试题36-二叉搜索树与双向链表【困难】" class="headerlink" title="面试题36. 二叉搜索树与双向链表【困难】"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表【困难】</a></h2><h3 id="My-Answer-【中序遍历】【辅助队列】"><a href="#My-Answer-【中序遍历】【辅助队列】" class="headerlink" title="My Answer 【中序遍历】【辅助队列】"></a>My Answer 【中序遍历】【辅助队列】</h3><ul>
<li><p>解题思路：<code>中序遍历</code> + <code>辅助队列</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span> <span class="comment"># 中序遍历</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> []</span><br><span class="line">            dfs(cur.left) <span class="comment"># 左</span></span><br><span class="line">            res.append(cur) <span class="comment"># 中</span></span><br><span class="line">            dfs(cur.right) <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 根据 队列，前后链接链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(res) - <span class="number">1</span>):</span><br><span class="line">            res[i].right = res[i + <span class="number">1</span>]</span><br><span class="line">            res[i+<span class="number">1</span>].left = res[i]</span><br><span class="line">        <span class="comment"># 头尾特殊处理</span></span><br><span class="line">        res[<span class="number">0</span>].left = res[<span class="number">-1</span>] </span><br><span class="line">        res[<span class="number">-1</span>].right = res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Best-Answer-【中序遍历】【双指针改进】"><a href="#Best-Answer-【中序遍历】【双指针改进】" class="headerlink" title="Best Answer 【中序遍历】【双指针改进】"></a>Best Answer 【中序遍历】【双指针改进】</h3><ul>
<li><p>解题思路</p>
<p>上述方法虽然简单，但是借助了 <code>辅助队列</code> ，可以利用双指针改进</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            <span class="keyword">if</span> self.pre:</span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.head = cur <span class="comment"># 此时记录的是头结点</span></span><br><span class="line">            self.pre = cur <span class="comment"># 最后遍历的是尾结点</span></span><br><span class="line">            dfs(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head </span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题37-序列化二叉树【困难】"><a href="#面试题37-序列化二叉树【困难】" class="headerlink" title="面试题37. 序列化二叉树【困难】"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树【困难】</a></h2><h3 id="Best-Answer-7"><a href="#Best-Answer-7" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：<code>层次遍历</code></p>
<p>我们可以根据 level 层级，限制最后生成 <code>队列</code> 的长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                   res.append(node.val)</span><br><span class="line">                   queue.append(node.left)</span><br><span class="line">                   queue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                   res.append(<span class="string">"null"</span>)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        level -= <span class="number">1</span> <span class="comment"># 减一后的level是真实的 层数</span></span><br><span class="line">        res = res[:<span class="number">2</span>**level - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + <span class="string">","</span>.join([str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> res]) + <span class="string">"]"</span></span><br><span class="line">             </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">"[]"</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        vals, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>])) </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> i &lt; len(vals):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                 node.left = TreeNode(int(vals[i]))</span><br><span class="line">                 queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                 node.right = TreeNode(int(vals[i]))</span><br><span class="line">                 queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题38-字符串的排列【全排列】"><a href="#面试题38-字符串的排列【全排列】" class="headerlink" title="面试题38. 字符串的排列【全排列】"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38. 字符串的排列【全排列】</a></h2><h3 id="Best-Answer-8"><a href="#Best-Answer-8" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：<code>回溯</code> + <code>交换</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="My-Answer"><a href="#My-Answer" class="headerlink" title="My Answer"></a>My Answer</h3><ul>
<li><p>解题思路： <code>回溯</code> + <code>辅助站</code></p>
<p>每一位上只能使用一次，故用 <code>visited 矩阵</code> 记录的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(st)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(st) == len(s):</span><br><span class="line">                 res.append(st)</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.append(i)</span><br><span class="line">                    recur(st + s[i])</span><br><span class="line">                    visited.remove(i)</span><br><span class="line"></span><br><span class="line">        visited, res = [], []</span><br><span class="line">        recur(<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题39-数组中出现次数超过一半的数字"><a href="#面试题39-数组中出现次数超过一半的数字" class="headerlink" title="面试题39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>哈希表统计法： 遍历数组 nums ，用 HashMap 统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为 $O(N)$ 。</li>
<li>数组排序法： 将数组 nums 排序，由于众数的数量超过数组长度一半，因此 数组中点的元素 一定为众数。此方法时间复杂度 $O(N log_2 N)$</li>
<li><strong>摩尔投票法：</strong> 核心理念为 <strong>“正负抵消”</strong> ；时间和空间复杂度分别为 $O(N)$ 和 $O(1)$；是本题的最佳解法。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200708172711.png" style="zoom:50%;" />

</li>
</ul>
<h3 id="Best-Answer-【摩尔投票法】"><a href="#Best-Answer-【摩尔投票法】" class="headerlink" title="Best Answer 【摩尔投票法】"></a>Best Answer 【摩尔投票法】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        votes, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>: x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 验证 x 是否为众数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == x: count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 当无众数时返回 0</span></span><br></pre></td></tr></table></figure>



<h2 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></h2><ul>
<li><p>解题思路：</p>
<ul>
<li><p><code>快排</code> + <code>筛选</code></p>
<blockquote>
<p>时间复杂度: $O(N log_2 N)$， 空间复杂度 $O(1)$</p>
</blockquote>
</li>
<li><p><code>堆排</code></p>
<blockquote>
<p>时间复制度：$O(Nlog_2k)$ ，空间复杂度 $O(N)$</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="My-Answer1【快排】"><a href="#My-Answer1【快排】" class="headerlink" title="My Answer1【快排】"></a>My Answer1【快排】</h3><ul>
<li><p><code>快排</code> + <code>筛选</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快排 + 筛选</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span> </span><br><span class="line">            pivot = nums[start]</span><br><span class="line">            low, high = start, end</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] &gt;= pivot: high -= <span class="number">1</span></span><br><span class="line">                nums[low] = nums[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] &lt; pivot: low += <span class="number">1</span></span><br><span class="line">                nums[high] = nums[low]</span><br><span class="line">            nums[low] = pivot</span><br><span class="line">            quicksort(nums, start, low - <span class="number">1</span>)</span><br><span class="line">            quicksort(nums, low + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">        quicksort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]  <span class="comment"># 筛选</span></span><br></pre></td></tr></table></figure>

<p>上面的方法没有利用到 <code>快排</code> 的性质，由于每次排完之后，存在 <code>左 &lt; 中 &lt; 右</code> </p>
<ul>
<li><code>中 == k - 1</code> 我们已经获得了前K个元素，但是也没有排序</li>
<li><code>中 &gt; k - 1</code> 只需要在左边找</li>
<li><code>中 &lt; k - 1</code> 只需要在右边找</li>
</ul>
</li>
<li><p>利用<code>快排</code> 性质</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span> </span><br><span class="line">            pivot = nums[start]</span><br><span class="line">            low, high = start, end</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] &gt;= pivot: high -= <span class="number">1</span></span><br><span class="line">                nums[low] = nums[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] &lt; pivot: low += <span class="number">1</span></span><br><span class="line">                nums[high] = nums[low]</span><br><span class="line">            nums[low] = pivot</span><br><span class="line">            <span class="keyword">if</span> low == k - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> arr[:k]</span><br><span class="line">            <span class="keyword">elif</span> low &lt; k - <span class="number">1</span>:</span><br><span class="line">                quicksort(nums, low + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                quicksort(nums, start, low - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="My-Answer2-【堆排】"><a href="#My-Answer2-【堆排】" class="headerlink" title="My Answer2 【堆排】"></a>My Answer2 【堆排】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, i, size)</span>:</span></span><br><span class="line">           lchild = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">           rchild = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">           max = i</span><br><span class="line">           <span class="keyword">if</span> i &lt; size / <span class="number">2</span>:</span><br><span class="line">               <span class="keyword">if</span> lchild &lt; size <span class="keyword">and</span> nums[lchild] &gt; nums[max]: max = lchild</span><br><span class="line">               <span class="keyword">if</span> rchild &lt; size <span class="keyword">and</span> nums[rchild] &gt; nums[max]: max = rchild</span><br><span class="line">               <span class="keyword">if</span> max != i:</span><br><span class="line">                   nums[max], nums[i] = nums[i], nums[max]</span><br><span class="line">                   adjust_heap(nums, max, size)</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(nums)</span>:</span></span><br><span class="line">            size = len(nums)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size &gt;&gt; <span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">                adjust_heap(nums, i, size)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> arr: <span class="keyword">return</span> []</span><br><span class="line">       arr = [<span class="number">-1</span> * _ <span class="keyword">for</span> _ <span class="keyword">in</span> arr]</span><br><span class="line">       build_heap(arr)</span><br><span class="line">       size = len(arr)</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>, len(arr) - <span class="number">1</span> - k, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#    print(arr)</span></span><br><span class="line">           arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">           adjust_heap(arr, <span class="number">0</span>, i)</span><br><span class="line">       arr = [<span class="number">-1</span> * _ <span class="keyword">for</span> _ <span class="keyword">in</span> arr][::<span class="number">-1</span>]</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure>

<p>堆排可以直接使用 <code>python</code> 自带的 <code>堆结构</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k: int)</span> :</span></span><br><span class="line">        shuffle(arr)  <span class="comment"># 随机排序</span></span><br><span class="line">        heapq.heapify(arr) <span class="comment"># 建立堆结构</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nsmallest(k, arr)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>heapq 模块的使用 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">heapq.heappush(heap, item) <span class="comment"># 添加元素</span></span><br><span class="line">heapq.heappop(heap) <span class="comment"># 弹出元素</span></span><br><span class="line">heapq.heappushpop(heap, item) <span class="comment">#添加元素后，再弹出一个元素，比 heappush + heappop 更高效</span></span><br><span class="line">heapq.heapreplace(heap, item) <span class="comment">#添加元素后，返回的是原数组中最小的元素</span></span><br><span class="line">heapq.heapify(x) <span class="comment"># 堆的初始化</span></span><br><span class="line">heapq.nlargest(n, heap) <span class="comment"># 最大n个元素</span></span><br><span class="line">heapq.nsmallest(n, heap) <span class="comment"># 最小n个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heapreplace vs heappushpop </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapify(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappushpop(a, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapreplace(b, <span class="number">-1</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="面试题41-数据流中的中位数【困难】"><a href="#面试题41-数据流中的中位数【困难】" class="headerlink" title="面试题41. 数据流中的中位数【困难】"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数【困难】</a></h2><h3 id="Best-Answer【优先队列】"><a href="#Best-Answer【优先队列】" class="headerlink" title="Best Answer【优先队列】"></a>Best Answer【优先队列】</h3><ul>
<li><p>解题思路：</p>
<p>维持两个根堆，一个是大顶堆A，一个是小顶堆B。其中A的最大元素 小于 B的最小元素。</p>
<p>寻找中位数的思路：<strong>令m为A的长度，n为B的长度，N为总长度​</strong></p>
<ul>
<li>当 m = n 时，证明N为偶数，中位数为 (A的堆顶 + B的堆顶)/2</li>
<li>当 m != n 时，证明N为奇数，中位数为A的堆顶(也可以取B的堆顶，类推)</li>
<li>Tips:<ul>
<li>为了保存中位数一直在A的堆顶，要保证A的长度始终要大于等于B。而且所有元素一定要在A，B中都调整过。</li>
<li>当 m = n 时，应该向A推元素，故应<strong>先推B，再推A</strong>，此时 A 有 m + 1 个，B有 n 个</li>
<li>当 m != n 时，应该向B推元素，因为我们始终保持的是A的数量大于B。即 m &gt;= n。故应<strong>先推A再推B</strong>，此时 A 有 m，B 有 n + 1 个</li>
<li>我们可以看出，先推的那个总是长度不变的，可以直接使用 <code>heapq.hashpushpop()</code> 方法</li>
<li>A 是大堆顶，故 <code>push&amp;pop</code> 的时候应该注意使用负数。heapq 实现了小顶堆，需要借助 负号 实现大根堆</li>
</ul>
</li>
</ul>
<blockquote>
<p>时间复杂度：$O(logn)$。堆插入和删除需要$O(logn)$，查找中位数需要$O(1)$。<br>空间复杂度：$O(n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max_heap, self.min_heap = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">             heapq.heappush(self.max_heap,</span><br><span class="line">                            -heapq.heappushpop(self.min_heap, num)) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             heapq.heappush(self.min_heap,</span><br><span class="line">                            -heapq.heappushpop(self.max_heap, -num))</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">            <span class="keyword">return</span> (- self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> - self.max_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Best-Answer【折半直接插入】"><a href="#Best-Answer【折半直接插入】" class="headerlink" title="Best Answer【折半直接插入】"></a>Best Answer【折半直接插入】</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/u/z1m/" target="_blank" rel="noopener">腐烂的橘子🍊</a>  <a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/you-xian-dui-lie-by-z1m/" target="_blank" rel="noopener">图解 排序+二分查找+优先队列</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<p>排序法是针对无序数组，本题中最适合的排序方法是 <strong>直接插入排序</strong>，Python 自带的 <code>bisect</code> 已经为我们提前实现了 <code>二分插入</code> </p>
<p>Tips:</p>
<ul>
<li><p>当 数组长度为奇数时，直接返回中位数：<code>nums[len(nums)&gt;&gt;1]</code></p>
</li>
<li><p>当 数组长度为偶数时，直接返回平均数：</p>
<p><code>(nums[len(nums)//2] + nums[len(nums)//2 +1])/2</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a 查找数组；x为插入的元素；lo,hi 约定为数组的范围</span></span><br><span class="line">bisect.insort(a, x, lo=<span class="number">0</span>, hi=len(a)) <span class="comment"># 折半插入，若存在x则插入x的右侧</span></span><br><span class="line">bisect.insort_right <span class="comment"># 同 bisect.insort</span></span><br><span class="line">bisect.insort_left <span class="comment">#  折半插入，若存在x则插入x的左侧</span></span><br><span class="line"><span class="comment"># 有以下三种方法，对应上面的插入方法。不同的是，它们只返回应插入的位置</span></span><br><span class="line">bisect.bisect</span><br><span class="line">bisect.bisect_left</span><br><span class="line">bisect.bisect_right</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        bisect.insort(self.A, num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        size = len(self.A)</span><br><span class="line">        <span class="keyword">if</span> size &amp; <span class="number">1</span> == <span class="number">0</span>: <span class="comment"># even</span></span><br><span class="line">            <span class="keyword">return</span> (self.A[size &gt;&gt; <span class="number">1</span>] + self.A[(size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>]) / <span class="number">2</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.A[size &gt;&gt; <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42. 连续子数组的最大和</a></h2><blockquote>
<p>参考<a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener">Krahets</a> 的 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener">方法总结</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>常见解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>暴力搜索</td>
<td>$O(N^2)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>分治思想</td>
<td>$O(NlogN)$</td>
<td>$O(logN)$</td>
</tr>
<tr>
<td>动态规划</td>
<td>$O(N)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>剪枝法</td>
<td>$O(N)$</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<h3 id="Best-Answer-【暴力-剪枝】"><a href="#Best-Answer-【暴力-剪枝】" class="headerlink" title="Best Answer 【暴力+剪枝】"></a>Best Answer 【暴力+剪枝】</h3><ul>
<li><p>解题思路：</p>
<p>只需要 保证求出的 sum 始终大于 0 即可，若是小于0，完全可以直接丢弃。</p>
<blockquote>
<p>本质算是暴力法的剪枝，这种剪枝巧妙的利用了规律</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 64ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        s, ret = <span class="number">0</span>, <span class="number">-101</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> s &lt; <span class="number">0</span>: s = <span class="number">0</span></span><br><span class="line">            s += i</span><br><span class="line">            ret = max(ret, s)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Best-Answer-【动态规划】"><a href="#Best-Answer-【动态规划】" class="headerlink" title="Best Answer 【动态规划】"></a>Best Answer 【动态规划】</h3><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200710162955.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</span></span><br></pre></td></tr></table></figure>

<p>上面 jyd 在处理的时候，直接在 nums 基础上进行了运算，可以说节约了 $O(N)$ 的空间使用，非常精妙</p>
<h3 id="Other-Answer-【分治法】"><a href="#Other-Answer-【分治法】" class="headerlink" title="Other Answer 【分治法】"></a>Other Answer 【分治法】</h3><blockquote>
<p>参考资料：</p>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/bao-li-qiu-jie-by-pandawakaka/" target="_blank" rel="noopener">最大子序和（暴力法 + 分治法 + DP）- Python3</a></p>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/chao-quan-4zhong-jie-fa-dong-tai-gui-hua-ji-you-hu/" target="_blank" rel="noopener">【超全·4种解法】动态规划及优化、贪心法、分治法（JavaScript实现）</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>将数组分为 2 部分。例如 [1, 2, 3, 4] 被分为 [1, 2] 和 [3, 4]</li>
<li>通过递归计算，得到左右两部分的最大子序列和是 lsum，rsum</li>
<li>从数组中间开始向两边计算最大子序列和 cross</li>
<li>返回 max(lsum, cross, rsum)</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200710162955.png" style="zoom:50%;" />

<p><strong>Tips:</strong></p>
<ul>
<li>由于 <code>len(nums)==1</code> 保证了 <code>mid=len(nums)//2 - 1</code> 和 <code>mid - 1</code> 是存在的</li>
<li>中间值计算一定是从 mid 开始的连续值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 544 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">crossSum</span><span class="params">(nums)</span>:</span></span><br><span class="line">            mid = len(nums) // <span class="number">2</span> - <span class="number">1</span> </span><br><span class="line">            left_max_sum, left_sum = nums[mid], <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[mid: : <span class="number">-1</span>]:</span><br><span class="line">                left_sum += i</span><br><span class="line">                left_max_sum = max(left_max_sum, left_sum)</span><br><span class="line">            </span><br><span class="line">            right_max_sum, right_sum = nums[mid + <span class="number">1</span>], <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[mid + <span class="number">1</span>: : <span class="number">1</span>]:</span><br><span class="line">                right_sum += i</span><br><span class="line">                right_max_sum = max(right_max_sum, right_sum)</span><br><span class="line">            <span class="keyword">return</span> left_max_sum + right_max_sum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        mid = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">        left_max = self.maxSubArray(nums[:mid])</span><br><span class="line">        right_max = self.maxSubArray(nums[mid:])</span><br><span class="line">        mid_max = crossSum(nums)</span><br><span class="line">        <span class="keyword">return</span> max(left_max, right_max, mid_max)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指-Offer-43-1～n整数中1出现的次数"><a href="#剑指-Offer-43-1～n整数中1出现的次数" class="headerlink" title="剑指 Offer 43. 1～n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 43. 1～n整数中1出现的次数</a></h2><p>待整理</p>
<h2 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 44. 数字序列中某一位的数字</a></h2><p>待整理</p>

      
    </div>
    <footer class="article-footer">
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>PPsteven</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2020/05/14/jz-offer-solution/" target="_blank" title="算法笔记:《剑指 Offer》">http://ppsteven.github.io/2020/05/14/jz-offer-solution/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
      
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer%EF%BC%8C%E5%88%B7%E9%A2%98/" rel="tag">剑指Offer，刷题</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/19/vmware-centos-environment-network/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          mac + VMware + Centos7 下的网络配置
        
      </div>
    </a>
  
  
    <a href="/2020/05/03/several-tips-git-speed-up/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">提升 git 速度的几个加速方法</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题03-数据中的重复数字"><span class="nav-number">1.</span> <span class="nav-text">面试题03. 数据中的重复数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【利用下表法】"><span class="nav-number">1.1.</span> <span class="nav-text">Best Answer【利用下表法】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer【哈希表法】"><span class="nav-number">1.2.</span> <span class="nav-text">Other Answer【哈希表法】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题04-二维数组中的查找"><span class="nav-number">2.</span> <span class="nav-text">面试题04. 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【左下-右上元素移动法】"><span class="nav-number">2.1.</span> <span class="nav-text">Best Answer【左下/右上元素移动法】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer-【双折半查找】"><span class="nav-number">2.2.</span> <span class="nav-text">Other Answer 【双折半查找】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题05-替换空格"><span class="nav-number">3.</span> <span class="nav-text">面试题05. 替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题06-从尾到头打印链表"><span class="nav-number">4.</span> <span class="nav-text">面试题06. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题07-重建二叉树"><span class="nav-number">5.</span> <span class="nav-text">面试题07. 重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer"><span class="nav-number">5.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题09-用两个栈实现一个队列"><span class="nav-number">6.</span> <span class="nav-text">面试题09. 用两个栈实现一个队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-1"><span class="nav-number">6.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试10-I-斐波那契数列【动态规划经典】"><span class="nav-number">7.</span> <span class="nav-text">面试10- I. 斐波那契数列【动态规划经典】</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试10-II-青蛙跳台阶问题【动态规划经典】"><span class="nav-number">8.</span> <span class="nav-text">面试10- II. 青蛙跳台阶问题【动态规划经典】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【动态规划】"><span class="nav-number">8.1.</span> <span class="nav-text">Best Answer【动态规划】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer-【循环求余法】"><span class="nav-number">8.2.</span> <span class="nav-text">Other Answer 【循环求余法】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer【分治法-记忆化搜索】"><span class="nav-number">8.3.</span> <span class="nav-text">Other Answer【分治法+记忆化搜索】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题11-旋转数组的最小数字【中高难】"><span class="nav-number">9.</span> <span class="nav-text">面试题11. 旋转数组的最小数字【中高难】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【变形二分查找】"><span class="nav-number">9.1.</span> <span class="nav-text">Best Answer【变形二分查找】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer-【直接搜索】"><span class="nav-number">9.2.</span> <span class="nav-text">Other Answer 【直接搜索】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题12-矩阵中的路径"><span class="nav-number">10.</span> <span class="nav-text">面试题12. 矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-2"><span class="nav-number">10.1.</span> <span class="nav-text">Best Answer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graceful-Answer-【精妙写法】"><span class="nav-number">10.2.</span> <span class="nav-text">Graceful Answer 【精妙写法】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题13-机器人的运动范围"><span class="nav-number">11.</span> <span class="nav-text">面试题13. 机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer【DFS-深度搜索改进】"><span class="nav-number">11.1.</span> <span class="nav-text">My Answer【DFS 深度搜索改进】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【DFS-深度搜索】"><span class="nav-number">11.2.</span> <span class="nav-text">Best Answer【DFS 深度搜索】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【BFS-广度搜索】"><span class="nav-number">11.3.</span> <span class="nav-text">Best Answer 【BFS 广度搜索】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题14-I-剪绳子【非常经典】"><span class="nav-number">12.</span> <span class="nav-text">面试题14- I. 剪绳子【非常经典】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Answer-01-【暴力法】"><span class="nav-number">12.1.</span> <span class="nav-text">Answer 01 【暴力法】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Answer-02-【记忆化搜索】【自顶向下】"><span class="nav-number">12.2.</span> <span class="nav-text">Answer 02 【记忆化搜索】【自顶向下】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【动态规划】【自底向上】"><span class="nav-number">12.3.</span> <span class="nav-text">Best Answer 【动态规划】【自底向上】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【动态规划空间优化】【自底向上】"><span class="nav-number">12.4.</span> <span class="nav-text">Best Answer 【动态规划空间优化】【自底向上】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【数学推导】"><span class="nav-number">12.5.</span> <span class="nav-text">Best Answer 【数学推导】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题15-二进制中的1"><span class="nav-number">13.</span> <span class="nav-text">面试题15-二进制中的1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer-【无符号位】【逐位判断】"><span class="nav-number">13.1.</span> <span class="nav-text">My Answer 【无符号位】【逐位判断】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graceful-Answer【无符号】【技巧法】"><span class="nav-number">13.2.</span> <span class="nav-text">Graceful Answer【无符号】【技巧法】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题16-数值的整数次方"><span class="nav-number">14.</span> <span class="nav-text">面试题16. 数值的整数次方</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【递归法】【快速幂】"><span class="nav-number">14.1.</span> <span class="nav-text">Best Answer 【递归法】【快速幂】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graceful-Answer-【数学递推法】【快速幂】"><span class="nav-number">14.2.</span> <span class="nav-text">Graceful Answer 【数学递推法】【快速幂】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题17-打印从1到最大的n位数"><span class="nav-number">15.</span> <span class="nav-text">面试题17. 打印从1到最大的n位数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Answer【简单版本】"><span class="nav-number">15.1.</span> <span class="nav-text">Simple Answer【简单版本】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hard-Answer-【大数版本】【全排列】"><span class="nav-number">15.2.</span> <span class="nav-text">Hard Answer 【大数版本】【全排列】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题18-删除链表的节点"><span class="nav-number">16.</span> <span class="nav-text">面试题18. 删除链表的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer【单指针】"><span class="nav-number">16.1.</span> <span class="nav-text">My Answer【单指针】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer【双指针】【较为清晰】"><span class="nav-number">16.2.</span> <span class="nav-text">My Answer【双指针】【较为清晰】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer-【递归】"><span class="nav-number">16.3.</span> <span class="nav-text">Other Answer 【递归】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题19-正则表达式匹配【困难】"><span class="nav-number">17.</span> <span class="nav-text">面试题19. 正则表达式匹配【困难】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer-【递归法】"><span class="nav-number">17.1.</span> <span class="nav-text">My Answer 【递归法】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graceful-Answer【递归法】【大神代码】"><span class="nav-number">17.2.</span> <span class="nav-text">Graceful Answer【递归法】【大神代码】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graceful-Answer-【倒查递归】【大神代码】"><span class="nav-number">17.3.</span> <span class="nav-text">Graceful Answer 【倒查递归】【大神代码】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graceful-Answer-【动态规划】"><span class="nav-number">17.4.</span> <span class="nav-text">Graceful Answer 【动态规划】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题21-调整数组顺序使奇数位于偶数前面"><span class="nav-number">18.</span> <span class="nav-text">面试题21. 调整数组顺序使奇数位于偶数前面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【快排思路】【首尾双指针】"><span class="nav-number">18.1.</span> <span class="nav-text">Best Answer【快排思路】【首尾双指针】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【首端快慢指针】"><span class="nav-number">18.2.</span> <span class="nav-text">Best Answer 【首端快慢指针】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Answer-【辅助数组】"><span class="nav-number">18.3.</span> <span class="nav-text">Simple Answer 【辅助数组】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题22-链表中倒数第k个节点"><span class="nav-number">19.</span> <span class="nav-text">面试题22. 链表中倒数第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-Answer【辅助数组】"><span class="nav-number">19.1.</span> <span class="nav-text">Simple Answer【辅助数组】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【双指针】"><span class="nav-number">19.2.</span> <span class="nav-text">Best Answer 【双指针】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题24-反转链表"><span class="nav-number">20.</span> <span class="nav-text">面试题24. 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer-1-【双指针头尾交换】"><span class="nav-number">20.1.</span> <span class="nav-text">My Answer 1 【双指针头尾交换】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer-2【递归】【理解有点难度】"><span class="nav-number">20.2.</span> <span class="nav-text">My Answer 2【递归】【理解有点难度】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer-3【辅助空间】"><span class="nav-number">20.3.</span> <span class="nav-text">My Answer 3【辅助空间】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题25-合并两个排序的链表【经典】"><span class="nav-number">21.</span> <span class="nav-text">面试题25. 合并两个排序的链表【经典】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-3"><span class="nav-number">21.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题26-树的子结构"><span class="nav-number">22.</span> <span class="nav-text">面试题26. 树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【递归】"><span class="nav-number">22.1.</span> <span class="nav-text">Best Answer 【递归】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题27-二叉树的镜像"><span class="nav-number">23.</span> <span class="nav-text">面试题27. 二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【递归】"><span class="nav-number">23.1.</span> <span class="nav-text">Best  Answer【递归】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题28-对称的二叉树"><span class="nav-number">24.</span> <span class="nav-text">面试题28. 对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【递归】-1"><span class="nav-number">24.1.</span> <span class="nav-text">Best Answer 【递归】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题29-顺时针打印矩阵"><span class="nav-number">25.</span> <span class="nav-text">面试题29. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题30-包含min函数的栈【思路经典】"><span class="nav-number">26.</span> <span class="nav-text">面试题30. 包含min函数的栈【思路经典】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-4"><span class="nav-number">26.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题31-栈的压入、弹出序列"><span class="nav-number">27.</span> <span class="nav-text">面试题31. 栈的压入、弹出序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【模拟法】"><span class="nav-number">27.1.</span> <span class="nav-text">Best Answer 【模拟法】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题32-I-从上到下打印二叉树"><span class="nav-number">28.</span> <span class="nav-text">面试题32 - I. 从上到下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【经典算法】【二叉树的层次遍历】"><span class="nav-number">28.1.</span> <span class="nav-text">Best Answer【经典算法】【二叉树的层次遍历】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题32-II-从上到下打印二叉树-II"><span class="nav-number">29.</span> <span class="nav-text">面试题32 - II. 从上到下打印二叉树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【层次遍历升级】"><span class="nav-number">29.1.</span> <span class="nav-text">Best Answer 【层次遍历升级】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题32-III-从上到下打印二叉树-III"><span class="nav-number">30.</span> <span class="nav-text">面试题32 - III. 从上到下打印二叉树 III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-5"><span class="nav-number">30.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题33-二叉搜索树的后序遍历序列"><span class="nav-number">31.</span> <span class="nav-text">面试题33. 二叉搜索树的后序遍历序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-6"><span class="nav-number">31.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指-Offer-34-二叉树中和为某一值的路径"><span class="nav-number">32.</span> <span class="nav-text">剑指 Offer 34. 二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指-Offer-35-复杂链表的复制"><span class="nav-number">33.</span> <span class="nav-text">剑指 Offer 35. 复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题36-二叉搜索树与双向链表【困难】"><span class="nav-number">34.</span> <span class="nav-text">面试题36. 二叉搜索树与双向链表【困难】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer-【中序遍历】【辅助队列】"><span class="nav-number">34.1.</span> <span class="nav-text">My Answer 【中序遍历】【辅助队列】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【中序遍历】【双指针改进】"><span class="nav-number">34.2.</span> <span class="nav-text">Best Answer 【中序遍历】【双指针改进】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题37-序列化二叉树【困难】"><span class="nav-number">35.</span> <span class="nav-text">面试题37. 序列化二叉树【困难】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-7"><span class="nav-number">35.1.</span> <span class="nav-text">Best Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题38-字符串的排列【全排列】"><span class="nav-number">36.</span> <span class="nav-text">面试题38. 字符串的排列【全排列】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-8"><span class="nav-number">36.1.</span> <span class="nav-text">Best Answer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer"><span class="nav-number">36.2.</span> <span class="nav-text">My Answer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题39-数组中出现次数超过一半的数字"><span class="nav-number">37.</span> <span class="nav-text">面试题39. 数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【摩尔投票法】"><span class="nav-number">37.1.</span> <span class="nav-text">Best Answer 【摩尔投票法】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题40-最小的k个数"><span class="nav-number">38.</span> <span class="nav-text">面试题40. 最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer1【快排】"><span class="nav-number">38.1.</span> <span class="nav-text">My Answer1【快排】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#My-Answer2-【堆排】"><span class="nav-number">38.2.</span> <span class="nav-text">My Answer2 【堆排】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题41-数据流中的中位数【困难】"><span class="nav-number">39.</span> <span class="nav-text">面试题41. 数据流中的中位数【困难】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【优先队列】"><span class="nav-number">39.1.</span> <span class="nav-text">Best Answer【优先队列】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer【折半直接插入】"><span class="nav-number">39.2.</span> <span class="nav-text">Best Answer【折半直接插入】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题42-连续子数组的最大和"><span class="nav-number">40.</span> <span class="nav-text">面试题42. 连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【暴力-剪枝】"><span class="nav-number">40.1.</span> <span class="nav-text">Best Answer 【暴力+剪枝】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Answer-【动态规划】"><span class="nav-number">40.2.</span> <span class="nav-text">Best Answer 【动态规划】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-Answer-【分治法】"><span class="nav-number">40.3.</span> <span class="nav-text">Other Answer 【分治法】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指-Offer-43-1～n整数中1出现的次数"><span class="nav-number">41.</span> <span class="nav-text">剑指 Offer 43. 1～n整数中1出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指-Offer-44-数字序列中某一位的数字"><span class="nav-number">42.</span> <span class="nav-text">剑指 Offer 44. 数字序列中某一位的数字</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2019 - 2020 软微9133 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/link" class="mobile-nav-link">Link</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            软微9133
          </div>
          <div class="panel-body">
            Copyright © 2020 PPsteven All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>