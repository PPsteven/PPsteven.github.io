<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>python并发编程——多进程编程 multiprocessing 模块 | 软微9133</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="pythonmultiprocessing" />
  
  
  
  
  <meta name="description" content="Python 并发编程可以分为三块：多进程编程，多线程编程，多协程编程。前两者是由于操作系统控制的，协程是由用户控制。所以在多进程的编程上，不同操作系统的效果不一样。如果是为了学习多进程编辑，建议在Mac Os 或者 Linux 上。 本篇介绍基于进程的并行操作，主要用到的模块是 multiprocessing">
<meta name="keywords" content="python,multiprocessing">
<meta property="og:type" content="article">
<meta property="og:title" content="Python并发编程——多进程编程 multiprocessing 模块">
<meta property="og:url" content="http:&#x2F;&#x2F;ppsteven.github.io&#x2F;2020&#x2F;04&#x2F;05&#x2F;python-multiprocessing-basic&#x2F;index.html">
<meta property="og:site_name" content="软微9133">
<meta property="og:description" content="Python 并发编程可以分为三块：多进程编程，多线程编程，多协程编程。前两者是由于操作系统控制的，协程是由用户控制。所以在多进程的编程上，不同操作系统的效果不一样。如果是为了学习多进程编辑，建议在Mac Os 或者 Linux 上。 本篇介绍基于进程的并行操作，主要用到的模块是 multiprocessing">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200406150352.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200406020450.png">
<meta property="og:updated_time" content="2020-06-06T19:12:51.853Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;PPsteven&#x2F;pictures&#x2F;img&#x2F;20200406150352.png">
  
    <link rel="alternate" href="/atom.xml" title="软微9133" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li> <a class="main-nav-link" href="/link">我的关注</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-python-multiprocessing-basic" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Python并发编程——多进程编程 multiprocessing 模块
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/04/05/python-multiprocessing-basic/" class="article-date">
	  <time datetime="2020-04-05T04:27:57.000Z" itemprop="datePublished">2020-04-05</time>
	</a>

      
    <a class="article-category-link" href="/categories/python/">python</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      
	<a class="article-edit" target="_blank" rel="noopener" href="https://github.com/ppsteven/blog/edit/master/source/_posts/python-multiprocessing-basic.md">
	<span id="edit">编辑</span>
	</span>
	</a>


    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>Python 并发编程可以分为三块：多进程编程，多线程编程，多协程编程。前两者是由于操作系统控制的，协程是由用户控制。所以在多进程的编程上，不同操作系统的效果不一样。如果是为了学习多进程编辑，建议在Mac Os 或者 Linux 上。</p>
<p>本篇介绍基于进程的并行操作，主要用到的模块是 <code>multiprocessing</code> </p>
<a id="more"></a>

<h2 id="简单多进程编程"><a href="#简单多进程编程" class="headerlink" title="简单多进程编程"></a>简单多进程编程</h2><p>简单多进程用 <code>Process</code>  和 <code>Pool</code> 两个基础类就可以实现</p>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()  <span class="comment"># 启动进程</span></span><br><span class="line">    p.join()  <span class="comment"># 阻塞进程，只有当本次进程完成后才运行下一进程。进程同步逻辑。</span></span><br></pre></td></tr></table></figure>

<p>下面我们可以详细看看 Process 类的属性，构造方法和方法</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">Process</span><span class="params">(group=None, target=None, name=None, args=<span class="params">()</span>, kwargs=&#123;&#125;, *, daemon=None)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>group</em>    兼容逻辑，始终设置为None</p>
</li>
<li><p><em>target</em>     目标函数</p>
</li>
<li><p><em>args, kwargs</em>    传入目标函数的参数，列表参数和字典参数</p>
</li>
<li><p><em>name</em>   进程名称</p>
</li>
<li><p><em>daemon</em>  后台运行，守护进程。若 daemon =True，该进程会一直存在于主进程中，伴随着父进程终止而终止。</p>
<blockquote>
<p>Tips： 守护进程</p>
<p>主进程结束后，子进程不一定会运行结束。如果我们需要让父进程终止的时候，可以设置子进程为守护进程。注意的是，守护进程不能够再创造子进程了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Process(group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>, args=(), kwargs=&#123;&#125;, *, daemon=<span class="literal">True</span>) <span class="comment"># 创建Process类时设置</span></span><br><span class="line">p.daemon = <span class="literal">True</span> <span class="comment"># 主动设置deemon 属性</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><em>pid</em>  进程ID</li>
<li><em>name</em>  进程名</li>
<li><em>deamon</em> 设置后台守护进程</li>
<li><em>exitcode</em> 子进程退出代码。如果进程尚未终止，这将是 <code>None</code> 。负值 <em>-N</em> 表示孩子被信号 <em>N</em> 终止。</li>
</ul>
<p>我们可以轻松的通过访问任一 Process 类的变量获取基本信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.current_process().pid</span><br><span class="line">multiprocessing.current_process().name</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>run()  进程活动的方法</p>
<blockquote>
<p>通过重载 run 方法实现进程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        name = multiprocessing.current_process().name</span><br><span class="line">        pid = multiprocessing.current_process().pid</span><br><span class="line">        print(<span class="string">f'name:<span class="subst">&#123;name&#125;</span>, pid:<span class="subst">&#123;pid&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     p = MyProcess()</span><br><span class="line">     p.start()</span><br><span class="line">     p.join()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，尽管我们修改的是 run 方法。我们启动进程的方法还是 p.start</p>
</blockquote>
</li>
<li><p>start()   启动进程</p>
</li>
<li><p>join([timeout]) 进程阻塞，直到进程终止。</p>
<p>timeout 是阻塞的时间，默认None，一直阻塞直到进程终止。</p>
</li>
<li><p>is_alive()  进程存在返回 True， 否则 False</p>
</li>
<li><p>terminate()/kill() 在Unix上，这是使用 <code>SIGTERM</code> 信号完成的</p>
</li>
<li><p>close() 关闭 <code>Process</code>对象，释放与之关联的所有资源</p>
</li>
</ul>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果需要运行多个子进程，采用进程池 <code>Pool</code> 的方式可以节省程序开销。进程的创建和销毁都是需要操作系统资源的。</p>
<h4 id="进程池Pool-vs-Process"><a href="#进程池Pool-vs-Process" class="headerlink" title="进程池Pool vs Process"></a>进程池Pool vs Process</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"%s is now running, process id: %s"</span> % (msg, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    po = multiprocessing.Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        po.apply_async(worker, args=(i,))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"main process starting...."</span>)</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"main process stoping...."</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">''' 输出</span></span><br><span class="line"><span class="string">main process starting....</span></span><br><span class="line"><span class="string">0 is now running, process id: 3436</span></span><br><span class="line"><span class="string">1 is now running, process id: 3437</span></span><br><span class="line"><span class="string">2 is now running, process id: 3438</span></span><br><span class="line"><span class="string">4 is now running, process id: 3436</span></span><br><span class="line"><span class="string">3 is now running, process id: 3439</span></span><br><span class="line"><span class="string">5 is now running, process id: 3437</span></span><br><span class="line"><span class="string">6 is now running, process id: 3438</span></span><br><span class="line"><span class="string">7 is now running, process id: 3436</span></span><br><span class="line"><span class="string">8 is now running, process id: 3437</span></span><br><span class="line"><span class="string">9 is now running, process id: 3439</span></span><br><span class="line"><span class="string">main process stoping....</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>使用进程池的优点提现在</p>
<ul>
<li><p>限制同一时间进程并行的数目<br>多进程可以提高程序运行的效率，但是过多的进程切换反而会降低效率。原因是a.进程会占用计算机资源，资源决定了进程不能开启过多。b.进程的切换开销比较大，占用过多CPU资源。</p>
</li>
<li><p>进程池减少不必要的创建，销毁过程。</p>
<p>程序中，Pool(4) 的进程号只有 3436，3437，3438，3439 这四个进程号。证明进程池省去了创建和销毁的过程。</p>
</li>
</ul>
<p>当进程数和计算机的内核数一致的时候，效率最高。我们可以先看看自己计算机的内核个数，使用 <code>os.cpu_count()</code> 或者 <code>multiprocess.cpu_count()</code> 来查看内核个数。<br>如果不填写内核参数，Pool 默认采取机器的内核个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line">p = Pool(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p.apply_async(f, args=(i,))  <span class="comment"># 异步调用</span></span><br><span class="line">    p.apply(f, args=(i,)) <span class="comment"># 同步调用</span></span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">pool</span>.<span class="title">Pool</span><span class="params">([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</span></span></span><br><span class="line"><span class="class"># 一个进程池对象，它控制可以提交作业的工作进程池。它支持带有超时和回调的异步结果，以及一个并行的 <span class="title">map</span> 实现。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>processes 进程数，默认采用 <code>os.cpu_count()</code></li>
<li>initializer(*initargs) 进程池调用前的初始化方法</li>
</ul>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>apply(<em>func</em>[, <em>args</em>[, <em>kwds</em>]]) </p>
<p>返回结果前阻塞。这种情况下，<a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" target="_blank" rel="noopener"><code>apply_async()</code></a> 更适合并行化工作。另外 <em>func</em> 只会在一个进程池中的一个工作进程中执行。</p>
</li>
<li><p>apply_async(<em>func</em>[, <em>args</em>[, <em>kwds</em>[, <em>callback</em>[, <em>error_callback</em>]]]])  非阻塞操作</p>
<p>callback 是一个只接受一个参数的可调用对象。成功则执行callback，失败执行 error_callback</p>
</li>
<li><p>map(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>]) </p>
<p>内置函数 <code>map</code> 的并行版本，map会 <strong>保持阻塞</strong> 直到获得结果。</p>
<p><em>iterable</em> 可以切分成多块运行，chunksize 指定块的大小。</p>
<p>当 iterable 太大的时候，为了节省内存，可以使用 imap 和 imap_unordered</p>
</li>
<li><p>map_async(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>[, <em>callback</em>[, <em>error_callback</em>]]]) </p>
<p>map 的对应的<strong>异步</strong>回调方法</p>
</li>
<li><p>imap(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>] 需要显式的设置 chunksize，可以极大的加快 map  的速度。原先map中的默认值为1。</p>
</li>
<li><p>imap_unordered    imap 的无序版本</p>
</li>
</ul>
<blockquote>
<p>apply_async 和 map_async 除了是异步执行的以外，它们还会放回一个 <strong>AsyncResult</strong> 对象，它有如下方法</p>
</blockquote>
<ul>
<li>get([<em>timeout</em>]) 获取执行的结果</li>
<li>wait([<em>timeout</em>]) 阻塞，直到返回结果</li>
<li>ready 是否已完成结果</li>
<li>successful 是否已完成且没有发生异常</li>
</ul>
<h2 id="进程间通信——数据传递"><a href="#进程间通信——数据传递" class="headerlink" title="进程间通信——数据传递"></a>进程间通信——数据传递</h2><p>multiprocessing  支持两种通信方式：Queue(队列) , Pipe(管道) </p>
<h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">q = Queue(maxsize=<span class="number">4</span>)</span><br><span class="line">q.put(obj, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>) <span class="comment"># 存入队列中</span></span><br><span class="line">q.get(obj, block=<span class="literal">False</span>) <span class="comment"># 读取队列</span></span><br><span class="line"><span class="comment"># block: 是否主动阻塞，阻塞的时间为timeout。timeout=None 代表一直阻塞。block为 False 的时候，会主动抛出 queue.Full 和 queue.Empty 的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pipe 建立的是一个双全工的连接</span></span><br><span class="line">parent_conn, child_conn = Pipe()</span><br><span class="line">parent_conn.send([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>]) <span class="comment"># 发送</span></span><br><span class="line">parent_conn.close() <span class="comment"># 关闭 一端的连接，关闭后不可以再次进行 send 和 recv 操作</span></span><br><span class="line">child_conn.recv() <span class="comment"># 接收</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，Pipe 是只能在两个进程进行通信，而 Queue 可以支持多个队列。Pipe 解决了进程之间的通信问题，Queue 还加上了一个缓冲区的作用。</p>
</blockquote>
<p>那么multiprocessing.Queue 和 标准库中的 queue 的区别是什么？</p>
<ol>
<li>需要注意的是这里是多进程编程，进程是资源分配的最小单位。不同的进程是无法获取对方堆栈的。Queue 可以解决这一个数据共享的问题。如果我们现在采用的是多线程编程，那么就可以直接采用标准库的queue 来替代。</li>
<li>multiprocessing 中的 Queue 实现了标准库中的 queue 中的所有方法，除了<code>task_done</code> 和 <code>join</code> 方法</li>
</ol>
<h3 id="Pipe-的使用"><a href="#Pipe-的使用" class="headerlink" title="Pipe 的使用"></a>Pipe 的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conn1, conn2 = multiprocessing.Pipe([duplex])</span><br><span class="line"><span class="comment"># 返回 Connection 对象 conn1,conn2 分别代表管道的两端。Connection 类型</span></span><br><span class="line"><span class="keyword">while</span> conn1.poll():</span><br><span class="line">   conn1.recv()</span><br></pre></td></tr></table></figure>

<p>duplex: True 代表双全工，即管道的两端是可以双向的通信的。False 代表单向， <code>conn1</code> 只能用于接收消息，而 <code>conn2</code> 仅能用于发送消息。</p>
<p><strong>Connect 对象的方法有</strong></p>
<ul>
<li><p>send/recv 发送的对象必须是可序列化的</p>
</li>
<li><p>send_bytes(<em>buffer</em>[, <em>offset</em>[, <em>size<em>]]) / recv_bytes([</em>maxlength<em>]) / <code>recv_bytes_into</code>(</em>buffer</em>[, <em>offset</em>]) </p>
<p>发送 和 接受 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 字节类对象</p>
</li>
<li><p>poll([<em>timeout</em>]) 返回连接对象中是否有可以读取的数据</p>
</li>
<li><p>close() 关闭</p>
</li>
</ul>
<blockquote>
<p>注意的一点是，Connect 的仅仅支持少量数据的发送，对于多大的对象（32M+），可能会引发异常</p>
</blockquote>
<h3 id="Queue-的使用"><a href="#Queue-的使用" class="headerlink" title="Queue 的使用"></a>Queue 的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">Queue</span><span class="params">([maxsize])</span></span></span><br></pre></td></tr></table></figure>

<p>主要实现了如下属性&amp;方法，基本和 queue 一样</p>
<ul>
<li><p>qsize 队列大小，由于是多进程的上下文，这个数字不是很可靠，而且在Mac OS X 上可能存在异常。</p>
</li>
<li><p>empty 是否为空</p>
</li>
<li><p>full 是否为满</p>
</li>
<li><p>put(<em>obj</em>[, <em>block</em>[, <em>timeout</em>]])  当没有可用缓冲槽的时，抛出 <a href="https://docs.python.org/zh-cn/3.7/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>queue.Empty</code></a> 异常</p>
<p>put_nowait(<em>obj</em>) 等价于 put(obj, False)</p>
</li>
<li><p>get([<em>block</em>[, <em>timeout</em>]]) 当没有可取用对象时，抛出 <a href="https://docs.python.org/zh-cn/3.7/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>queue.Empty</code></a> 异常</p>
<p>get_nowait() 等价于 get(False)</p>
</li>
<li><p>close() 指示当前进程将不会再往队列中放入对象</p>
</li>
</ul>
<h3 id="Queue的几种变形"><a href="#Queue的几种变形" class="headerlink" title="Queue的几种变形"></a>Queue的几种变形</h3><ol>
<li><p>multiprocessing.SimpleQueue() 简化的队列，其只具有empty、get、put3个方法。</p>
<p>这个队列实际上是用 Pipe 实现的</p>
</li>
<li><p>multiprocessing.JoinableQueue(maxsize=0)  建立<strong>可阻塞的队列实例</strong>，采用一般队列的方式访问。加上了 <code>join</code>  和 <code>task_done</code> 两个方法。</p>
</li>
</ol>
<h2 id="进程间通信——数据共享"><a href="#进程间通信——数据共享" class="headerlink" title="进程间通信——数据共享"></a>进程间通信——数据共享</h2><p>进程间的通信 Pipe 和 Queue 能解决小批量数据的传输，如 <strong>Pipe.send() 方法发送的数据一般不超过 32M</strong>。对于大量的数据，可以借助 <code>共享内存</code> 和 <code>Manager 类</code>实现。<code>Manager</code>实现了两个重要的类型 <code>list</code> 和 <code>dict</code>。</p>
<h3 id="Manager-类（共享进程）"><a href="#Manager-类（共享进程）" class="headerlink" title="Manager 类（共享进程）"></a>Manager 类（共享进程）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(list, x)</span>:</span></span><br><span class="line">    print(list, x)</span><br><span class="line">    list.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     manager = multiprocessing.Manager()</span><br><span class="line">     mag_list = manager.list([]) </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">     <span class="keyword">with</span> multiprocessing.Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">         <span class="keyword">for</span> item <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">            p.apply(f, args=(mag_list, item))</span><br><span class="line">         p.close()</span><br><span class="line">     print(mag_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># [] 1</span></span><br><span class="line"><span class="comment"># [1] 2</span></span><br><span class="line"><span class="comment"># [1, 2] 3</span></span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以尝试 mag_list=[] ,最后的结果是不会发生任何变化</span></span><br><span class="line"><span class="comment"># [] 1</span></span><br><span class="line"><span class="comment"># [] 2</span></span><br><span class="line"><span class="comment"># [] 3</span></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<h3 id="Value-Array（共享内存）"><a href="#Value-Array（共享内存）" class="headerlink" title="Value, Array（共享内存）"></a>Value, Array（共享内存）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Value(typecode_or_type, *args, lock=<span class="literal">True</span>)</span><br><span class="line">multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>typecode_or_type  类型码</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200406150352.png" alt=""></p>
</li>
<li><p>size_or_initializer 大小，或者初始化操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Array(<span class="string">'i'</span>, <span class="number">3</span>) <span class="comment"># 结果 [0,0,0]</span></span><br><span class="line">multiprocessing.Array(<span class="string">'i'</span>, range(<span class="number">3</span>)) <span class="comment"># 结果 [0,1,2]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Lock 锁操作，在修改访问数据的时候，通过设置为 True 能锁定资源，阻塞其他进程的访问。</p>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = multiprocessing.Value(<span class="string">'d'</span>, <span class="number">10</span>, lock=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> v.get_lock(): <span class="comment"># 修改值前，加锁</span></span><br><span class="line">    v.value += <span class="number">1</span>  <span class="comment"># 属性 value 取值</span></span><br></pre></td></tr></table></figure>



<h2 id="数据进程锁"><a href="#数据进程锁" class="headerlink" title="数据进程锁"></a>数据进程锁</h2><p>上一部分解决了进程间共享数据的操作。但是不同进程若是需要对于共享数据进行修改，可能会发生冲突。解决这一类问题的方式就是在 重要数据修改的时候加上锁，修改完毕再释放。</p>
<p>multiprocessing 的 互斥&amp;同步操作有： <code>Lock</code>,  <code>Semaphore</code> , <code>Event</code> 和 <code>Barrier</code></p>
<h3 id="Lock-原始锁"><a href="#Lock-原始锁" class="headerlink" title="Lock 原始锁"></a>Lock 原始锁</h3><p>原始锁（非递归锁）对象，一旦一个进程或者线程拿到了锁，后续的任何其他进程或线程的其他请求都会被阻塞直到锁被释放。<strong>任何进程或线程都可以释放锁。</strong></p>
<blockquote>
<p>Lock 一般只针对一个资源同步访问</p>
</blockquote>
<h3 id="RLock-递归锁"><a href="#RLock-递归锁" class="headerlink" title="RLock 递归锁"></a>RLock 递归锁</h3><p><strong>递归锁必须由持有线程、进程亲自释放。</strong>递归锁和原始锁的区别是，一个进程可以多次加锁，每次加锁，锁加一。每次释放，锁减一。所以当获得锁和释放锁的数量相等的时候，才能释放锁住的资源。使用方法和Lock 一样。</p>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><p>Semaphore 一般是针对多个(有限)资源的访问的，它的操作和Lock一样。只是初始化的时候，需要给出型号量的初始值。可以认为Semaphore(1) 和 RLock是相同的。</p>
<blockquote>
<p>上面三个锁的使用方法都可以使用 acquire/release 操作</p>
</blockquote>
<h3 id="Barrier-屏障"><a href="#Barrier-屏障" class="headerlink" title="Barrier 屏障"></a>Barrier 屏障</h3><p>当若干个进程没有到达屏障点的时候，会自动阻塞，一旦到达屏障点，将会自动解除阻塞并启动运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200406020450.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threading</span>.<span class="title">Barrier</span><span class="params">(parties, action=None, timeout=None)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>parties  栅栏的个数</li>
<li>action  当突破栅栏后，会在被释放的其中一个进程中运行</li>
</ul>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li>n_waiting  当前时刻正在栅栏中阻塞的线程数量。</li>
<li>broken  值为 <code>True</code> 表明栅栏为破损态。</li>
</ul>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li>wait(<em>timeout=None</em>) 阻塞操作，函数会返回一个范围在 0~parties-1 内的整数。当为0 的时候，代表栅栏破裂</li>
<li>reset() 重置为初始状态</li>
<li>abort() 与reset() 相反，设置为破损状态</li>
</ul>
<h3 id="Event-事件锁"><a href="#Event-事件锁" class="headerlink" title="Event 事件锁"></a>Event 事件锁</h3><p>这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li>is_set()   判断内部标识位是否为True</li>
<li>set()  设置内部标识位为True</li>
<li>clear()  设置内部标识位为False</li>
<li>wait()  阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>由于之前没有接触过Event，这里自己练手写了一个Event 的小例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(e, car_id)</span>:</span></span><br><span class="line">    print(<span class="string">f'car <span class="subst">&#123;car_id&#125;</span> is coming '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> e.is_set():</span><br><span class="line">        print(<span class="string">f'car <span class="subst">&#123;car_id&#125;</span> is waiting'</span>)</span><br><span class="line">        e.wait()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> e.is_set():</span><br><span class="line">        print(<span class="string">f'car <span class="subst">&#123;car_id&#125;</span> pass the cross road'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traffic_light</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    红绿灯切换的时候，e.clear 和 e.set 是成队出现的。</span></span><br><span class="line"><span class="string">    因为红绿本省就是相互同步的一个操作</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 每5秒切换一次红绿灯</span></span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">'&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>)</span><br><span class="line">            e.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> e.is_set():</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">'&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>)</span><br><span class="line">            e.set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = multiprocessing.Event()</span><br><span class="line">    event.clear()  <span class="comment"># 默认设置红灯</span></span><br><span class="line">    cars = [multiprocessing.Process(target=car, args=(event,car_id)) <span class="keyword">for</span> car_id <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    lights = multiprocessing.Process(target=traffic_light, args=(event,))</span><br><span class="line">    lights.daemon = <span class="literal">True</span>  <span class="comment"># 设置完这一步，可以在小汽车都开走后，结束整个程序。</span></span><br><span class="line">    lights.start()</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> cars:</span><br><span class="line">        each.start()</span><br><span class="line">        time.sleep(<span class="number">1</span>) <span class="comment"># 间隔一秒钟发车</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> cars:</span><br><span class="line">        each.join()</span><br><span class="line">    <span class="comment"># 当 each.join 执行完毕，此时 traffic_light 还在后台运行</span></span><br><span class="line">    <span class="comment"># 但是由于没有添加 traffic_light.join() 所以此时 mian 结束，带着守护进程 traffic_light一起结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">car <span class="number">0</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">0</span> <span class="keyword">is</span> waiting</span><br><span class="line">car <span class="number">1</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">1</span> <span class="keyword">is</span> waiting</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">....</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">car <span class="number">8</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">8</span> <span class="keyword">is</span> waiting</span><br><span class="line">car <span class="number">9</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">9</span> <span class="keyword">is</span> waiting</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">car <span class="number">8</span> <span class="keyword">pass</span> the cross road</span><br><span class="line">car <span class="number">9</span> <span class="keyword">pass</span> the cross road</span><br></pre></td></tr></table></figure>

<p>如果我们不启动守护进程，而是一直让程序在后台运行。这样我们可以感受到  <strong>守护进程</strong>  的作用</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> cars = [multiprocessing.Process(target=car, args=(event,car_id)) for car_id in range(10)]</span><br><span class="line"> lights = multiprocessing.Process(target=traffic_light, args=(event,))</span><br><span class="line"><span class="deletion">-   lights.daemon = True  # 设置完这一步，可以在小汽车都开走后，结束整个程序。</span></span><br><span class="line">    lights.start()</span><br><span class="line">    for each in cars:</span><br><span class="line">        each.start()</span><br><span class="line">        time.sleep(1) # 间隔一秒钟发车</span><br><span class="line"></span><br><span class="line">    for each in cars:</span><br><span class="line">        each.join()</span><br><span class="line"><span class="addition">+   lights.join() # </span></span><br><span class="line"># 输出结果如下</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">car 9 pass the cross road</span><br><span class="line">car 8 pass the cross road</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Condition-条件锁"><a href="#Condition-条件锁" class="headerlink" title="Condition 条件锁"></a>Condition 条件锁</h3><h3 id="几种方法的比较"><a href="#几种方法的比较" class="headerlink" title="几种方法的比较"></a>几种方法的比较</h3><table>
<thead>
<tr>
<th>方法</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Lock</td>
<td>原始锁</td>
<td>当多个进程需要访问共享资源的时候，、</td>
</tr>
<tr>
<td>RLock</td>
<td>递归锁</td>
<td>Lock 的升级</td>
</tr>
<tr>
<td>Semaphore</td>
<td>信号量（计数器锁）</td>
<td>Semaphore用来控制对共享资源的访问数量，例如池的最大连接数。</td>
</tr>
<tr>
<td>Barrier</td>
<td>时间锁</td>
<td>进程间同步通信</td>
</tr>
<tr>
<td>Barrier</td>
<td>障碍锁</td>
<td>等待足够资源启动</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#cleanup" target="_blank" rel="noopener">python官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1pJ411h7YS?p=17" target="_blank" rel="noopener">B站【李兴华编程训练营】Python并发编程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/46798399" target="_blank" rel="noopener">知乎python并行计算（上）：multiprocessing、multiprocess模块</a></p>

      
    </div>
    <footer class="article-footer">
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>PPsteven</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2020/04/05/python-multiprocessing-basic/" target="_blank" title="Python并发编程——多进程编程 multiprocessing 模块">http://ppsteven.github.io/2020/04/05/python-multiprocessing-basic/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
      
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/multiprocessing/" rel="tag">multiprocessing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/03/several-tips-git-speed-up/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          提升 git 速度的几个加速方法
        
      </div>
    </a>
  
  
    <a href="/2020/03/01/mysql-freq-command/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">mysql 常用命令</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单多进程编程"><span class="nav-number">1.</span> <span class="nav-text">简单多进程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Process"><span class="nav-number">1.1.</span> <span class="nav-text">Process</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">1.1.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">1.1.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">1.1.3.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pool"><span class="nav-number">1.2.</span> <span class="nav-text">Pool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程池Pool-vs-Process"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程池Pool vs Process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信——数据传递"><span class="nav-number">2.</span> <span class="nav-text">进程间通信——数据传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础用法"><span class="nav-number">2.1.</span> <span class="nav-text">基础用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipe-的使用"><span class="nav-number">2.2.</span> <span class="nav-text">Pipe 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-的使用"><span class="nav-number">2.3.</span> <span class="nav-text">Queue 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue的几种变形"><span class="nav-number">2.4.</span> <span class="nav-text">Queue的几种变形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信——数据共享"><span class="nav-number">3.</span> <span class="nav-text">进程间通信——数据共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Manager-类（共享进程）"><span class="nav-number">3.1.</span> <span class="nav-text">Manager 类（共享进程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value-Array（共享内存）"><span class="nav-number">3.2.</span> <span class="nav-text">Value, Array（共享内存）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-number">3.2.1.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据进程锁"><span class="nav-number">4.</span> <span class="nav-text">数据进程锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock-原始锁"><span class="nav-number">4.1.</span> <span class="nav-text">Lock 原始锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RLock-递归锁"><span class="nav-number">4.2.</span> <span class="nav-text">RLock 递归锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-信号量"><span class="nav-number">4.3.</span> <span class="nav-text">Semaphore 信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Barrier-屏障"><span class="nav-number">4.4.</span> <span class="nav-text">Barrier 屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性-1"><span class="nav-number">4.4.1.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-2"><span class="nav-number">4.4.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-事件锁"><span class="nav-number">4.5.</span> <span class="nav-text">Event 事件锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-3"><span class="nav-number">4.5.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子-1"><span class="nav-number">4.5.2.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-条件锁"><span class="nav-number">4.6.</span> <span class="nav-text">Condition 条件锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几种方法的比较"><span class="nav-number">4.7.</span> <span class="nav-text">几种方法的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2019 - 2020 软微9133 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/link" class="mobile-nav-link">Link</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            软微9133
          </div>
          <div class="panel-body">
            Copyright © 2020 PPsteven All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>