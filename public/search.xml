<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PHP+phpstorm+xdebug 环境配置</title>
    <url>/2019/12/14/PHP+phpstorm+xdebug%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>php 环境搭建是一件相当麻烦的事情，本篇博客记录了在Mac 系统下的环境配置。</p>
<p>Win上的php 环境搭建，建议使用XAMPP，一键搭建，而且自带xdebug.dll，用过就知道。Mac 上的php 环境，我一开始也使用了 XAMPP 作为环境，但是发现Mac 上的是阉割版的，也没有xdebug。</p>
<p>目前介绍的环境搭建方法是: <strong>brew</strong> 和 <strong>pecl</strong> </p>
<a id="more"></a>

<h2 id="PHP-安装"><a href="#PHP-安装" class="headerlink" title="PHP 安装"></a>PHP 安装</h2><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>Mac 上是自带php和Apache的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whereis php</span><br><span class="line">/usr/bin/php</span><br></pre></td></tr></table></figure>

<p>我这里准备用brew 装一个最新的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew search php</span><br><span class="line">==&gt; Formulae</span><br><span class="line">brew-php-switcher      php@7.2                phpmyadmin</span><br><span class="line">php                    php@7.3 ✔              phpstan</span><br><span class="line">php-code-sniffer       phplint                phpunit</span><br><span class="line">php-cs-fixer           phpmd</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">eclipse-php            netbeans-php           phpstorm</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<p>安装最新的 php 7.3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install php@7.3</span><br><span class="line"><span class="comment"># 安装后，我们需要添加环境变量</span></span><br><span class="line">php@7.3 is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have php@7.3 first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/php@7.3/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/php@7.3/sbin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find php@7.3 you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/php@7.3/lib"</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/php@7.3/include"</span></span><br><span class="line"></span><br><span class="line">To have launchd start php@7.3 now and restart at login:</span><br><span class="line">  brew services start php@7.3</span><br><span class="line">Or, <span class="keyword">if</span> you don<span class="string">'t want/need a background service you can just run:</span></span><br><span class="line"><span class="string">  php-fpm</span></span><br></pre></td></tr></table></figure>

<h3 id="brew-安装遇到的问题"><a href="#brew-安装遇到的问题" class="headerlink" title="brew 安装遇到的问题"></a>brew 安装遇到的问题</h3><p>brew 安装<a href="mailto:php@7.3" target="_blank" rel="noopener">php@7.3</a> 的过程中，中间一条命令是 brew clean 产生了问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cleanup</span><br><span class="line">Warning: Skipping opam: most recent version 2.0.3 not installed</span><br><span class="line">Warning: Skipping python: most recent version 3.7.2_2 not installed</span><br><span class="line">Warning: Skipping sqlite: most recent version 3.27.1 not installed</span><br><span class="line">Error: Permission denied @ unlink_internal - /usr/<span class="built_in">local</span>/lib/node_modules/@angular/cli/node_modules/.bin/<span class="keyword">in</span>-install</span><br></pre></td></tr></table></figure>

<p>既然说我们权限不够，第一反应是使用 <code>sudo</code> 命令，但是brew 不允许用户这么做。</p>
<p>经过查询后，可以使用如下命令，可以给没有权限的文件夹，更改权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R <span class="string">"<span class="variable">$(whoami)</span>"</span>:admin /usr/<span class="built_in">local</span> <span class="comment"># 这里文件夹填写需要的</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-xdebug"><a href="#安装-xdebug" class="headerlink" title="安装 xdebug"></a>安装 xdebug</h2><p>xdebug 的安装是比较麻烦的，若是没有xdebug 需要的步骤复制很多。涉及到自己编译（自己编译的话，由于计算机环境不同又会产生很多问题）</p>
<h3 id="XAMPP-环境的安装"><a href="#XAMPP-环境的安装" class="headerlink" title="XAMPP 环境的安装"></a>XAMPP 环境的安装</h3><p>这里XAMPP环境的话我建议参考下面的教程</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/d60ad942aa88" target="_blank" rel="noopener">Mac下XAMPP+PhpStorm中集成xdebug</a></p>
</blockquote>
<p>简单的描述一下过程就是：</p>
<ol>
<li>生成 phpinfo ，复制到 xdebug 官网<a href="https://link.jianshu.com/?t=https://xdebug.org/wizard.php" target="_blank" rel="noopener">官网下载xdebug.so</a> 下载xdebug.tgz</li>
<li>解压文件: <code>tar -xvzf xdebug.tgz</code></li>
<li>编译过程官方教程(有坑)</li>
</ol>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215000634.png" class="lozad"></p>
<ol start="4">
<li><blockquote>
<p>坑一：使用对phpize 命令。如果你电脑中安装的是XAMPP环境，你需要使用XAMPP环境的phpize</p>
</blockquote>
<p><code>/Applications/XAMPP/xamppfiles/bin/phpize</code></p>
<blockquote>
<p>坑二：出现<code>Cannot find autoconf</code> 错误 </p>
</blockquote>
<p><code>brew install autoconf</code></p>
<blockquote>
<p>坑三：./configure 编译问题</p>
</blockquote>
<p><code>./configure --with-php-config=/Applications/XAMPP/xamppfiles/bin/php-config</code></p>
</li>
<li><p>make 获得 xdebug.so 文件</p>
</li>
</ol>
<h3 id="Pecl-方法安装（采用的方法）"><a href="#Pecl-方法安装（采用的方法）" class="headerlink" title="Pecl 方法安装（采用的方法）"></a>Pecl 方法安装（采用的方法）</h3><p>我们使用的较为简单的方法，就是使用pecl命令，如果我们成功的安装了 php 的话，pecl 是自带的。pecl 相当于为我们省去了编译的过程，也帮我们避免了很多的坑</p>
<p>pecl 之于 php 相当于 pip 之于 python 和 npm 之于 node.js，管理的是 php 的扩展(或者叫插件？)</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215001759.png" class="lozad"></p>
<h3 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h3><p>找到php.ini 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php --ini</span><br><span class="line">Configuration File (php.ini) Path: /usr/<span class="built_in">local</span>/etc/php/7.3</span><br><span class="line">Loaded Configuration File:         /usr/<span class="built_in">local</span>/etc/php/7.3/php.ini</span><br><span class="line">Scan <span class="keyword">for</span> additional .ini files <span class="keyword">in</span>: /usr/<span class="built_in">local</span>/etc/php/7.3/conf.d</span><br><span class="line">Additional .ini files parsed:      /usr/<span class="built_in">local</span>/etc/php/7.3/conf.d/ext-opcache.ini</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">zend_extension</span>=/Applications/XAMPP/xamppfiles/lib/php/extensions/<span class="literal">no</span>-debug-non-zts-<span class="number">20160303</span>/xdebug.so <span class="comment"># xdebug 存放路径</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span>=<span class="literal">on</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span>=<span class="literal">on</span></span><br><span class="line"><span class="attr">xdebug.remote_mode</span>=<span class="string">"req"</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=localhost</span><br><span class="line"><span class="attr">xdebug.remote_port</span>=<span class="number">9000</span> <span class="comment"># 端口号，记住</span></span><br><span class="line"><span class="attr">xdebug.remote_handler</span>=<span class="string">"dbgp"</span></span><br><span class="line"><span class="attr">xdebug.idekey</span>=<span class="string">"PhpStorm"</span></span><br><span class="line"><span class="attr">xdebug.profiler_enable</span> = <span class="literal">Off</span></span><br></pre></td></tr></table></figure>

<p>查看xdebug 是否成功安装，使用 <code>php -m</code>  查看所有已安装的扩展，存在xdebug 则表明安装成功。当然也可以使用 <code>phpinfo()</code> 查看xdebug。</p>
<blockquote>
<p>注意: 重启Apache 服务才能看到 phpinfo 输出的情况</p>
</blockquote>
<h2 id="配置phpstorm-环境"><a href="#配置phpstorm-环境" class="headerlink" title="配置phpstorm 环境"></a>配置phpstorm 环境</h2><p>xdebug 在phpstorm 中的设置，有大量图，不想重复造轮子。看下面两个教程足够了。</p>
<p><a href="https://blog.csdn.net/u012338816/article/details/52243785" target="_blank" rel="noopener">史上最佳 Mac+PhpStorm+XAMPP+Xdebug 集成开发和断点调试环境的配置</a></p>
<p><a href="https://www.jianshu.com/p/d60ad942aa88" target="_blank" rel="noopener">Mac下XAMPP+PhpStorm中集成xdebug</a></p>
<p>实践下来，由于我只是作为php 后端开发，不需要与前端交互的话，我这里只需要保证下面的端口设置正确即可。</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215013247.png" class="lozad"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>真实工作环境中，其实由于项目是很大的，实际上没有用到xdebug的机会（主要通过日志排查问题）。我这里安装xdebug 主要是想要通过逐步调试的过程，更好的理解php 语言，协程的使用方法等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xdebug.org/docs/install#1" target="_blank" rel="noopener">xdebug 官方安装教程</a></p>
<p><a href="https://stackoverflow.com/questions/54682876/brew-cleanup-error-permission-denied-unlink-internal" target="_blank" rel="noopener">brew cleanup 问题解决方法–stackoverflow</a> </p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php环境配置</tag>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>php协程笔记</title>
    <url>/2019/12/07/php%E5%8D%8F%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实习的过程中使用到了腾讯微服务平台（Tencent Service Framework，TSF）框架，tsf中经常看到 </p>
<p><code>$ret = (yield func(a,b));</code></p>
<p>这样的用法。<br>yield 外面包括号的用法并不常见，实际上这是yield的一种特殊的用法——<strong><em>协程</em></strong>。<br>这里我准备通读一下这一领域的经典教程，好好理解yield 和 协程 是如何在PHP 项目开发中起到作用的。</p>
<blockquote>
<p><a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="noopener">在PHP中使用协程实现多任务调度| 风雪之隅</a></p>
<p>作者背景：风雪之隅，PHP开发组核心成员，鸟叔，PHP7的主要开发者。本篇文章其实他对一篇英文教程的翻译之作。</p>
</blockquote>
<p>之所以标题起笔记，原因是原文理解起来稍有难度，所以我这里加上自己的理解。本篇可以在大家读原文的过程中做一个参考。</p>
<p>yield 的作用</p>
<ul>
<li>迭代生成器</li>
</ul>
<h2 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进程是程序执行的一个实例</p>
</li>
<li><p>进程是资源分配的最小单位，资源包括：CPU，内存，I/O等</p>
</li>
<li><p>进程间的通讯方式（IPC） &lt;—- 抄，参考<a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/82951084</a></p>
<ul>
<li>管道 Pipe</li>
<li>命名管道 FIFO</li>
<li>* 消息队列（Message Queue)<ul>
<li>腾讯的hippo</li>
<li>Kafka</li>
</ul>
</li>
<li>信号量（Semaphore）</li>
<li>共享内存（Shared Memory）</li>
<li>* 套接字（Socket）</li>
</ul>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><strong>轻量级进程(Lightweight Process，LWP）</strong></li>
<li>CPU调度的最小单位</li>
<li>进程由于是拥有系统资源，所以切换时需要保存上下文环境，开销大。线程开销小</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>协程是一种比线程更加轻量级的存在</li>
<li>与进程线程不同的是，协程是完全由程序控制在（用户态执行）</li>
<li>举例： 当我们读文件的时候，我们可以主动让出控制权，而不是等待I/O操作完成。</li>
<li>特点<ul>
<li>极高的执行效率，没有线程那么大的切换开销。<br>我们知道涉及到内核参与管理的程序，需要从用户态通过中断的方式切换到内核态。这样的开销是极大的。</li>
<li>不需要多线程的锁机制，<strong>在协程中控制共享资源不加锁</strong></li>
<li>对用户可见</li>
<li>协同，因为是由程序员自己写的调度策略，其通过协作而不是抢占来进行切换</li>
<li><strong>协程的思想本质上就是控制流的主动让出（yield）和恢复（resume）机制</strong>（来源：<a href="https://segmentfault.com/a/1190000012457145" target="_blank" rel="noopener">PHP7下的协程实现</a>）</li>
</ul>
</li>
</ul>
<h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><p>迭代生成器是我们对于 yield 最常用的一个功能。<br>用 yield 替代 return 作为函数的返回最大的作用是，它返回的不仅是一个值，而是一个迭代器。这一优点在面对无法载入到内存的大型数据集有很大的作用。</p>
<p>如以下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start,$end,$step = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ($i = $start ; $i &lt;= $end ; $i += $step)&#123;</span><br><span class="line">		<span class="keyword">yield</span> $i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (xrange(<span class="number">1</span>,<span class="number">10000000000</span>) <span class="keyword">as</span> $num) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $num .<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这里使用return的话，返回的是一个非常大的数组，当你数据量特别大的时候会造成数据溢出的问题。<br>yield 的神奇之处在于，它会保持生成器的状态。函数会一直运行，直到下一个yield。程序执行的控制流可以在主代码和生成器函数之间切换，也不用用户担心上下文环境的问题。<br>优点</p>
<ul>
<li>运行大型数据集</li>
<li>不用编写就能生成复杂的生成器</li>
</ul>
<p>写一个生成器的流程，需要</p>
<ul>
<li>被迭代的类实现 IteratorAggregate <strong>接口</strong></li>
<li>定义一个返回迭代类的方法，这个类必须实现Iterator <strong>接口</strong></li>
<li>提供一系列必须实现的方法<ul>
<li>rewind : 函数内部指针设置回到数据开始处</li>
<li>valid : 判读是否还有数据</li>
<li>key : 返回数据指针值</li>
<li>current : 返回当前指针指向的值</li>
<li>next : 移动到下一位<br>yield 关键字简化了实现迭代器的过程。</li>
</ul>
</li>
<li><input disabled type="checkbox"> TODO 实现一个PHP Iterator 对象</li>
</ul>
<h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><p>yield 的一个特性是函数每次执行到yield 的时候，就会主动让出控制权。这一点可以很好的帮助我们控制程序的执行顺序。</p>
<h3 id="send-函数"><a href="#send-函数" class="headerlink" title="send 函数"></a>send 函数</h3><p>public Generator::send ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$value</code> ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a></p>
<p>向生成器中传入一个值，并且当做 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 表达式的结果。</p>
<p><strong><em>然后继续执行生成器</em></strong>。</p>
<p>如果当这个方法被调用时，生成器不在 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 表达式，那么在传入值之前，它会先运行到第一个 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 表达式。传入生成器的值。这个值将会被作为生成器当前所在的 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 的返回值。</p>
<blockquote>
<p>利用send 函数，我们可以很方便的与协程进行交互，具体如下。</p>
</blockquote>
<h3 id="yield-作为参数接受者"><a href="#yield-作为参数接受者" class="headerlink" title="yield 作为参数接受者"></a>yield 作为参数接受者</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">($fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"这个语句只会执行一次"</span>,<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">yield</span> . <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">//函数每次都会执行要yield 暂停，然后让出控制权。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$logger = logger(<span class="keyword">__DIR__</span> . <span class="string">'/log'</span>);</span><br><span class="line">$logger-&gt;send(<span class="string">'Foo'</span>);  <span class="comment">// 输出 "这个语句只会执行一次", 输出 Foo \n;</span></span><br><span class="line">$logger-&gt;send(<span class="string">'Bar'</span>);  <span class="comment">// 输出 Bar \n;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>yield 作用：</p>
<ul>
<li><ol>
<li>类似于debug 时候的断点，每一次都是运行到 yield 停止</li>
</ol>
</li>
<li><ol start="2">
<li>可以利用send方法给 yield 传递数据</li>
</ol>
</li>
</ul>
<blockquote>
<p>那自然会有一个疑问，此处的 yield 有没有接受数据回来？<br>经过试验，发现此处的yield 是没有返回数据的。</p>
</blockquote>
<p>这个例子可以看到yield 并没有返回数据，是NULL</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">($fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"这个语句只会执行一次"</span>,<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">yield</span> . <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">//函数每次都会执行要yield 暂停，然后让出控制权。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$logger = logger(<span class="keyword">__DIR__</span> . <span class="string">'/log'</span>);</span><br><span class="line">$a = $logger-&gt;send(<span class="string">'Foo'</span>);  <span class="comment">// 输出 "这个语句只会执行一次", 输出 Foo;</span></span><br><span class="line">var_dump($a); <span class="comment">// 返回 NULL , 这里的yield 并没有返回任何值</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="yield-同时接受和发送数据"><a href="#yield-同时接受和发送数据" class="headerlink" title="yield 同时接受和发送数据"></a>yield 同时接受和发送数据</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$gen = gen();</span><br><span class="line">var_dump($gen-&gt;current());    <span class="comment">// string(6) "yield1"</span></span><br><span class="line">var_dump($gen-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1"   (the first var_dump in gen)</span></span><br><span class="line">                              <span class="comment">// string(6) "yield2" (the var_dump of the -&gt;send() return value)</span></span><br><span class="line">var_dump($gen-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2"   (again from within gen)</span></span><br><span class="line">                              <span class="comment">// NULL               (the return value of -&gt;send())</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>逐句分析</p>
<p>$ gen = gen() 指针指向这个迭代器</p>
<p>$ gen-&gt; current() 运行到第一个yield ，返回 yield 语句的值 yield，并 输出 类型和值</p>
<p>$ gen -&gt;send(“ret1”)  当前生成器在 yield 语句，于是把 “ret1” 当做 （yield “yield1”）的结果，并赋值给 $ret1。而且还会执行一个 gen-&gt;next() 移到下一个yield 处，返回第二个yield 语句的返回值</p>
<p>$ gen -&gt;send(“ret2”)  当前生成器在第二个yield 语句，把”ret2” 当做   (yield “yield2”) 的结果，并赋值给 $ret2 。继续向下执行，此时指针会移至迭代器末尾，此时已经没有yield ，所以返回NULL</p>
<h3 id="多任务合作"><a href="#多任务合作" class="headerlink" title="多任务合作"></a>多任务合作</h3><p>为了帮助理解 协程和任务调度的关机，yield 在 任务运行的过程中可以主动中断自身，并把控制权交还给调度器。</p>
<p>这里我们先需要实现: 任务、调度器</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123; <span class="comment">//实现一个任务</span></span><br><span class="line">    <span class="keyword">protected</span> $taskId; <span class="comment">//任务ID</span></span><br><span class="line">    <span class="keyword">protected</span> $coroutine;<span class="comment">//协程</span></span><br><span class="line">    <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;<span class="comment">//send 传送的value</span></span><br><span class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;<span class="comment">//是不是第一次传送</span></span><br><span class="line">    <span class="comment">// 因为每次send 返回的值，都是当前yield 的下一个yield 的返回值，这导致了第一个yield 的返回值被丢弃了。对于第一个 yield，我们需要用current()获取返回值，从第二个往后用send()获取返回值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;<span class="comment">//协程类型是 迭代器</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;<span class="comment">// 如果是第一次yield，那么就用current()返回</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是第一个yield，就用send设置一个value，并返回下一个yield的值</span></span><br><span class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;<span class="comment">//设置完毕清空value</span></span><br><span class="line">            <span class="keyword">return</span> $retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();<span class="comment">// 判断迭代器是否迭代完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;<span class="comment">//实现一个调度器</span></span><br><span class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>; <span class="comment">// 最大任务</span></span><br><span class="line">    <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></span><br><span class="line">    <span class="keyword">protected</span> $taskQueue;<span class="comment">// 任务队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue(); <span class="comment">// 实例化一个队列</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</span><br><span class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;<span class="comment">// 生成任务id</span></span><br><span class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine); <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;<span class="comment">// 标识 taskId =&gt; task</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">        <span class="keyword">return</span> $tid;</span><br><span class="line">    &#125;</span><br><span class="line"> 		</span><br><span class="line">    <span class="comment">//任务入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</span><br><span class="line">            $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();<span class="comment">// 出队</span></span><br><span class="line">            $task-&gt;run(); <span class="comment">//任务运行</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123; <span class="comment">//当前任务结束，删除</span></span><br><span class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;schedule($task);<span class="comment">//未完成的话，放入队尾继续执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>用一个例子看看程序是否按照我们的期望在运行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>); <span class="comment">// 载入定义好的模块</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"Scheduler.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;<span class="comment">// 程序运行10次</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;<span class="comment">// 程序运行5次</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">5</span>; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task 2 iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;newTask(task1());</span><br><span class="line">$scheduler-&gt;newTask(task2());</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"></span><br><span class="line">结果如下:</span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">1.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">1.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">2.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">2.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">3.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">3.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">4.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">4.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">5.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">5.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">6.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">7.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">8.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">9.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">10.</span></span><br></pre></td></tr></table></figure>

<p>发现程序是交替运行的，和我们的预期是相同的。因为我们使用了队列的结构，若是一个任务从队列中取出后并没有运行结束，我们会放入队尾继续运行。</p>
<h4 id="与调度器之间的通信"><a href="#与调度器之间的通信" class="headerlink" title="与调度器之间的通信"></a>与调度器之间的通信</h4><p>我们再看一眼，上面例子中需要运行的程序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;<span class="comment">// 程序运行10次</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>; <span class="comment">// &lt;-- 若是要在用调度器中的taskid 替代此句需要怎么做。</span></span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实现：任务与调度器之间的通信。</p>
<p>我们使用的是 进程用来和操作系统会话的同样的方式来通信：系统调用。</p>
<p>要注意的是，不能简单的把调度器作为一个参数，传递给任务，不然很危险。这里作者通过yield表达式，配合send 来传递信息。</p>
<p>首先是对可调用的系统调用做一个封装</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $callback;</span><br><span class="line">    <span class="comment">// 传入的值是 一个可调用的类/函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(callable $callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;callback = $callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __invoke:当类发生调用的使用使用</span></span><br><span class="line">    <span class="comment">// 这样，类在使用的时候看上去和一个函数一样</span></span><br><span class="line">    <span class="comment">// 传入的参数是 任务 和 调度器</span></span><br><span class="line">    <span class="comment">// 作用是运行 初始化的函数/类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $callback = <span class="keyword">$this</span>-&gt;callback;</span><br><span class="line">        <span class="keyword">return</span> $callback($task, $scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面我们需要进行消息通讯</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">($max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们需要传入 $tid 的值 从调度器中</span></span><br><span class="line">    $tid = (<span class="keyword">yield</span> getTaskId()); <span class="comment">// &lt;-- here's the syscall!</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task $tid iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line"> </span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">10</span>));</span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，我们需要对传入的getTaskId 进行修改</p>
<p>传入的值是来自与调度器和任务的，结合之前的封装的系统调用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(<span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $task-&gt;setSendValue($task-&gt;getTaskId());</span><br><span class="line">        $scheduler-&gt;schedule($task);</span><br><span class="line">        <span class="comment">// 这里返回的是一个系统调用</span></span><br><span class="line">        <span class="comment">// 作用是给任务设置 send 的值，send值的内容是 taskid</span></span><br><span class="line">        <span class="comment">// 把此任务加入调度器的队列中去</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里return 的不是如函数名写的 taskid，而是一个系统调用。</p>
<p>最后程序中的 $tid = (yield getTaskId()); 又会把这个系统调用传入调度器的队列中</p>
</blockquote>
<p>进过这样的操作，我们调度器的队列中有两种类型的任务</p>
<ul>
<li>SystemCall类型，但是它也可以和函数一样调用</li>
<li>Task 类型，也就是我们的任务类型</li>
</ul>
<p>所以我们必须还要修改一下调度器的run方法（其实就是加入一段对SystemCall 的处理）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</span><br><span class="line">        $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</span><br><span class="line">        $retval = $task-&gt;run();</span><br><span class="line"> 				</span><br><span class="line">       <span class="comment">// 这一段是新加的,如果出队的类型是系统调用，就在调度器里面调用它，传入任务 和 调度器</span></span><br><span class="line">       <span class="comment">// 调用的结果是 </span></span><br><span class="line">       <span class="comment">// $task 会设置一个 Send 值</span></span><br><span class="line">       <span class="comment">// $this(调度器) 会把这个 $task 加入到调度器的末尾</span></span><br><span class="line">        <span class="keyword">if</span> ($retval <span class="keyword">instanceof</span> SystemCall) &#123;</span><br><span class="line">            $retval($task, <span class="keyword">$this</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//--------------------------</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</span><br><span class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在xdebug 的帮助下，我们可以看到第一次 <code>$retval = $task-&gt;run()</code> 的返回值，会走到 Task(line: 24) 的<code>$this-&gt;coroutine-&gt;current();</code> 最终取得的 <code>getTaskId()</code> 的返回值(类型为 SystemCall)</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215161137.png" class="lozad"></p>
<p>第二次走到<code>$retval = $task-&gt;run()</code> 的时候，最终是返回task 函数中的<code>yield();</code> 所以返回值是<code>null</code>。</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215162115.png" class="lozad"></p>
<p>运行的结果就是，两个任务交替运行，知道结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is task 1 iteration 1.</span><br><span class="line">This is task 2 iteration 1.</span><br><span class="line">This is task 1 iteration 2.</span><br><span class="line">This is task 2 iteration 2.</span><br><span class="line">This is task 1 iteration 3.</span><br><span class="line">This is task 2 iteration 3.</span><br><span class="line">This is task 1 iteration 4.</span><br><span class="line">This is task 2 iteration 4.</span><br><span class="line">This is task 1 iteration 5.</span><br><span class="line">This is task 2 iteration 5.</span><br><span class="line">This is task 1 iteration 6.</span><br><span class="line">This is task 1 iteration 7.</span><br><span class="line">This is task 1 iteration 8.</span><br><span class="line">This is task 1 iteration 9.</span><br><span class="line">This is task 1 iteration 10.</span><br></pre></td></tr></table></figure>



<h2 id="协程堆栈"><a href="#协程堆栈" class="headerlink" title="协程堆栈"></a>协程堆栈</h2><p>协程堆栈是一个非常重要的应用，当你的项目变得越来越大的时候，会出现协程中套用另一个协程的情况。我们看下面这个例子。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123; <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    echoTimes(<span class="string">'foo'</span>, <span class="number">10</span>); <span class="comment">// 期待打印10次foo，实际上返回的协程，并没有真实运行过</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    echoTimes(<span class="string">'bar'</span>, <span class="number">5</span>); <span class="comment">// 期待打印5次bar，实际上返回的协程，并没有真实运行过</span></span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line">$scheduler-&gt;newTask(task());</span><br><span class="line">$scheduler-&gt;run();<span class="comment">// 运行结果： ---\n</span></span><br></pre></td></tr></table></figure>

<p>最终的结果只运行了<code>echo &quot;---\n&quot;;</code>  </p>
<p>原因也很简单，当<code>echoTimes(&#39;foo&#39;, 10)</code> 运行后，实际上返回的协程，并没有参数去接受，也没有对协程进行进一步的处理（如 <code>$this-&gt;current()</code> <code>$this-&gt;send</code> ）自然也就不会运行了。</p>
<p>但是若是直接调用 echoTimes 子协程，也是无法运行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> echoTimes(<span class="string">'foo'</span>, <span class="number">10</span>); <span class="comment">// 添加了 yield 语句</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    <span class="keyword">yield</span> echoTimes(<span class="string">'bar'</span>, <span class="number">5</span>); <span class="comment">// 添加了 yield 语句</span></span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里<code>yield echoTimes(&#39;foo&#39;, 10);</code>返回的是一个Generator 类型，而在我们的Task 类的run 方法里面，并没有对这一类型进行处理。而且我们需要的是进入函数内执行 yield 语句。这样来说，我们原先的方法就不适用了。如何解决？？</p>
<blockquote>
<p> 解决的方法就是使用——<strong><em>协程栈</em></strong></p>
</blockquote>
<p>首先，我们对传入的 $coroutine 裸协程上写一个小小的封装，stackedCoroutine就是：<strong><em>“协程堆栈”</em></strong>。 因为它将管理嵌套的协程调用堆栈。这将使得通过生成协程来调用子协程成为可能。</p>
<blockquote>
<p>注意: stackedCoroutine 中包含 yield 语句，所以它也是一个协程</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span><span class="params">(Generator $gen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $stack = <span class="keyword">new</span> SplStack; <span class="comment">// 新建一个栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断遍历这个传进来的生成器，作用和 while(True)一样</span></span><br><span class="line">    <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">        <span class="comment">// $gen可以理解为指向当前运行的协程闭包函数（生成器）</span></span><br><span class="line">        $value = $gen-&gt;current(); <span class="comment">// 获取中断点，也就是yield出来的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($value <span class="keyword">instanceof</span> Generator) &#123;</span><br><span class="line">            <span class="comment">// 如果是也是一个生成器，这就是子协程了，把当前运行的协程入栈保存</span></span><br><span class="line">            $stack-&gt;push($gen);</span><br><span class="line">            $gen = $value; <span class="comment">// 把子协程函数给gen，继续执行，注意接下来就是执行子协程的流程了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们对子协程返回的结果做了封装</span></span><br><span class="line">        $isReturnValue = $value <span class="keyword">instanceof</span> CoroutineReturnValue; <span class="comment">// 子协程返回`$value`需要主协程帮忙处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!$gen-&gt;valid() || $isReturnValue) &#123;<span class="comment">// 协程栈没有执行完 或者 存在返回值</span></span><br><span class="line">            <span class="keyword">if</span> ($stack-&gt;isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是gen已经执行完毕，或者遇到子协程需要返回值给主协程去处理</span></span><br><span class="line">            $gen = $stack-&gt;pop(); <span class="comment">//出栈，得到之前入栈保存的主协程</span></span><br><span class="line">            $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="keyword">NULL</span>); <span class="comment">// 调用主协程处理子协程的输出值</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        $gen-&gt;send(<span class="keyword">yield</span> $gen-&gt;key() =&gt; $value); <span class="comment">// 继续执行子协程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这段语句中使用了到了一个我们之前没有使用到的类 <code>CoroutineReturnValue</code> 它的作用是接受 yield 的返回值，这个类比较简单，就是对返回的值，做了一层封装。子协程的返回的结果也需要主协程帮助处理。</p>
<blockquote>
<p>在 $gen-&gt;send(yield ​$gen-&gt;key()=&gt;$value)；</p>
<p>调用者和当前正在运行的子协程之间扮演着简单代理的角色。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineReturnValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;value = $value;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 获取能把子协程的输出值给主协程，作为主协程的send参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回的值被封装成了一个类，这个类的话也很简单，就是存值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retval</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CoroutineReturnValue($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义完了协程栈，如何去使用呢？这里需要将Task中的初始化方法改一下。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</span><br><span class="line">        <span class="comment">// $this-&gt;coroutine = $coroutine;</span></span><br><span class="line">        <span class="comment">// 换成这个，实际Task-&gt;run的就是stackedCoroutine这个函数，不是$coroutine保存的闭包函数了</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;coroutine = stackedCoroutine($coroutine); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主程序如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Scheduler.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"stackedCorountine.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> retval(<span class="string">"程序运行结束"</span>); <span class="comment">//我们在这里让子协程传值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = <span class="keyword">yield</span> echoTimes(<span class="string">'foo'</span>, <span class="number">5</span>); <span class="comment">// print foo ten times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    $ret = (<span class="keyword">yield</span> echoTimes(<span class="string">'bar'</span>, <span class="number">2</span>)); <span class="comment">// print bar five times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line">$scheduler-&gt;newTask(task());</span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">foo iteration <span class="number">1</span></span><br><span class="line">foo iteration <span class="number">2</span></span><br><span class="line">foo iteration <span class="number">3</span></span><br><span class="line">foo iteration <span class="number">4</span></span><br><span class="line">foo iteration <span class="number">5</span></span><br><span class="line">程序运行结束</span><br><span class="line">---</span><br><span class="line">bar iteration <span class="number">1</span></span><br><span class="line">bar iteration <span class="number">2</span></span><br><span class="line">程序运行结束</span><br></pre></td></tr></table></figure>

<p>这个程序真的是不容易看懂，我是在xdebug 的逐步调试的过程中才看懂了一点。</p>
<p>解释下<code>$gen-&gt;send(yield $gen-&gt;key()=&gt;$value)；</code> 这个语句中send 和 yield 交叉，而且用了 <code>$gen-&gt;key =&gt; $value</code>  这样的用法。</p>
<p>yield 有三种用法 </p>
<p><strong>参考：</strong><a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">php manual: yield</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>; <span class="comment">// 相当于 (yield null);</span></span><br><span class="line">$data = (<span class="keyword">yield</span> $value); <span class="comment">// 必须使用圆括号把yield申明包围起来</span></span><br><span class="line">$data = (<span class="keyword">yield</span> $key =&gt; $value); <span class="comment">//返回的是键值对，迭代的时候用 foreach($data as $key =&gt; $value)</span></span><br></pre></td></tr></table></figure>

<p>首先我们找到 <code>(yield $gen-&gt;key()=&gt;$value)；</code> 返回的地方</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();  <span class="comment">// &lt;-- 返回的是这里</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue); <span class="comment">// &lt;-- 返回的是这里</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">return</span> $retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会让人很奇怪，因为我们返回的是键值对，这里直接调用current() 。经过实践可知 最终的值是<code>$value</code> ，也就是说，我们直接把语句改成 <code>(yield $value)</code> 也是正确的。</p>
<p>我的第二个疑问是<code>$gen-&gt;send(yield $gen-&gt;key()=&gt;$value)；</code> 中 send 方法到低发送出去了什么❓</p>
<p>send  方法中是一个yield 语句。那我们就可以找找在这个协程中有没有对应的send 方法即可。</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191216192955.png" class="lozad"></p>
<p>最后，我们找到了这个协程的send 方法，但是<code>$this-&gt;sendValue</code> 我们是一直都没有设置过，始终是null。</p>
<h3 id="协程堆栈小结"><a href="#协程堆栈小结" class="headerlink" title="协程堆栈小结"></a>协程堆栈小结</h3><p>这个协程堆栈实现起来比较费脑子，特别是主协程和子协程之间的沟通方式。可能现实情况下动手写的情况很少（我感觉是框架已经实现完毕，我们只需要简单的使用 <code>$ret = (yield readfile());</code> 语句就可以）。但是如果能自己实现一遍协程堆栈，对yield 的用法肯定掌握的更好。</p>
<p>这篇教程参考了很多博客</p>
<p><a href="https://segmentfault.com/a/1190000012457145" target="_blank" rel="noopener">PHP7下的协程实现</a></p>
<p><a href="http://reatang.com/?id=23" target="_blank" rel="noopener">我是这么理解协程yield异步IO的</a></p>
<p>TO DO LIST</p>
<ul>
<li><input disabled type="checkbox"> yield from</li>
<li><input disabled type="checkbox"> 教程中的 非阻塞IO 案例 代码分析 测试 配合<a href="http://reatang.com/?id=23" target="_blank" rel="noopener">我是这么理解协程yield异步IO的</a></li>
</ul>
<h2 id="程序附录"><a href="#程序附录" class="headerlink" title="程序附录"></a>程序附录</h2><h3 id="程序一：-与调度器之间的通讯"><a href="#程序一：-与调度器之间的通讯" class="headerlink" title="程序一： 与调度器之间的通讯"></a>程序一： 与调度器之间的通讯</h3><p>Index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Scheduler.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"SystemCall.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(<span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $task-&gt;setSendValue($task-&gt;getTaskId());</span><br><span class="line">        $scheduler-&gt;schedule($task);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">($max)</span> </span>&#123;</span><br><span class="line">    $tid = (<span class="keyword">yield</span> getTaskId()); <span class="comment">// &lt;-- here's the syscall!</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task $tid iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">10</span>));</span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>Scheduler.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></span><br><span class="line">    <span class="keyword">protected</span> $taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> \SplQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</span><br><span class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</span><br><span class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">        <span class="keyword">return</span> $tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</span><br><span class="line">            $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</span><br><span class="line">            $retval = $task-&gt;run();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($retval <span class="keyword">instanceof</span> SystemCall) &#123;</span><br><span class="line">                $retval($task, <span class="keyword">$this</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</span><br><span class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>SystemCall.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(callable $callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;callback = $callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $callback = <span class="keyword">$this</span>-&gt;callback;</span><br><span class="line">        <span class="keyword">return</span> $callback($task, $scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $taskId;</span><br><span class="line">    <span class="keyword">protected</span> $coroutine;</span><br><span class="line">    <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> $retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="程序二：-协程堆栈"><a href="#程序二：-协程堆栈" class="headerlink" title="程序二： 协程堆栈"></a>程序二： 协程堆栈</h3><p>index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Scheduler.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"stackedCorountine.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> retval(<span class="string">"程序运行结束\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = <span class="keyword">yield</span> echoTimes(<span class="string">'foo'</span>, <span class="number">5</span>); <span class="comment">// print foo ten times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    $ret = (<span class="keyword">yield</span> echoTimes(<span class="string">'bar'</span>, <span class="number">2</span>)); <span class="comment">// print bar five times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line">$scheduler-&gt;newTask(task());</span><br><span class="line">$scheduler-&gt;run();</span><br></pre></td></tr></table></figure>



<p>stackedCoroutine.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span><span class="params">(Generator $gen)</span> </span>&#123;</span><br><span class="line">    $stack = <span class="keyword">new</span> SplStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        $value = $gen-&gt;current();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($value <span class="keyword">instanceof</span> Generator) &#123;</span><br><span class="line">            $stack-&gt;push($gen);</span><br><span class="line">            $gen = $value;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $isReturnValue = $value <span class="keyword">instanceof</span> CoroutineReturnValue;</span><br><span class="line">        <span class="keyword">if</span> (!$gen-&gt;valid() || $isReturnValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($stack-&gt;isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $gen = $stack-&gt;pop();</span><br><span class="line">            $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="keyword">NULL</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $gen-&gt;send( (<span class="keyword">yield</span> $gen-&gt;key() =&gt; $value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineReturnValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;value = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取能把子协程的输出值给主协程，作为主协程的send参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retval</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CoroutineReturnValue($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task.php  和   Scheduler.php 不变</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用SSH连接家中的服务器</title>
    <url>/2019/12/01/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%AE%B6%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>家中闲置了一台电脑，准备用来当做服务器。一方面也是作为linux 学习练练手，二是可以运行一些爬虫小程序或者是网页服务。</p>
<p>这里我用的manjaro，这是目前比较流行的linux 发行版，最热门的linux桌面发行版之一。</p>
<p>我选择manjaro也是想作为替代windows 来用。manjaro拥有一个非常方便的软件仓库，利用pacman和yay等命令可以十分方便的安装软件。</p>
<p>家中的电脑，由于没有公网ip，只能在家中用ssh 访问，一旦出门，就无法访问服务器了。这非常不方便，因为可能要从电脑上获取资料，访问数据库，修改代码等等操作，一旦离开本地环境，也太不方便了。</p>
<p>经过百度后发现，需要利用  <strong>内网穿透</strong> 技术实现。 内网穿透技术有很多了，我这里选择的是ngrok 这个方案。</p>
<p>我试了一下两种方案，第一个是外国的，没有尝试成功，而且免费版本每次断开后，生成的url 是随机的。所以没有采用。第二个是国内的Sunny-Ngrok，有免费版的。先尝试一波，如果好用再购买。</p>
<ul>
<li><a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">ngrok</a></li>
<li><a href="https://www.ngrok.cc/download.html" target="_blank" rel="noopener">ngrok.cc</a>  （Sunny-Ngrok）</li>
</ul>
<a id="more"></a>

<h2 id="局域网连接服务器"><a href="#局域网连接服务器" class="headerlink" title="局域网连接服务器"></a>局域网连接服务器</h2><p>这里先给出用局域网连接服务器的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux 查看ip 地址一般是下面三种方法（不同系统不一样）</span></span><br><span class="line">$ ifconfig</span><br><span class="line">$ ipconfig</span><br><span class="line">$ ip addr &lt;--manjaro</span><br></pre></td></tr></table></figure>
<p>运行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip addr | grep inet</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">    inet 192.168.1.102/24 brd 192.168.1.255 scope global dynamic noprefixroute wlp2s0</span><br><span class="line">    inet6 fe80::1bd5:9435:6572:ffc7/64 scope link noprefixroute</span><br><span class="line"><span class="comment"># ip地址是 192.168.1.102</span></span><br></pre></td></tr></table></figure>
<p>局域网中使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 22 ppsteven@192.168.1.l02</span><br><span class="line"><span class="comment"># -p 22 也可以省略，因为ssh 的默认端口号就是22</span></span><br></pre></td></tr></table></figure>

<p>方便起见，我选择把这条语句在zsh中创建一个别名</p>
<p>把<code>alias locallogin=&quot;ssh ppsteven@192.168.1.102&quot;</code>添加在<code>~/.zshrc</code>配置中</p>
<h2 id="Sunny-Ngrok教程"><a href="#Sunny-Ngrok教程" class="headerlink" title="Sunny-Ngrok教程"></a>Sunny-Ngrok教程</h2><p>教程基本上都在 <a href="http://www.ngrok.cc/_book/general/tcp.html" target="_blank" rel="noopener">ngrok.cc官方文档</a> 写的很清楚了，但是有一些还是需要注意的。</p>
<h3 id="开通隧道"><a href="#开通隧道" class="headerlink" title="开通隧道"></a>开通隧道</h3><p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191201135321.png" class="lozad"></p>
<p>如果你是想用ssh，开通的就是TCP转发。记得要把本地端口换成22（当然不换也是可以的，只要你最后连ssh 的时候设置好端口就行了）</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191201135519.png" class="lozad"></p>
<p>最后看到的结果是这样的</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191201153141.png" class="lozad"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -p 10568 psteven@free.aa.com 就可以连接上你的服务器了</span><br></pre></td></tr></table></figure>

<h3 id="Ngrok-启动"><a href="#Ngrok-启动" class="headerlink" title="Ngrok 启动"></a>Ngrok 启动</h3><p>上图可以看到，在状态栏显示 是否成功开启ngrok</p>
<p>启动的方法，官网教程里面也有写，本人按照流程走一遍。</p>
<h3 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h3><p>我用的是Mac 下载zip文件，然后上传到服务器的操作。有图形界面的同学，可以直接按照官网操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp ~/Downloads/linux_amd64.zip ppsteven@192.168.1.102:~/Documents</span><br><span class="line">$ ssh 192.168.1.102</span><br><span class="line">$ <span class="built_in">cd</span> ~/Documents</span><br><span class="line">$ unzip linux_amd64.zip</span><br></pre></td></tr></table></figure>
<h3 id="启动ngrok-服务"><a href="#启动ngrok-服务" class="headerlink" title="启动ngrok 服务"></a>启动ngrok 服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前目录在linux_amd64 下</span></span><br><span class="line">$ ./sunny clientid 隧道id  <span class="comment"># 启动隧道服务</span></span><br><span class="line">$ nohup ./sunny clientid 743acXXXX &gt; sunny.out &amp; <span class="comment"># 在后台启动隧道服务</span></span><br></pre></td></tr></table></figure>
<p>启动服务后，我们在官网的后端就可以看到结果。<br>为了让我们的服务器能不断的在后台运行，我们需要登录服务器后，运行第二行的命令</p>
<ul>
<li>&amp; 作用是后台运行程序</li>
<li>nohup 作用是当终端关闭的时候命令一直不会关闭</li>
<li>&gt; sunny.out 表示把运行的结果输出到文件 sunny.out 中<br> 这一段语句感觉必须加上去，本人尝试过 <code>nohup ./sunny clientid 隧道id &amp;</code> 命令后，<br>程序用 <code>jobs</code> 显示的是 suspended 状态，在后台中查询端口也是 <strong>不在线</strong>的状态。<br>加上这一条输出语句，正常了。</li>
<li>若是 遇到suspended 的进程<br>用以下语句可以运行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs # 查看当前终端中的进程（当关闭终端就看不到了）</span><br><span class="line">fg %1 # 后台程序调入前台并运行</span><br><span class="line">bg %1 # 后台程序在后台运行</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="连接远程服务器"><a href="#连接远程服务器" class="headerlink" title="连接远程服务器"></a>连接远程服务器</h3><p>ngrok 的作用直观的来说，就是给我们提供了一个公网ip，使我们可以访问内网地址。<br>可以简单的认为 192.168.1.102 等于 <a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> (提供的域名)，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -p PORT_NUM ppsteven@www.abc.com</span><br></pre></td></tr></table></figure>

<h2 id="zshrc-配置小结"><a href="#zshrc-配置小结" class="headerlink" title=".zshrc 配置小结"></a>.zshrc 配置小结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> localDell=<span class="string">"ssh ppsteven@192.168.1.102"</span></span><br><span class="line">$ <span class="built_in">alias</span> remoteDell=<span class="string">"ssh -p 10568 ppsteven@free.aa.com"</span></span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/91684175" target="_blank" rel="noopener">有了内网穿透神器 ngrok ，个人电脑也能做服务器</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>sunny-ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基础命令</title>
    <url>/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近的工作</p>
<ul>
<li>php 学习，设计到LAMP的环境搭建。虽然是Mac上Apache 和 php 都是自带的，但是环境上还是不足，所以要用Docker。DAMP</li>
<li>爬虫ip 池搭建，发现别人造好的轮子上需要如redis，flask等环境。而且配置完了，最终也是要部署到服务器上去的，所以docker 是必不可少的</li>
</ul>
<p>最近的工作，让我感到Docker的学习一定要提前了。因为只是先用起来，首先记录一些常用的命令，争取一天搞定。</p>
<a id="more"></a>

<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>我的主力机子是Mac，家里用旧电脑搭了 manjaro ，所以我需要两个安装教程</p>
<h3 id="Mac-Docker安装"><a href="#Mac-Docker安装" class="headerlink" title="Mac Docker安装"></a>Mac Docker安装</h3><p>Mac 上配置docker最为方便</p>
<blockquote>
<p>这里参考 <a href="https://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">菜鸟教程:MacOS Docker 安装</a> </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cask install docker </span><br><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">$ docker info </span><br><span class="line">$ docker -v</span><br></pre></td></tr></table></figure>
<p><strong>镜像加速</strong><br>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a></p>
<p>在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。<br><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191124001923.png" class="lozad"></p>
<h3 id="Manjaro-docker-安装"><a href="#Manjaro-docker-安装" class="headerlink" title="Manjaro docker 安装"></a>Manjaro docker 安装</h3><p>Manjaro 也拥有非常强大的包管理软件 pacman 和 yay<br>这里我们使用pacman，这里面的软件都是来自官方库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">$ sudo pacman -S docker</span><br><span class="line"><span class="comment"># 启动docker 服务</span></span><br><span class="line">$ sudo systemctl start docker </span><br><span class="line"><span class="comment"># 查看docker服务状态</span></span><br><span class="line">$ sudo systemctl status docker</span><br><span class="line"><span class="comment"># 设置docker开启启动服务</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>这里Linux 有一个比Mac 麻烦一点的地方，就是每次使用docker 需要用sudo 超级管理员权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果还没有 docker group 就添加一个</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将自己的登录名($&#123;USER&#125; )加入该 group 内。然后退出并重新登录就生效啦</span></span><br><span class="line">sudo gpasswd -aG <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker 服务</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p><strong>Linux 镜像加速</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建配置文件</span></span><br><span class="line">$ sudo touch /etc/docker/daemon.json </span><br><span class="line"><span class="comment"># 添加国内站点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>,<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker daemon</span></span><br><span class="line">$ sudo systemctl restart docker </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否有修改成功</span></span><br><span class="line">$ docker info </span><br><span class="line"><span class="comment"># 查看Register Mirrors的信息</span></span><br><span class="line">Registry Mirrors:</span><br><span class="line">  https://registry.docker-cn.com/</span><br><span class="line">  http://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>



<h2 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的镜像 images</span></span><br><span class="line"><span class="variable">$docker</span> images</span><br><span class="line"><span class="variable">$docker</span> image ls </span><br><span class="line">REPOSITORY       TAG     IMAGE ID      CREATED             SIZE</span><br><span class="line">ubuntu          latest   775349758637  2 weeks ago         64.2MB</span><br><span class="line"><span class="comment"># 标签的含义</span></span><br><span class="line">- REPOSTITORY：表示镜像的仓库源</span><br><span class="line">- TAG：镜像的标签</span><br><span class="line">- IMAGE ID：镜像ID</span><br><span class="line">- CREATED：镜像创建时间</span><br><span class="line">- SIZE：镜像大小</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取镜像</span></span><br><span class="line"><span class="variable">$docker</span> pull ubuntu:13.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找镜像</span></span><br><span class="line"><span class="variable">$docker</span> search ubuntu</span><br><span class="line">- NAME:镜像仓库源的名称</span><br><span class="line">- DESCRIPTION:镜像的描述</span><br><span class="line">- OFFICIAL:是否docker官方发布</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line"><span class="variable">$docker</span> rmi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有镜像</span></span><br></pre></td></tr></table></figure>



<h2 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h2><p>docker run 是docker 命令中比较复杂的一个命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> run &lt;images&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="variable">$docker</span> run busybox <span class="built_in">echo</span> hello world</span><br><span class="line"><span class="variable">$docker</span> run Ubuntu:16.01 /bin/bash</span><br><span class="line"><span class="variable">$docker</span> run -t-i Ubuntu:16.01 /bin/bash</span><br><span class="line">-t-i: 交互式会话</span><br><span class="line">-d: 后台方式</span><br><span class="line">--rm: 运行完成后就会删除</span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -ti &lt;CONTAINER ID&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面所有的&lt;CONTAINER ID&gt; 都可以用容器的NAME 替代</span></span><br><span class="line"><span class="comment"># docker 很贴心的为我们的容器起了名字</span></span><br><span class="line"><span class="comment"># 列出运行容器</span></span><br><span class="line"><span class="variable">$docker</span> ps </span><br><span class="line"><span class="variable">$docker</span> ps -a <span class="comment"># 包含停止但没有消失的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止正在运行的容器</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="variable">$docker</span> stop &lt;CONTAINER ID&gt; </span><br><span class="line"><span class="comment"># 两个命令都是会停止容器运行</span></span><br><span class="line"><span class="comment"># 停止没有消失的容器</span></span><br><span class="line"><span class="variable">$docker</span> restart &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="variable">$docker</span> start &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="comment"># 启动并进入交互界面</span></span><br><span class="line"><span class="variable">$docker</span> start -it &lt;CONTAINER ID&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除无用的容器</span></span><br><span class="line"><span class="variable">$docker</span> rm &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="comment"># 删除所有已停止的容器</span></span><br><span class="line"><span class="variable">$docker</span> rm -v $(docker ps -aq -f status=exited)</span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line"><span class="variable">$docker</span> rm $(docker ps -a)</span><br></pre></td></tr></table></figure>

<h2 id="查看docker输出"><a href="#查看docker输出" class="headerlink" title="查看docker输出"></a>查看docker输出</h2><p>用于查看docker 的输出，对于没有交互(-ti)的容器的时候，需要用这个命令查看容器输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> logs &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> cp &lt;CONTAINER ID&gt;:[/path/to/file]</span><br></pre></td></tr></table></figure>

<h2 id="Docker-LNMP环境搭建"><a href="#Docker-LNMP环境搭建" class="headerlink" title="Docker LNMP环境搭建"></a>Docker LNMP环境搭建</h2><blockquote>
<p>这里我用的是github 上phplearn<br>有一份教程整理的也很不错，下面列出来，以后继续看<br><a href="https://www.awaimai.com/2120.html#9" target="_blank" rel="noopener">Docker LNMP环境搭建</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cd</span> phplearn</span><br><span class="line"><span class="variable">$docker</span>-compose up <span class="comment"># 启动容器</span></span><br><span class="line"><span class="variable">$docker</span>-compose stop <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://github.com/eon01/DockerCheatSheet" target="_blank" rel="noopener">DockerCheatSheet</a><br><a href="https://www.cnblogs.com/imzhizi/p/10718310.html" target="_blank" rel="noopener">Linux(Manjaro) -Docker 安装及基本配置</a></p>
</blockquote>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>日常学习笔记</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 搜索技巧</title>
    <url>/2019/11/21/Github%20%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为最近手头上的东西很多，要最快的在很短的时间内完成一个项目，需要多多参考别人的优秀的代码。很多东西，在github 上都开源了，反复造轮子浪费时间，用好别人东西才是最高效的方法。</p>
<a id="more"></a>

<h2 id="瞎逛逛"><a href="#瞎逛逛" class="headerlink" title="瞎逛逛"></a>瞎逛逛</h2><ul>
<li><a href="https://github.com/trending" target="_blank" rel="noopener">GitHub Trend</a> 页面总结了每天/每周/每月周期的热门 Repositories 和 Developers，你可以看到在某个周期处于热门状态的开发项目和开发者。</li>
<li><a href="https://github.com/topics" target="_blank" rel="noopener">GitHub Topic</a> 展示了最新和最流行的讨论主题，在这里你不仅能够看到开发项目，还能看到更多非开发技术的讨论主题，比如 Job、Chrome 浏览器等。</li>
</ul>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:name xx //搜索名字中带有&quot;xx&quot;的</span><br><span class="line">in:readme xx //搜索readme中带有&quot;xx&quot;的</span><br><span class="line">in:description xx //搜索描述中带有&quot;xx&quot;的</span><br><span class="line">stars:&gt;1000 //搜索stars&gt;1000的</span><br><span class="line">forks:&gt;1000 //搜索forks&gt;1000的</span><br><span class="line">pushed:&gt;2019-09-01 //搜索最近更新于2019年9月1日之后的</span><br><span class="line">language:xx //搜索xx的项目</span><br><span class="line">pushed:&gt;2019-09-01 //2019年9月1日后有更新的</span><br><span class="line">language:java //用Java编写的项目</span><br><span class="line">user:ppsteven forks:&gt;100 //ppsteven用户下forks&gt;100 的项目</span><br></pre></td></tr></table></figure>

<h2 id="有影响力的项目"><a href="#有影响力的项目" class="headerlink" title="有影响力的项目"></a>有影响力的项目</h2><ul>
<li><a href="https://github.com/vhf/free-programming-books" target="_blank" rel="noopener">free-programming-books</a>：整理了所有和编程相关的免费书籍，同时也有 <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">中文版项目</a>。</li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet/" target="_blank" rel="noopener">github-cheat-sheet</a>：集合了使用 GitHub 的各种技巧。</li>
<li>后续会逐步更新添加</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://sspai.com/post/46061" target="_blank" rel="noopener">掌握 3 个搜索技巧，在 GitHub 上快速找到实用软件资源</a></p>
</blockquote>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>Github,</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记</title>
    <url>/2019/11/19/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>php 入门教程，主要来自于菜鸟教程，入门级别。</p>
<p>随后慢慢的补充</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;My first PHP page&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php 代码</span></span><br><span class="line">？&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  单行注释</span></span><br><span class="line"><span class="comment">/**/</span> 多行注释</span><br></pre></td></tr></table></figure>

<h2 id="echo-print"><a href="#echo-print" class="headerlink" title="echo/print"></a>echo/print</h2><p>echo // 多个<br>print // 一个</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="comment">//两行是相同效果，&lt;br&gt; 看做回车</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Hello world! from:"</span>,<span class="string">"Elen"</span>,<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Hello world! from:"</span>.<span class="string">"Elen"</span>.<span class="string">'&lt;br&gt;'</span>; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> Echo,print,print_r,var_dump 区别</p>
</blockquote>
<p><strong>1.echo</strong></p>
<p>输出一个或者多个字符串。</p>
<p><strong>2.print</strong></p>
<p>和 echo 最主要的区别： print 仅支持一个参数，并总是返回 1。</p>
<p><strong>3.print_r</strong></p>
<p>打印关于变量的易于理解的信息,如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 记住，print_r() 将把数组的指针移到最后边。使用 reset() 可让指针回到开始处。</p>
<p><strong>4.var_dump</strong></p>
<p>此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p>
<p><strong>5.var_dump 和 print_r 的区别</strong></p>
<p>var_dump 返回表达式的类型与值而 print_r 仅返回结果，相比调试代码使用 var_dump 更便于阅读。</p>
<h2 id="EOF-定义字符串"><a href="#EOF-定义字符串" class="headerlink" title="EOF 定义字符串"></a>EOF 定义字符串</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name=<span class="string">"Sally"</span>;</span><br><span class="line">$a= <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">        "hername : " <span class="subst">$name</span></span></span><br><span class="line"><span class="string">        "123"</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line"><span class="keyword">echo</span> $a;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hername : &quot; Sally &quot;123&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>结束需要独立一行且前后不能空格</li>
<li>$name 经过了计算</li>
<li>空格和换行都被处理为一个空格 </li>
</ol>
</blockquote>
<h2 id="PHP-类型"><a href="#PHP-类型" class="headerlink" title="PHP 类型"></a>PHP 类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line">$a = <span class="string">"Hello world"</span>;</span><br><span class="line"><span class="comment">// Integer </span></span><br><span class="line">$b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Float</span></span><br><span class="line">$c = <span class="number">3.0</span>;</span><br><span class="line">$d = (float)$a;</span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line">$e = <span class="string">'3.0'</span>==<span class="number">3</span>; <span class="comment">//$e 的值应该是为true，因为== 是弱比较，不关心等式左右的类型</span></span><br><span class="line">$f = <span class="keyword">true</span>; </span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line">$g = <span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'wang'</span>,<span class="string">'year'</span>=&gt;<span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $color;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($color=<span class="string">"green"</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;color = $color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">what_color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$h = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">// NULL</span></span><br><span class="line">$i = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_</span><span class="params">($obj)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> $obj,<span class="string">'=&gt;'</span>,var_dump($obj),<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">print_($a);</span><br><span class="line">print_($b);</span><br><span class="line">print_($c);</span><br><span class="line">print_($d);</span><br><span class="line">print_($e);</span><br><span class="line">print_($f);</span><br><span class="line">print_($g);</span><br><span class="line">var_dump($h);<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">print_($i);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello world=&gt;string(11) &quot;Hello world&quot;</span><br><span class="line">3=&gt;int(3)</span><br><span class="line">3=&gt;float(3)</span><br><span class="line">0=&gt;float(0)</span><br><span class="line">1=&gt;bool(true)</span><br><span class="line">1=&gt;bool(true)</span><br><span class="line">Array=&gt;array(2) &#123; [&quot;name&quot;]=&gt; string(4) &quot;wang&quot; [&quot;year&quot;]=&gt; int(2000) &#125;</span><br><span class="line">object(Car)#1 (1) &#123; [&quot;color&quot;]=&gt; string(5) &quot;green&quot; &#125;</span><br><span class="line">=&gt;NULL</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bool define ( string $name , mixed $value [, bool $case_insensitive = <span class="keyword">false</span> ] )</span><br><span class="line">$name:常量名</span><br><span class="line">$value:值</span><br><span class="line">$case_insensitive:是否对大小写敏感,<span class="keyword">true</span> 代表不敏感</span><br></pre></td></tr></table></figure>

<p>define(“GREETING”, “欢迎访问 Runoob.com”);<br>echo GREETING;    // 输出 “欢迎访问<br>常量默认是全局变量</p>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//字符串合并</span><br><span class="line">$txt .&quot;+&quot;.$txt2 </span><br><span class="line">//字符串长度</span><br><span class="line">strlen()</span><br><span class="line">//字符串查找，未找到返回False</span><br><span class="line">strpos(&quot;文本&quot;,&quot;查找字符&quot;) // 返回字符串位置，从0开始</span><br></pre></td></tr></table></figure>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age = <span class="number">18</span>;</span><br><span class="line">$stage = <span class="keyword">array</span>(<span class="string">'青少年'</span>,<span class="string">'成年'</span>,<span class="string">'老年'</span>);</span><br><span class="line"><span class="keyword">if</span> ($age &gt;=<span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">	$title = $stage[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ($age &gt;=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line">	$title = $stage[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	$title = $stage[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $title,<span class="string">'&lt;br&gt;&lt;br&gt;'</span>;</span><br><span class="line"></span><br><span class="line">$favcolor=<span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">switch</span> ($favcolor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色是红色!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"blue"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色是蓝色!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色是绿色!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色不是 红, 蓝, 或绿色!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>while/do while/for /foreach</p>
<h3 id="while-do-while"><a href="#while-do-while" class="headerlink" title="while/do while"></a>while/do while</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// while </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"while &lt;br&gt;"</span>;</span><br><span class="line">$x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> ($x) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $x--,<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do .. while </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"do..while &lt;br&gt;"</span>;</span><br><span class="line">$x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">echo</span> $x,<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">while</span> ($x--)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">do..while</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="for-foreach"><a href="#for-foreach" class="headerlink" title="for/ foreach"></a>for/ foreach</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">1</span>; $i&lt;=<span class="number">5</span>; $i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The number is "</span> . $i . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$x=<span class="keyword">array</span>(<span class="string">"one"</span>=&gt;<span class="number">1</span>,<span class="string">"two"</span>=&gt;<span class="number">2</span>,<span class="string">"three"</span>=&gt;<span class="number">3</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($x <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> $key,<span class="string">" : "</span>,$value,<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The number is 1</span><br><span class="line">The number is 2</span><br><span class="line">The number is 3</span><br><span class="line">The number is 4</span><br><span class="line">The number is 5</span><br><span class="line">one : 1</span><br><span class="line">two : 2</span><br><span class="line">three : 3</span><br></pre></td></tr></table></figure>



<h2 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__LINE__: 语句所处的行号</span><br><span class="line">__FILE__: 文件的完整路径（含文件名）</span><br><span class="line">__DIR__: 文件的目录</span><br><span class="line">__FUNCTION__: 函数名</span><br><span class="line">__CLASS__: 类名</span><br><span class="line">__TRAIT__: Trait 名</span><br><span class="line">__METHOD__:类的方法名</span><br><span class="line">__NAMESPACE__:命名空间</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace MyProject;// 必须是在首行</span><br><span class="line">// 魔术常量</span><br><span class="line">echo &apos;这是第 &quot; &apos;  . __LINE__ . &apos; &quot; 行&apos;,&apos;&lt;br&gt;&apos;;</span><br><span class="line">echo &apos;该文件位于 &quot; &apos;  . __FILE__ . &apos; &quot; &apos;,&apos;&lt;br&gt;&apos;;</span><br><span class="line">echo &apos;该文件位于 &quot; &apos;  . __DIR__ . &apos; &quot; &apos;,&apos;&lt;br&gt;&apos;;</span><br><span class="line"></span><br><span class="line">echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line">        function _print() &#123;</span><br><span class="line">                echo &apos;类名为：&apos;  . __CLASS__ . &quot;&lt;br&gt;&quot;;</span><br><span class="line">                echo  &apos;函数名为：&apos; . __FUNCTION__ .&quot;&lt;br&gt;&quot;;</span><br><span class="line">                echo  &apos;类的方法名：&apos; . __METHOD__ ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">$t = new test();</span><br><span class="line">$t-&gt;_print();</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是第 &quot; 4 &quot; 行</span><br><span class="line">该文件位于 &quot; /Library/WebServer/Documents/a.php &quot;</span><br><span class="line">该文件位于 &quot; /Library/WebServer/Documents &quot;</span><br><span class="line">命名空间为：&quot;MyProject&quot;类名为：MyProject\test</span><br><span class="line">函数名为：_print</span><br><span class="line">类的方法名：MyProject\test::_print</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：PHP中的命名空间，可以解决的问题：</p>
</blockquote>
<ol>
<li>用户编写的代码与PHP内部的类/函数/常量名字冲突</li>
<li>为很长的标识符创建一个更加可读的别名</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><ol>
<li>自动分配id</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cars = <span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="keyword">array</span>( <span class="string">'a'</span>,<span class="number">3</span> =&gt; <span class="string">'b'</span>,<span class="number">1</span> =&gt; <span class="string">'c'</span>, <span class="string">'d'</span>);</span><br><span class="line">var_dump($a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//array(4) &#123; [0]=&gt; string(1) "a" [3]=&gt; string(1) "b" [1]=&gt; string(1) "c" [4]=&gt; string(1) "d" &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关联数组</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$age = <span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>遍历数组</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age = <span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($age <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $key,<span class="string">'  =&gt; '</span>,$value,<span class="string">'  type: '</span>,var_dump($key),<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数组排序</li>
</ol>
<p>sort() &lt;–&gt; rsort()<br>asort() &lt;–&gt; arsort() //关联数组<br>ksort() &lt;–&gt; krsort() //关联数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age=<span class="keyword">array</span>(<span class="string">"a"</span>=&gt;<span class="string">"5"</span>,<span class="string">"c"</span>=&gt;<span class="string">"37"</span>,<span class="string">"b"</span>=&gt;<span class="string">"-1"</span>,<span class="string">"e"</span>=&gt;<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原始数组:"</span>;</span><br><span class="line">print_r($age);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"按key 排序"</span>;</span><br><span class="line">ksort($age);</span><br><span class="line">print_r($age);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"按value 排序"</span>;</span><br><span class="line">asort($age);</span><br><span class="line">print_r($age);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="PHP-面向对象"><a href="#PHP-面向对象" class="headerlink" title="PHP 面向对象"></a>PHP 面向对象</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> $url;</span><br><span class="line">  <span class="keyword">var</span> $title;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($par1,$par2)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">$this</span>-&gt;url = $par1;</span><br><span class="line">  	<span class="keyword">$this</span>-&gt;title = $par2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>.<span class="string">"  已经运行"</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">     <span class="keyword">$this</span>-&gt;url = $par;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">     <span class="keyword">$this</span>-&gt;title = $par;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$siteobj = <span class="keyword">new</span> Site(<span class="string">'www.baidu.com'</span>,<span class="string">'baidu'</span>);</span><br><span class="line"><span class="keyword">print</span> $siteobj-&gt;url;</span><br><span class="line">$siteobj-&gt;setUrl(<span class="string">'ppsteven.github.io'</span>);</span><br><span class="line">$siteobj-&gt;setTitle(<span class="string">'learnPHP'</span>);</span><br><span class="line">$siteobj-&gt;getUrl();</span><br><span class="line">$siteobj-&gt;getTitle();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$y = <span class="string">"globals varibale"</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">($z=null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">global</span> $y; <span class="comment">// $y 为全局变量，有两种方式使用</span></span><br><span class="line">	<span class="keyword">echo</span> $y,<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">	<span class="keyword">echo</span> $GLOBALS[<span class="string">'y'</span>],<span class="string">'&lt;br&gt;'</span>; </span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'参数作用域'</span>,$z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> $x1=<span class="number">0</span>;</span><br><span class="line">    $x2 = <span class="number">0</span>; <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $x1.<span class="string">'('</span>.$x2.<span class="string">"）"</span>;<span class="comment">// 静态变量是不会随着函数完成而删除</span></span><br><span class="line">    $x1++;</span><br><span class="line">    $x2++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x2(x1)</span></span><br><span class="line"><span class="comment">0(0)</span></span><br><span class="line"><span class="comment">0(1)</span></span><br><span class="line"><span class="comment">0(2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>包含一些小的知识点和未系统整理的知识</p>
<ul>
<li><p>三元：expr1 ? expr2 : expr3</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> $var = <span class="keyword">true</span> ? <span class="number">1</span> : <span class="keyword">false</span> ? <span class="number">2</span> : <span class="number">3</span>;</span><br><span class="line"> $varx = (<span class="keyword">true</span> ? <span class="number">1</span> : <span class="keyword">false</span>)? <span class="number">2</span> : <span class="number">3</span>;</span><br><span class="line"> $vary = <span class="keyword">true</span> ? <span class="number">1</span> : (<span class="keyword">false</span> ? <span class="number">2</span> : <span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> $var.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> $varx.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> $vary.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="comment">// 结果是 2 2 1 , 这里的三元运算需要注意执行的顺序</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>null == false  : 返回的是false</p>
</li>
<li><p>1/2 (0.5) PHP中没有整除算法，有整除函数intdiv(1/2)</p>
</li>
<li><p>php 作用域</p>
<ul>
<li>local</li>
<li>global</li>
<li>static</li>
<li>parameter // 参数作用域</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> $x;</span><br><span class="line">    $x++;</span><br><span class="line">    <span class="keyword">echo</span> PHP_EOL;    <span class="comment">// 换行符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 static 使得$x 的值会一直累加</span></span><br><span class="line">myTest(); <span class="comment">// 0 </span></span><br><span class="line">myTest(); <span class="comment">// 1</span></span><br><span class="line">myTest(); <span class="comment">// 2</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>echo PHP_EOL; // 换行符</p>
</li>
<li><p>==   弱比较<br>=== 强比较</p>
</li>
</ul>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>日常学习笔记</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>git cheetsheet</title>
    <url>/2019/11/14/git%20cheetsheet/</url>
    <content><![CDATA[<h2 id="cheetsheet"><a href="#cheetsheet" class="headerlink" title="cheetsheet"></a>cheetsheet</h2><p>入门级别的git 基础操作，仅仅收录理解了的，常用的命令。负责的命令，在附录的大全里面可以找到</p>
<p> <img alt="img" data-src="http://kmknkk.oss-cn-beijing.aliyuncs.com/image/git.jpg" class="lozad"> </p>
<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>Git 有三层的配置文件</p>
<ol>
<li>仓库级的配置文件：在仓库的 <code>.git/config</code> 目录下，只对本仓库有效</li>
<li>全局级的配置文件：Mac在 <code>~/.gitconfig</code> 目录</li>
<li>系统级的配置文件：在Git 的 安装目录下 (经过查找，我的目录为/usr/local/Cellar/git/2.23.0_1/.bottle/etc)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --local: 仓库级 , --glocal: 全局级 , --system: 系统级</span></span><br><span class="line"><span class="comment"># 添加配置</span></span><br><span class="line">$ git config --global user.name <span class="string">"Name"</span> <span class="comment"># 添加用户名 --global 代表配置的全局的参数</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span> <span class="comment"># 添加邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">$ git config --list/ -l <span class="comment"># 查看全部git配置</span></span><br><span class="line">$ git config --get user.name/user.email <span class="comment"># 查看单个配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置</span></span><br><span class="line">$ git config --<span class="built_in">unset</span> user.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置</span></span><br><span class="line">$ git config -e --global</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加别名，对于一些比较长的别名，可以简化</span></span><br><span class="line"><span class="comment"># 也可以通过git config </span></span><br><span class="line">$ git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">$ git config --global alias.graph <span class="string">"log --graph --oneline"</span></span><br></pre></td></tr></table></figure>
<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init  <span class="comment"># 创建空的git代码库</span></span><br><span class="line">$ git init Myfolder <span class="comment"># 创建文件夹Myfolder，并创建git代码库</span></span><br></pre></td></tr></table></figure>
<h3 id="文件（增删改提）"><a href="#文件（增删改提）" class="headerlink" title="文件（增删改提）"></a>文件（增删改提）</h3><h4 id="git-add-增"><a href="#git-add-增" class="headerlink" title="git add 增"></a>git add 增</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line">$ git add .  <span class="comment"># 当前目录（递归子目录）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="git-commit-提交"><a href="#git-commit-提交" class="headerlink" title="git commit 提交"></a>git commit 提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend -m <span class="string">"desc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿372a* 提交的信息（作者、提交者、注释、时间戳等）来提交当前修改</span></span><br><span class="line">$ git commit -c 372a</span><br></pre></td></tr></table></figure>

<h4 id="git-reset-还原"><a href="#git-reset-还原" class="headerlink" title="git reset 还原"></a>git reset 还原</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line"><span class="comment"># 丢弃暂存区中的所有文件的修改（工作区不受影响）</span></span><br><span class="line">$ git reset </span><br><span class="line">$ git reset --mixed </span><br><span class="line"></span><br><span class="line">$ git reset &lt;文件路径,commit ID&gt;</span><br><span class="line">$ git reset --mixed  &lt;文件路径,commit ID&gt;</span><br><span class="line"></span><br><span class="line">$ git reset --hard HEAD^ <span class="comment"># 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD~100: 往上100个版本）</span></span><br><span class="line">$ git reset --hard 1234567 <span class="comment"># 回到指定版本号commit id（此处：commit id 假设为1234567******，Git会根据commit id的前几位自动寻找对应的版本）</span></span><br><span class="line">$ git reset --soft HEAD~ <span class="comment"># hard 和 soft 的区别在与 soft（暂存区和工作区中的所有文件的修改都不丢弃）</span></span><br><span class="line">$ git reset --merge  &lt;commit&gt;  // 在被污染的工作区中回滚merge或者</span><br><span class="line"></span><br><span class="line">$ git reflog <span class="comment"># 查看命令历史</span></span><br></pre></td></tr></table></figure>





<h4 id="git-revert-反做"><a href="#git-revert-反做" class="headerlink" title="git revert 反做"></a>git revert 反做</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>
<p>比较一下 git revert 和 git reset 的区别：</p>
<p>git reset是把HEAD向后移动来删除提交，而git revert是用一次新的提交来回滚之前的提交（HEAD会继续前进）。下面一幅图比较形象生动。</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191115001540.png" class="lozad"></p>
<p>关于git 的版本回退的问题，<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">廖雪峰的博客：时光穿梭机</a>已经讲的很好了，我们可以通过<code>git log</code> 查看“当前”版本库的状态，但是如何查看“未来”的版本库呢？可以通过<code>git reflog</code> 查看。</p>
<h4 id="git-remove-删除"><a href="#git-remove-删除" class="headerlink" title="git remove 删除"></a>git remove 删除</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;文件路径&gt; <span class="comment"># 删除工作区文件，若文件在工作区或缓存区中有修改，会失败。有两种解决方式：1、强制删除  2、只删除暂存区的文件</span></span><br><span class="line">$ git rm -f &lt;文件路径&gt; <span class="comment"># 1.无论有没有在工作区或暂存区修改，强制删除</span></span><br><span class="line">$ git rm --cached &lt;文件路径&gt; <span class="comment"># 2.移除暂存区的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git rm -r &lt;文件夹路径&gt; <span class="comment"># 移除文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br><span class="line"><span class="comment"># 可以使用 Beyond Compare4 软件</span></span><br></pre></td></tr></table></figure>



<h4 id="git-checkout-恢复"><a href="#git-checkout-恢复" class="headerlink" title="* git checkout  恢复"></a>* git checkout  恢复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当在暂存区中有修改时，使用暂存区中的修改覆盖工作区中的 &lt;文件路径&gt;</span></span><br><span class="line"><span class="comment"># 当不在暂存区中时，使用本地版本库中的HEAD指针处的修改覆盖工作区中的&lt;文件路径&gt;</span></span><br><span class="line">$ git checkout -- &lt;文件路径&gt;</span><br><span class="line"><span class="comment"># 用本地版本库中 HEAD处提交的文件，覆盖 暂存区和工作区的文件</span></span><br><span class="line">$ git checkout HEAD &lt;文件路径&gt;</span><br><span class="line"><span class="comment"># 用本地版本库中 93ef处提交的文件，覆盖 暂存区和工作区的文件</span></span><br><span class="line">$ git checkout 93ef &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>恢复文件举例</p>
<p>a 文件被修改过，checkout  去除修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat a </span><br><span class="line">Hello world</span><br><span class="line">orphan`</span><br><span class="line">$ git checkout a</span><br><span class="line">Updated 1 path from the index</span><br><span class="line">$ cat a</span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">add a line</span><br></pre></td></tr></table></figure>



<h3 id="git-日志与文件状态"><a href="#git-日志与文件状态" class="headerlink" title="git 日志与文件状态"></a>git 日志与文件状态</h3><h4 id="git-status-状态"><a href="#git-status-状态" class="headerlink" title="git status 状态"></a>git status 状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前所处的分支暂存区和工作区的文件（会显示当前所处分支）</span></span><br><span class="line"><span class="comment"># 注1：处于暂存区的文件状态:：staged(已暂存)；处于工作区的文件状态:：untrack(未跟踪)、modified(已修改)</span></span><br><span class="line"><span class="comment"># 注2：工作区中的空目录不会被git追踪</span></span><br><span class="line">$ git status</span><br><span class="line">$ git status &lt;branch name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以简短模式查看暂存区和工作区的文件</span></span><br><span class="line"><span class="comment"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line">$ git status -s</span><br></pre></td></tr></table></figure>

<h4 id="git-log-日志"><a href="#git-log-日志" class="headerlink" title="git log 日志"></a>git log 日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line">$ git <span class="built_in">log</span> -- &lt;文件&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级功能</span></span><br><span class="line"><span class="comment"># 记不住可以设置别名</span></span><br><span class="line">$ git <span class="built_in">log</span> -p &lt;文件&gt; <span class="comment"># 显示出每次修改的内容</span></span><br><span class="line">$ --graph  <span class="comment"># 图形化的方式显示</span></span><br><span class="line">$ --graph --oneline <span class="comment"># 图形化简洁模式</span></span><br><span class="line">$ --graph --oneline --name-only <span class="comment"># 图像化简洁模式（只显示文件名清单）</span></span><br><span class="line">$ --author = leon <span class="comment"># 限定作者leon</span></span><br><span class="line">$ --grep = <span class="string">"test"</span> <span class="comment"># 限定注释</span></span><br><span class="line">$ --since=<span class="string">"2018-10-7"</span> --until=<span class="string">'2019-10-12'</span></span><br><span class="line"><span class="comment"># since,until 标记对和 after，before 标记对是等价的</span></span><br><span class="line">$ --after=<span class="string">"2018-10-7"</span> --before=<span class="string">'2018-10-12'</span></span><br><span class="line">$ --since=2.weeks <span class="comment"># 最近2周的提交记录</span></span><br></pre></td></tr></table></figure>

<h4 id="git-show-显示修改"><a href="#git-show-显示修改" class="headerlink" title="git show 显示修改"></a>git show 显示修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计各个提交者的次数</span></span><br><span class="line">$ git shortlog -sn </span><br><span class="line"><span class="comment"># 显示修改内容(详细)</span></span><br><span class="line">$ git show 3a6c</span><br><span class="line">$ git show HEAD</span><br><span class="line"><span class="comment"># 显示最近一次提交的修改内容（不显示具体的修改内容）</span></span><br><span class="line">$ git show --name-only HEAD</span><br></pre></td></tr></table></figure>

<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line">$ git branch -r <span class="comment"># 列出所有远程分支 cache</span></span><br><span class="line">$ git branch -a <span class="comment"># 列出所有本地分支和远程分支cache</span></span><br><span class="line">$ git branch -av <span class="comment"># 列出所有本地分支和远程分支cache（含简单说明）</span></span><br><span class="line">$ git branch -vv <span class="comment"># 查看本地分支和远程分支cache的追踪关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line"><span class="comment"># 删除的时候需要从被删除的分区切换出去</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream hexo origin:hexo ??</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在本地新建了分支，远程没有分支的情况</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream origin master <span class="comment"># 建立联系</span></span><br><span class="line">$ git branch -vv <span class="comment"># 查看本地和远程的追踪关系</span></span><br></pre></td></tr></table></figure>

<h4 id="git-checkout-分支切换"><a href="#git-checkout-分支切换" class="headerlink" title="git checkout 分支切换"></a>git checkout 分支切换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git 提交流程 工作区-&gt; 暂存区 -&gt; 版本库</span></span><br><span class="line">$ git checkout &lt;分支名称&gt; <span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout -- &lt;file&gt; <span class="comment"># 撤销修改：1. 文件在添加到缓存区前修改，则回退到原工作区状态；2. 文件在添加到缓存区后修改，则回退到原缓存区状态。也即是将&lt;file&gt;撤回到最近一次git add或git commit状态（注：--表示在当前分支，如果没有，则切换到另一个分支）</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt; <span class="comment"># 创建并切换</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;<span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout -<span class="comment"># 切换到上一次分支</span></span><br></pre></td></tr></table></figure>

<h4 id="git-merge-rebase-分支合并"><a href="#git-merge-rebase-分支合并" class="headerlink" title="git merge/rebase 分支合并"></a>git merge/rebase 分支合并</h4><h4 id><a href="#" class="headerlink" title></a><img alt="img" data-src="https://images2018.cnblogs.com/blog/78946/201809/78946-20180910200246573-415665647.png" class="lozad"></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下</span></span><br><span class="line">$ git merge &lt;分支名称&gt; <span class="comment"># 无冲突时会直接提交</span></span><br><span class="line">$ git merge --no-commit &lt;分支名称&gt; <span class="comment"># 不自动提交</span></span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> &lt;name&gt; <span class="comment"># 合并后的分支有历史记录，而Fast-Forward合并之后，分支没有历史记录</span></span><br><span class="line"><span class="comment"># Fast-Forwar 的合并的方法是指针的移动。</span></span><br><span class="line"></span><br><span class="line">$ git rebase &lt;分支名称&gt; <span class="comment"># rebase 能保持清晰的提交记录，但是合并的操作没有记录下来（merge 则是会新建一个提交）</span></span><br></pre></td></tr></table></figure>



<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><h4 id="git-clone-克隆"><a href="#git-clone-克隆" class="headerlink" title="git clone 克隆"></a>git clone 克隆</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆文件</span></span><br><span class="line"><span class="comment"># Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快，https 每次推送都必须输入口令。</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/XXX/learngit.git Yourfilepath <span class="comment"># https</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:XXX/learngit.git ./lesson01 <span class="comment"># ssh（推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b &lt;分支名称&gt; &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -o 设置远程仓库为origin</span></span><br><span class="line">$ git <span class="built_in">clone</span> -o &lt;orgin name&gt; https://github.com/kekec/Test.git</span><br></pre></td></tr></table></figure>

<h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line">origin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line">origin https://github.com/kekec/Test.git (fetch)</span><br><span class="line">origin https://github.com/kekec/Test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove/rm &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/显示远程仓库的 URL 地址</span></span><br><span class="line">$ git remote <span class="built_in">set</span>-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br><span class="line">$ git remoter get-url &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示远程仓库的信息（举例）</span></span><br><span class="line">$ git remote show origin </span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/kekec/Test.git</span><br><span class="line">  Push URL: https://github.com/kekec/Test.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master tracked</span><br><span class="line">    v3.1 tracked</span><br><span class="line">Local branch configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">Local refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span><br><span class="line">    master pushes to master (fast-forwardable)</span><br><span class="line">    v3.1 pushes to v3.1 (up to date)</span><br><span class="line"><span class="comment"># 可以查看 git pull 和 git push 的具体信息</span></span><br></pre></td></tr></table></figure>

<h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p> 从远程仓库获取最新的版本到本地分支上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch orgin master/dev</span><br></pre></td></tr></table></figure>

<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="* git pull"></a>* git pull</h4><blockquote>
<p>git pull  &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; </p>
</blockquote>
<p> 从远程仓库获取最新版本并合并到本地。<br>首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先执行fetch，然后将远程origin/master分支merge合并到当前分支（最后会更新origin/master, origin/HEAD指针到最新提交）</span></span><br><span class="line">$ git pull origin master</span><br><span class="line">$ git pull -r origin master <span class="comment"># 先执行fetch，然后将远程origin/master分支rebase合并到master分支</span></span><br><span class="line">$ git pull origin master:dev <span class="comment"># 先执行fetch，然后将远程origin/master 分支merge合并到本地dev分支</span></span><br></pre></td></tr></table></figure>

<h4 id="git-push"><a href="#git-push" class="headerlink" title="* git push"></a>* git push</h4><p> 把本地仓库的提交推送到远程仓库。</p>
<blockquote>
<p>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地仓库的修改push到origin所指向的远程仓库URL的master分支上，并在.git/config文件中记录当前分支与远程分支master的对应关系</span></span><br><span class="line">$ git push -u origin master <span class="comment"># -u 在第一次push的时候使用即可</span></span><br><span class="line">$ git push origin -f <span class="comment"># 当合入对应的远端仓库有冲突的时候，使用当前分支更新</span></span><br><span class="line">$ git push origin --all <span class="comment"># 推送本地的所有的分支到各自的远端分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete/-d &lt;远程分支名&gt;</span><br><span class="line">$ git push origin:dev <span class="comment"># 删除远端分支 dev</span></span><br><span class="line">$ git push origin -d dev <span class="comment"># 效果同上</span></span><br></pre></td></tr></table></figure>



<h3 id="存储文件的区块"><a href="#存储文件的区块" class="headerlink" title="存储文件的区块"></a>存储文件的区块</h3><h4 id="贮藏区-git-stash"><a href="#贮藏区-git-stash" class="headerlink" title="贮藏区 git  stash"></a>贮藏区 git  stash</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash <span class="comment"># 将工作区中所有文件的修改备份压栈到储藏区，然后丢弃工作区与暂存区的所有文件的修改。</span></span><br><span class="line"><span class="comment"># 经过试验，git stash 会丢弃已有文件的修改的，不会删除新建的文件。</span></span><br><span class="line">$ git stash pop <span class="comment"># 恢复工作区，并将贮藏区的备份删除</span></span><br><span class="line">$ git stash list <span class="comment"># 查看贮藏区</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: 30e5191 add a</span><br><span class="line">$ git stash show -p stash@&#123;0&#125; <span class="comment"># 查看栈顶文件的修改</span></span><br><span class="line">diff --git a/a b/a</span><br><span class="line">index 11817a2..399e9b0 100644</span><br><span class="line">--- a/a</span><br><span class="line">+++ b/a</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> Hello world</span><br><span class="line"></span><br><span class="line"> add a line</span><br><span class="line">+add a line</span><br><span class="line">$ git stash drop <span class="comment"># 直接移除储藏区的栈顶处备份（不用于恢复当前分支的工作区）</span></span><br><span class="line">$ git stash clear <span class="comment"># 清除储藏区栈列表</span></span><br><span class="line">$ git stash apply stash@&#123;0&#125; <span class="comment"># 使用stash@&#123;0&#125;来恢复当前分支的工作区，但不移除储藏区中任何备份</span></span><br></pre></td></tr></table></figure>

<h4 id="工作区-git-clean"><a href="#工作区-git-clean" class="headerlink" title="工作区 git clean"></a>工作区 git clean</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git clean -nd  <span class="comment"># 探测工作区中有哪些未追踪状态的文件和目录</span></span><br><span class="line">$ git clean -fd  <span class="comment"># 删除工作区中未追踪状态的文件和目录</span></span><br></pre></td></tr></table></figure>

<h4 id="暂存区-git-ls-files"><a href="#暂存区-git-ls-files" class="headerlink" title="暂存区 git ls-files"></a>暂存区 git ls-files</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git ls-files <span class="comment"># 查询暂存区中的文件列表（递归子目录）</span></span><br><span class="line"><span class="comment"># 下面是抄的</span></span><br><span class="line">$ git ls-files -s  // 查看暂存区中所有文件的blob数据块信息</span><br><span class="line">$ git ls-files -s -- README.md  // 查看暂存区中的README.md文件的blob数据块信息</span><br></pre></td></tr></table></figure>

<h3 id="打包-git-archive"><a href="#打包-git-archive" class="headerlink" title="打包 git archive"></a>打包 git archive</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前master分支所有文件使用zip压缩方式打包到d:/file.zip</span></span><br><span class="line">$ git archive --format zip --output ./file.zip master</span><br></pre></td></tr></table></figure>

<p>团队合作分支</p>
<p><img alt data-src="https://www.liaoxuefeng.com/files/attachments/919023260793600/0" class="lozad"></p>
<h2 id="TO-DO-LIST"><a href="#TO-DO-LIST" class="headerlink" title="TO DO LIST"></a>TO DO LIST</h2><ul>
<li><input disabled type="checkbox"> 看完教程<a href="http://www.findme.wang/share/detail/id/327.html#sub6" target="_blank" rel="noopener">git 教程</a> 补充</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></li>
<li><a href="https://www.cnblogs.com/kekec/p/9248487.html" target="_blank" rel="noopener">Git原理与命令大全</a></li>
<li><a href="https://www.jianshu.com/p/93318220cdce" target="_blank" rel="noopener">Git命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>日常学习笔记</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Pine Script 学习笔记(二)——基本特点</title>
    <url>/2019/11/04/Pine%20Script%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="Context-switching-and-the-security-function"><a href="#Context-switching-and-the-security-function" class="headerlink" title="Context switching and the security function"></a>Context switching and the security function</h2><p>security 函数可以用于按照特定要求请求数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;Example security 1&quot;, overlay=true)</span><br><span class="line">ibm_15 = security(&quot;NYSE:IBM&quot;, &quot;15&quot;, close)</span><br><span class="line">plot(ibm_15)</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://www.tradingview.com/pine-script-docs/en/v4/_images/Chart_security_1.png" class="lozad"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security(symbol, resolution, expression, gaps, lookahead)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>symbol (string)</strong> 商品代码。</p>
<p>商品代码可以包含数据提供商信息，也可以不含</p>
<p>如 “NYSE:IBM”,”BATS:IBM”,”IBM”(如不提供，默认使用BATS)</p>
<p> <a href="https://www.tradingview.com/pine-script-reference/v4/#var_syminfo{dot}ticker" target="_blank" rel="noopener">syminfo.ticker</a> and <a href="https://www.tradingview.com/pine-script-reference/v4/#var_syminfo{dot}tickerid" target="_blank" rel="noopener">syminfo.tickerid</a>是表示当前图标上的商品代码，syminfo.ticker是不含数据供应商信息，syminfo.tickerid是包含供应商信息。Pine教程建议使用后者，为了避免数据的模糊性</p>
</li>
<li><p><strong>resolution (string)</strong> 分辨率/ <strong>timeframe</strong>时间周期</p>
<ul>
<li>分钟级：1，5，10，21，60，120，等等</li>
<li>日级: D,1D,2D 等等</li>
<li>周级：W，1W，2W</li>
<li>月级：M，1M，2M</li>
<li>timeframe.period 记录当前图标时间周期</li>
</ul>
</li>
<li><p><strong>expression (series)</strong> 计数并从 <a href="https://cn.tradingview.com/pine-script-reference/v3/#fun_security" target="_blank" rel="noopener">security</a>调用返回的表达式。</p>
<p>如果仅仅是获取收盘价数据，我们可以用<code>security(&#39;EURUSD&#39;,&#39;D&#39;,close)</code></p>
<p>但是，expression能给我们提供更加丰富的操作，比如，我们需要知道，EURUSD相对于GBPUSD 上涨的幅度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(title = &quot;Advance Decline Ratio&quot;, shorttitle=&quot;ADR&quot;)</span><br><span class="line">ratio(t1, t2, source) =&gt;</span><br><span class="line">    s1 = security(t1, timeframe.period, source)</span><br><span class="line">    s2 = security(t2, timeframe.period, source)</span><br><span class="line">    s1 / s2</span><br><span class="line">plot(ratio(&quot;GBPUSD&quot;, &quot;EURUSD&quot;, close-open))</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102123145.png" class="lozad"></p>
<p>如上图所以，GBPUSD上涨幅度/EURUSD 的上涨幅度我们可以很轻松的通过7行代码实现。在绝大多数情况下，两者是同比例变动，但是在某些特等情况下，变化是相反的。这对于研究这两种货币对的走势关系有很大的帮助。</p>
</li>
</ul>
<p>在security数据应用到当前图表上的时候，有两个控制，一个是gaps，另一个是lookahead</p>
<ul>
<li><p><strong>gaps (const bool)</strong> 默认值为<a href="https://cn.tradingview.com/pine-script-reference/v3/#var_barmerge{dot}gaps_off" target="_blank" rel="noopener">barmerge.gaps_off</a>。可以理解为数据平滑的操作，因为数据中会存在空值（na），在gaps_off的情况下，na会被离它最近的非空值所替代，也就不会出现间隔（gap）的情况</p>
</li>
<li><p><strong>lookahead (const bool)</strong> 默认值为<a href="https://cn.tradingview.com/pine-script-reference/v3/#var_barmerge{dot}lookahead_off" target="_blank" rel="noopener">barmerge.lookahead_off</a>。</p>
<p>合并所请求数据位置的策略。 请求的条形图与当前的条形图按照k线开盘时间合并。 这种合并策略可能导致从“未来”获取数据计算历史的不良影响。 这在回溯测试策略中不被接受，但在指标中可使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&apos;My Script&apos;, overlay=true)</span><br><span class="line">a = security(syminfo.tickerid, &apos;60&apos;, low, lookahead=barmerge.lookahead_off)</span><br><span class="line">plot(a, color=color.red)</span><br><span class="line">b = security(syminfo.tickerid, &apos;60&apos;, low, lookahead=barmerge.lookahead_on)</span><br><span class="line">plot(b, color=color.lime)</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102163742.png" class="lozad"></p>
<p>红色是lookahead_off，绿色是lookahead_on。 我们发现开启了lookahead功能后，所产生的最低价是整个时间段的最低价，而原先是开盘K点的最低价。</p>
</li>
</ul>
<h2 id="bar-state-变量"><a href="#bar-state-变量" class="headerlink" title="bar state.* 变量"></a>bar state.* 变量</h2><ul>
<li><p>barstate.isfirst  当前k线为k线组的第一条k线</p>
</li>
<li><p>barstate.islast  当前k线为k线组的最后一条k线</p>
</li>
<li><p>barstate.ishistory  当前k线为历史k线</p>
</li>
<li><p>batstate.isrealtime 当前k线为实时k线</p>
</li>
<li><p>barstate.isnew 新K线的第一次更新</p>
</li>
<li><p>batstate.isconfirmed =当前k线的最后(关闭)更新 </p>
<blockquote>
<p>不建议在<a href="https://cn.tradingview.com/pine-script-reference/v3/#fun_security" target="_blank" rel="noopener">security</a>表达式中使用<a href="https://cn.tradingview.com/pine-script-reference/v3/#var_barstate{dot}isconfirmed" target="_blank" rel="noopener">barstate.isconfirmed</a></p>
</blockquote>
</li>
</ul>
<p>所有的历史柱线都曾被认为是新的柱线，因为脚本是依次执行的。当柱线第一更开盘价生成的时候，认为此柱线是新的。</p>
<h2 id="会话和时间信息"><a href="#会话和时间信息" class="headerlink" title="会话和时间信息"></a>会话和时间信息</h2><p>Pine 提供方法来生成 交易区间，时间和日期的信息。</p>
<p>time(变量): 返回的是时间戳格式</p>
<p>time(函数)：time(resolution, session) → series 返回的是按照session 格式返回的时间，如果不在session时间段的话便会返回na值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;Time&quot;, overlay=true)</span><br><span class="line">t1 = time(timeframe.period, &quot;0000-0000&quot;)</span><br><span class="line">bgcolor(t1 ? color.blue : na)</span><br></pre></td></tr></table></figure>

<p>session = “0000-0000:23456” 即24h，去除周六日，运行结果如下</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102203555.png" class="lozad"></p>
<p>可以看到，周一至周五背景都变成了蓝色，因为t1 不在session的范围内的时候返回na值</p>
<p>交易区间的格式有</p>
<ul>
<li><p>0000-0000:1234567 24小时交易，时间从午夜0点开始</p>
</li>
<li><p>0000-0000:23456 工作日24小时交易</p>
</li>
<li><p>1700-1700：24小时交易，时间从17点开始</p>
</li>
<li><p>0930-1700:146  交易时间为09:30~17:00，交易时间在周日（1），周三（4），周五（6）</p>
</li>
<li><p>24x7 等价于 0000-0000:1234567</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断是否为30min的新柱线</span><br><span class="line">//@version=4</span><br><span class="line">study(&quot;new 30 min bar&quot;)</span><br><span class="line">is_newbar(res) =&gt;</span><br><span class="line">    t = time(res)</span><br><span class="line">    not na(t) and (na(t[1]) or t &gt; t[1])</span><br><span class="line">plot(is_newbar(&quot;30&quot;) ? 1 : 0)</span><br></pre></td></tr></table></figure>

<p>用到的函数变量和类型</p>
<ul>
<li>time：UNIX格式的当前k线时间</li>
<li>timenow：UNIX格式的当前时间</li>
<li>syminfo.timezone：时区</li>
</ul>
<p>当前K线用到的变量</p>
<ul>
<li>year/month/weekofyear</li>
<li>dayofmonth</li>
<li>dayofweek（sunday,monday 等）</li>
<li>hour/minute/second</li>
</ul>
<p>创建时间</p>
<ul>
<li><a href="https://www.tradingview.com/pine-script-reference/v4/#fun_timestamp" target="_blank" rel="noopener">timestamp(year, month, day, hour, minute)</a> </li>
</ul>
<h2 id="策略编写"><a href="#策略编写" class="headerlink" title="策略编写"></a>策略编写</h2><h3 id="backtesting-amp-forwardtesting"><a href="#backtesting-amp-forwardtesting" class="headerlink" title="backtesting &amp; forwardtesting"></a>backtesting &amp; forwardtesting</h3><p>strategy脚本是可以产生交易订单的Pine 脚本。利用strategy 可以做策略回测（backtesting）和 模拟交易（forwardtesting）</p>
<p>无论backtesting 还是forwardtesting，计算都是<strong><u>默认</u></strong>发生在K线收盘的时候，但是在forwardtesting 的时候，可以选择在每一个tick发生的时候，都运行一次。</p>
<p>做法一是调整strategy的 Setting/Properties，或者修改代码，添加<code>strategy(... ,calc_on_every_tick=true )</code> ，此外还可以选择在每笔订单完成之后计算<code>strategy(... , calc_on_order_fills=true)</code></p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102215042.png" class="lozad"></p>
<h3 id="经纪商模拟"><a href="#经纪商模拟" class="headerlink" title="经纪商模拟"></a>经纪商模拟</h3><p>仅仅只有OHLC数据的话，K线内数据的生成有一套逻辑，如果最高价更接近开盘价，生成顺序是 open-&gt;high-&gt;low-&gt;close，此外还假设价格是没有gaps的</p>
<h3 id="订单生成命令"><a href="#订单生成命令" class="headerlink" title="订单生成命令"></a>订单生成命令</h3><h4 id="strategy-entry-订单生成函数"><a href="#strategy-entry-订单生成函数" class="headerlink" title="strategy.entry 订单生成函数"></a>strategy.entry 订单生成函数</h4><p>这是进入市场的命令。 如果具有相同ID的订单已经挂起，则可修改订单。 如果没有指定ID的订单，则会发出新的订单。 </p>
<p>要取消/停用预挂单，应使用命令<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}cancel" target="_blank" rel="noopener">strategy.cancel</a>或<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}cancel_all" target="_blank" rel="noopener">strategy.cancel_all</a>。 </p>
<p>与函数<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}order" target="_blank" rel="noopener">strategy.order</a>相比，<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}entry" target="_blank" rel="noopener">strategy.entry</a>功能受金字塔影响，可以正确反转市场位置。 如果“Limit”和“stop”参数均为“NaN”，则订单类型为市场订单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strategy.entry(id, long, qty, limit, stop, oca_name, oca_type, comment, when) → void</span><br></pre></td></tr></table></figure>

<h4 id="strategy-exit-订单退出函数"><a href="#strategy-exit-订单退出函数" class="headerlink" title="strategy.exit 订单退出函数"></a>strategy.exit 订单退出函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, when) → void</span><br></pre></td></tr></table></figure>

<p>这是一个退出指定进场或整个市场地位的命令，重点区分它和strategy.close 的不同</p>
<ul>
<li>id(string): 订单的标识符。</li>
<li>from_entry(string): 这里填入要平仓的订单的标识符，默认为空。</li>
<li>qty: 平仓手数(弄清楚合约的大小)</li>
<li>qty_percent: 平台的比例</li>
<li>profit: 获利点数(一定搞清楚单位是点还是步)</li>
<li>limit: 与profit 相似，limit约定获利的价格</li>
<li>loss:止损点数</li>
<li>stop:与loss 相似，stop约定止损的价格</li>
<li>tail.*: 指明跟踪指数</li>
</ul>
<h4 id="strategy-order"><a href="#strategy-order" class="headerlink" title="strategy.order"></a>strategy.order</h4><p>这条命令可以生成开仓也可以生成平仓命令，但是它不受金字塔影响。它的作用就是弥补strategy.entry 和 strategy.exit 函数的不灵活星。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是几个例子，可以帮助我们理解strategy函数</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">strategy(&quot;revers demo&quot;)</span><br><span class="line">if bar_index &gt; 4000</span><br><span class="line">    strategy.entry(&quot;buy&quot;, strategy.long, 4, when=strategy.position_size &lt;= 0)</span><br><span class="line">    strategy.entry(&quot;sell&quot;, strategy.short, 6, when=strategy.position_size &gt; 0)</span><br><span class="line">plot(strategy.equity)</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191103235510.png" class="lozad"></p>
<p>当仓位为空头或者无头寸的话，买4。当仓位为多头的话，卖6。</p>
<p>我们可以看到entry中buy 或sell 在交易的时候，会自动平仓，平掉反向的仓位。仓位在+4 –&gt; -6 变化。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">strategy(&quot;Partial exit demo&quot;)</span><br><span class="line">if bar_index &gt; 6500 and bar_index &lt;6550</span><br><span class="line">    strategy.entry(&quot;buy&quot;, strategy.long, 40000, when=strategy.position_size &lt;= 0)</span><br><span class="line">strategy.exit(&quot;bracket1&quot;, &quot;buy&quot;,  20000, profit = 3000,loss = 3000)</span><br><span class="line">strategy.exit(&quot;bracket2&quot;, &quot;buy&quot;,  profit=2000, loss=2000)</span><br><span class="line">plot(strategy.equity)</span><br></pre></td></tr></table></figure>

<p>盈亏曲线</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104151143.png" class="lozad"></p>
<p>交易逻辑</p>
<ul>
<li>buy：当空仓时候买入，40000笔合约（40000美金）</li>
<li>bracket1：设定平仓对象为buy标识的交易，平仓2000美金，止盈300点（单位为步，3000步=300点）。止损300点</li>
<li>bracket2：止盈止损200点</li>
</ul>
<p>下面结合交易清单具体分析</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104215413.png" class="lozad"></p>
<ul>
<li>1：空仓买入4000美金</li>
<li>2：止损200点，亏损20000 * 200 * 0.0001 = $ 400，从图中可以看到是bracket2 先止损</li>
<li>3：价格继续向下，亏损300点，bracket1策略触发，亏损$ 600</li>
<li>4,5,6:同上逻辑</li>
</ul>
<h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><p>strategy.risk.* 一系列函数，可以帮助进行风险管理。当风险管理规则被激活的时候，没有订单会生成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">strategy(&quot;multi risk demo&quot;, overlay=true, pyramiding=10, calc_on_order_fills = true)</span><br><span class="line">if year &gt; 2014</span><br><span class="line">    strategy.entry(&quot;LE&quot;, strategy.long)</span><br><span class="line">strategy.risk.max_intraday_filled_orders(5)</span><br><span class="line">strategy.risk.max_intraday_filled_orders(2)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>strategy.risk.max_intraday_filled_orders(2)</p>
<p>限制一天成交的最大的交易单数，一旦达到，所有未成交订单全部取消，成交订单关闭。并且一直关闭交易直到本交易日结束。</p>
<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104172514.png" class="lozad"></p>
<p>上图中，当第二笔交易生成的时候，同时也是两笔交易关闭的时间。</p>
</li>
<li><p>其余的函数参考手册</p>
</li>
</ul>
<h2 id="指标重绘"><a href="#指标重绘" class="headerlink" title="指标重绘"></a>指标重绘</h2><p>历史数据仅仅包含OHLC，不包含线内的运动。这会导致的问题是，历史数据上的回测和实时数据不一致的情况。</p>
<p>另外一个担心是，未来函数的使用。这里尤其要关注security 函数，此函数可能会错误的引入未来的信息。</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>Pine V4 中存在两种绘图类型：label 和 line。</p>
<blockquote>
<p>注：用户的绘图和 编程绘图是不一样的，编程得到的绘图是不能用鼠标修改的。</p>
</blockquote>
<p>和指标绘图函数(plot,plotshape,plotchar) 不一样的是，绘图函数可以在图表右侧没有K线的地方。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label.new(x, y, text, xloc, yloc, color, style, textcolor, size) → series[label]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;My Script&quot;, overlay=true)</span><br><span class="line">label.new(bar_index, high, style=label.style_none,</span><br><span class="line">          text=&quot;x=&quot; + tostring(bar_index) + &quot;\ny=&quot; + tostring(high))</span><br></pre></td></tr></table></figure>

<p><img alt data-src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104175710.png" class="lozad"></p>
<ul>
<li><p>x的位置是用bar_index 标识的，此时xloc 的默认值为xloc.barindex</p>
</li>
<li><p>y的位置是最高价</p>
</li>
<li><p>xloc取值：xloc.bar_index(默认) 和 xloc.bar_time</p>
</li>
<li><p>yloc取值：</p>
<ul>
<li><p>yloc.price 传入此函数，需要输入y值</p>
</li>
<li><p>yloc.abovebar,yloc.belowbar 启动时，y值会失效。标签在图表上部或者下部</p>
</li>
</ul>
</li>
<li><p>style: 很多种，可能用到比较多的有label.style_none，无底色</p>
</li>
</ul>
<p>label.set_* 一系列函数可以用来对对象进一步的修改。</p>
<h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">line.new(x1, y1, x2, y2, xloc, extend, color, style, width) → series[line]</span><br></pre></td></tr></table></figure>

<ul>
<li>extend: extend.none/extend.right/extend.left</li>
</ul>
]]></content>
      <categories>
        <category>量化</category>
        <category>Pine</category>
      </categories>
      <tags>
        <tag>Pine</tag>
        <tag>TradingView</tag>
        <tag>量化</tag>
      </tags>
  </entry>
  <entry>
    <title>Pine Script 学习笔记</title>
    <url>/2019/10/31/Pine%20Script%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Pine-Script-学习笔记——基础语法篇（一）"><a href="#Pine-Script-学习笔记——基础语法篇（一）" class="headerlink" title="Pine Script 学习笔记——基础语法篇（一）"></a>Pine Script 学习笔记——基础语法篇（一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>量化交易平台 <a href="https://www.tradingview.com/" target="_blank" rel="noopener">TrendingView </a> 是一个支持多种资产的投资平台，很多人在上面分享对于股票，外汇，数据货币等资产的投资观点，难得的是在上面能找到很多人的交易策略。</p>
<p>TrendingView 使用的是自己开发的Pine 语言作为脚本，这一点和MT4 开发的mql4 很像。用户可以自己编写脚本和策略，并与其他人分享。Pine 直观给我的印象比Mql4 更加简单，更加关注于策略本身，而不是编程技巧。</p>
<p>此外，Pine语言编辑器没有那么强大的debug 功能，这对于一开始上手练习来说，不是那么方便。不过它一直在更新，发展的很快。</p>
<p>TrendingView 对接了很多经纪商，使得它支持的交易品种很丰富，而且它的图表功能很强大。</p>
<p>下面记录一下自己学习Pine 脚本的一些基础的笔记，权当备忘。主要内容都参考自Pine 的脚本文档</p>
<h2 id="脚本结构"><a href="#脚本结构" class="headerlink" title="脚本结构"></a>脚本结构</h2><p>指明用的Pine 脚本版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br></pre></td></tr></table></figure>

<p>Pine 可以分为study脚本 和 strategy 脚本（指标&amp;策略）<br>study 脚本必须包含 plot,plotshape,barcolor,line.new  等输出<br>strategy 脚本包含 strategy.* 即交易函数</p>
<h2 id="换行-Line-wrapping"><a href="#换行-Line-wrapping" class="headerlink" title="换行 Line wrapping"></a>换行 Line wrapping</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//例子1 换行需要空格</span><br><span class="line">a = open+</span><br><span class="line">      high+</span><br><span class="line">        low</span><br><span class="line">// 例子2 换行中不能有注释</span><br><span class="line">a = open+</span><br><span class="line">       high // 此处加注释会出问题</span><br><span class="line">// 例子3 函数内换行，空行必须要超过一个Tab（或者4个空格）</span><br><span class="line">label.new(bar_index, na, yloc=yloc.abovebar, text=t,</span><br><span class="line">     color=hist ? color.green : color.red)</span><br><span class="line">// 这里空格必须超过4个</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>算术： + - * / %</p>
<blockquote>
<p>1/2 = 0<br>1/2.0 = 0.5</p>
</blockquote>
</li>
<li><p>比较:  ==  !=</p>
</li>
<li><p>逻辑: not and or</p>
</li>
<li><p>三元运算符：</p>
<ul>
<li>condition ? result1 : result2</li>
<li>iff(condition, result1, result2)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有房？嫁:有车？: 嫁:帅？嫁: 不嫁</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]  运算符(History reference operator)<br>close 代表最新的价格，close[1]代表了历史价格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close = close[0] //显示的是最新的收盘价</span><br></pre></td></tr></table></figure>
<p>除此之外，Pine脚本里面还有一个变量 bar_index，记录着bar的数目，编号自左向右，从0开始。bar_index = (bar数量)N-1。</p>
<ul>
<li><input disabled type="checkbox"> 为什么运行close[bar_index-1] ≠ close[0] ?<br>而close[bar_index-1] 会出错</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Pine 脚本中包含了大量的自建函数，用户还可以自定义函数、</p>
<ul>
<li><p>单行函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x,y) =&gt; x+y</span><br></pre></td></tr></table></figure>

<p>Pine Script 的函数不支持<strong><u>递归</u></strong></p>
<p>即，不允许在函数中再次调用自己本身</p>
</li>
<li><p>多行函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">geom_average(x, y) =&gt;</span><br><span class="line">    a = x*x</span><br><span class="line">    b = y*y</span><br><span class="line">    sqrt(a + b)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Pine Script 需要（一个Tab 或者4空格，TrendingView 会自动用4个空格来替换掉Tab）来划定函数的范围</li>
<li>最后一行的表达式或 变量作为函数的输出结果</li>
</ul>
</blockquote>
</li>
<li><p>输出&gt;=2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun(x,y) =&gt;</span><br><span class="line">	 a = x+y</span><br><span class="line">   b = x-y</span><br><span class="line">   retrun [a,b]</span><br><span class="line">// 调用函数</span><br><span class="line">[a,b] =fun(3,2)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="函数的注意事项"><a href="#函数的注意事项" class="headerlink" title="函数的注意事项"></a>函数的注意事项</h3><p>当在函数块中使用函数或者历史数据信息的时候要注意。因为所使用的历史信息是每一次连续调用生成的。</p>
<p>如果函数并不是在每一根柱线上都调用，那么数据生成就会出现错误。</p>
<ul>
<li><p>例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义两个函数f1,f2</span><br><span class="line">f1(a) =&gt; a[1]</span><br><span class="line">f2() =&gt; close[1]</span><br><span class="line">// 说明下列用法的实际意义</span><br><span class="line">f1(close) 等价于 close[2]</span><br><span class="line">f2() 等价于 close[1]</span><br></pre></td></tr></table></figure>

<div alig="“center”">
<img data-src="https://www.tradingview.com/pine-script-docs/en/v4/_images/Function_historical_context_1.png" class="lozad">
</div>

<p>f1 传入的close 序列，需要在第一次调用后才能生成，所以f1 的 价格信息实际上比f2 晚一天</p>
</li>
</ul>
<h2 id="变量声明-amp-语句statement"><a href="#变量声明-amp-语句statement" class="headerlink" title="变量声明&amp;语句statement"></a>变量声明&amp;语句statement</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul>
<li><p>Pine 语言中变量定义的方式有两种： = 和 var</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 1 // a为整形</span><br><span class="line">float a = 1 // a为浮点型</span><br><span class="line">var a = 0</span><br><span class="line">var int a = 0</span><br><span class="line">b = na //出错</span><br></pre></td></tr></table></figure>

<p>变量定义的时候，需要指明变量的类型(或者 等式右侧表达式能指明类型亦可)</p>
<p>na 没有特定的类型，所以赋值时会出错</p>
</li>
<li><p>var 关键词</p>
<p>var 是用于分配和一次性初始化变量的关键词。</p>
<p>不含var 关键词的变量在每次数据更新的时候都会覆盖变量的值。使用了var 关键词的变量，在数据更新中，可以“保持状态”。<br>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;Var keyword example&quot;)</span><br><span class="line">var a = close</span><br><span class="line">var b = 0.0</span><br><span class="line">var c = 0.0</span><br><span class="line">var green_bars_count = 0</span><br><span class="line">if close &gt; open</span><br><span class="line">	var x = close</span><br><span class="line">	b := x</span><br><span class="line">	green_bars_count := green_bars_count + 1</span><br><span class="line">	if green_bars_count &gt;= 10</span><br><span class="line">		var y = close</span><br><span class="line">		c := y</span><br><span class="line">plot(a)</span><br><span class="line">plot(b)</span><br><span class="line">plot(c)</span><br></pre></td></tr></table></figure>

<p>变量 ‘a’ 保持系列中每个柱线的第一根柱线的收盘价。</p>
<p>变量 ‘b’保持系列中第一个“绿色”价格棒的收盘价。</p>
<p>变量 ‘c’保持系列中第十个“绿色”条的收盘价。</p>
<p>即a,b,c 都是一个常数。</p>
<p>去除var 的话，a,b,c 会随着价格变化而变化</p>
</li>
</ul>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// This code compiles</span><br><span class="line">x = if close &gt; open</span><br><span class="line">    close</span><br><span class="line">else</span><br><span class="line">    open</span><br><span class="line">// This code doesn&apos;t compile</span><br><span class="line">x = if close &gt; open</span><br><span class="line">    close</span><br><span class="line">else</span><br><span class="line">    &quot;open&quot;</span><br></pre></td></tr></table></figure>
<p>  需要注意的是，与python不同，Pine要求，then 和 else语句返回的值的类型是相同的。在上面的第二个例子中，close 和 “open” 一个是float Series，另一个是string，不同类型的话，编译会出错。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  x = if close &gt; open</span><br><span class="line">    close</span><br><span class="line">// If current close &gt; current open, then x = close.</span><br><span class="line">// Otherwise the x = na.</span><br></pre></td></tr></table></figure>
<p>  if 语句中可以忽略else，但是系统会默认赋值（na,false,””）</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i = 1 to length-1</span><br><span class="line">     sum := sum + price[i]</span><br></pre></td></tr></table></figure>



<h2 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h2><p>Pine代码是根据价格信息计算的。但是价格信息并不是完整加载的，用户可以一直向左滑动图表，直到最早的一根柱子（Pro 用户可以在图表上加载10000左右，免费用户可以加载5000根柱子）</p>
<h3 id="实时数据的计算"><a href="#实时数据的计算" class="headerlink" title="实时数据的计算"></a>实时数据的计算</h3><p>Pine指标计算实时数据的时候和计算历史数据略有不同，因为实时数据会有addtional commit(?)和rollback action(?)</p>
<p>在实时数据的处理过程中，柱线的每一次变动都会引起Pine 指标的计算</p>
<ul>
<li>rollback : 在每一根柱线更新时发生</li>
<li>commit : 在每一根柱线关闭时发生</li>
</ul>
<p>对于判断柱线的状态，Pine中有一系列的自建函数 barstate.* 来显示当前柱线的状态。</p>
]]></content>
      <categories>
        <category>量化</category>
        <category>Pine</category>
      </categories>
      <tags>
        <tag>Pine</tag>
        <tag>TradingView</tag>
        <tag>量化</tag>
      </tags>
  </entry>
  <entry>
    <title>博客第一贴：Hexo 搭建</title>
    <url>/2019/10/27/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Hexo-博客搭建"><a href="#Hexo-博客搭建" class="headerlink" title="Hexo 博客搭建"></a>Hexo 博客搭建</h1><blockquote>
<p>CodeSheep 学习笔记</p>
</blockquote>
<p>Hexo 是一款基于node.js 的静态博库框架，而且可以可以方便的托管在Github 上（ 正好B站 up 主 :程序羊也推荐了）， 所以也正好简单记录一下Hexo 的安装配置过程</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>不少博客已经总结的很好了，所以提前放上人家的地址</p>
<p><a href="http://fangzh.top/2018/2018090514/" target="_blank" rel="noopener">hexo教程：github page+独立域名搭建(1)</a></p>
<p><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p>
<h2 id="本地搭建hexo博客"><a href="#本地搭建hexo博客" class="headerlink" title="本地搭建hexo博客"></a>本地搭建hexo博客</h2><h3 id="下载node-js"><a href="#下载node-js" class="headerlink" title="下载node.js"></a>下载node.js</h3><p> 官网下载LTS版本，直接安装</p>
<h3 id="npm-安装hexo"><a href="#npm-安装hexo" class="headerlink" title="npm 安装hexo"></a>npm 安装hexo</h3><p>注意：切换为 root 账号操作    <code>su</code>  ,切换淘宝源 cnpm,会更加快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>安装hexo <code>cnpm install hexo-cli -g</code> </p>
<p>安装完后用<code>hexo -v</code> 查看一下是否安装成功</p>
<h3 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h3><p>在目录下创建 blog 文件夹  <code>mkdir blog</code> ,进入 <code>cd blog</code></p>
<p><strong>初始化hexo</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure>

<p>出现 <code>INFO  Start blogging with Hexo!</code>  表示安装完成</p>
<p><strong>启动hexo</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server / hexo s</span><br></pre></td></tr></table></figure>

<h3 id="写第一篇博客"><a href="#写第一篇博客" class="headerlink" title="写第一篇博客"></a>写第一篇博客</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &apos;my first blog&apos;</span><br></pre></td></tr></table></figure>

<p>命令会在 /Users/YourUserName/blog/source/_posts/ 文件夹下生成一篇 md文件</p>
<p>可以在finder 中用 typro 编辑</p>
<p>清空hexo: <code>hexo clean</code></p>
<p>重新生成hexo： <code>hexo generate / hexo g</code></p>
<h2 id="github-仓库上搭建"><a href="#github-仓库上搭建" class="headerlink" title="github 仓库上搭建"></a>github 仓库上搭建</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>New repository </p>
<p>注意：名字必须为自己的用户名+.github.io</p>
<p>如 PPsteven.github.io</p>
<h3 id="安装git-插件"><a href="#安装git-插件" class="headerlink" title="安装git 插件"></a>安装git 插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<h3 id="修改-config-yml-配置文件"><a href="#修改-config-yml-配置文件" class="headerlink" title="修改 _config.yml 配置文件"></a>修改 _config.yml 配置文件</h3><p>在配置文件中找到如下代码，添加repo 信息和 branch 信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/PPsteven/PPsteven.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>部署hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean    <span class="comment">#会清除缓存文件db.json及之前生成的静态文件夹public；</span></span><br><span class="line">hexo g     <span class="comment">#会重新生成静态文件夹public；</span></span><br><span class="line">hexo deploy/ hexo d    <span class="comment">#因为之前已经安装了插件并且在博客配置文件中也配置好了，所以这个命令会在博客根目录下生成一个.deploy_git的文件夹，并 把本地生成的静态文件部署到LiLei.github.io这个仓库中的master分支上；</span></span><br></pre></td></tr></table></figure>

<p>如果是第一次部署，会提示输入github 账号和密码</p>
<p><strong>成功！！</strong></p>
<p>远端访问：PPsteven.github.io</p>
<h1 id="进阶教程"><a href="#进阶教程" class="headerlink" title="进阶教程"></a>进阶教程</h1><h2 id="参考教程："><a href="#参考教程：" class="headerlink" title="参考教程："></a>参考教程：</h2><blockquote>
<p><a href="http://fangzh.top/2018/2018090715/" target="_blank" rel="noopener">hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2)</a></p>
<p><a href="https://uchuhimo.me/2017/04/11/genesis/#more" target="_blank" rel="noopener">如何使用 Hexo 和 GitHub Pages 搭建这个博客</a></p>
</blockquote>
<p>学习了上面的教程后，基本的搭建和部署已经没有问题了。</p>
<p>主要的一个需求就是多电脑同步的问题。</p>
<h2 id="Hexo-CheetSheet"><a href="#Hexo-CheetSheet" class="headerlink" title="Hexo CheetSheet"></a>Hexo CheetSheet</h2><ul>
<li><p>初始化目录：<code>hexo init [folder]</code></p>
</li>
<li><p>新建文章：<code>hexo new/n [layout] &lt;title&gt;</code> 或</p>
<ul>
<li>新建草稿：<code>hexo new draft &lt;title&gt;</code></li>
<li>新建页面：<code>hexo new page tags</code></li>
</ul>
</li>
<li><p>将草稿发布为正式文章：<code>hexo publish &lt;title&gt;</code></p>
</li>
<li><p>生成静态文件：<code>hexo generate/g</code></p>
<ul>
<li>监听文件变化：<code>hexo g --watch</code> 或 <code>hexo g -w</code></li>
</ul>
</li>
<li><p>部署：<code>hexo deploy/d</code></p>
<ul>
<li>先生成后部署：<code>hexo d -g</code></li>
<li>等于 <code>hexo g</code> 加 <code>hexo d</code></li>
</ul>
</li>
<li><p>启动本地服务器（服务器会监听文件变化并自动更新）</p>
<ul>
<li><p><code>hexo server/s</code></p>
</li>
<li><p>启动调试：<code>hexo s --debug</code></p>
</li>
<li><p>预览草稿：<code>hexo s --draft</code></p>
</li>
</ul>
</li>
<li><p>清除缓存：<code>hexo clean</code></p>
</li>
</ul>
<h2 id="主题安装教程"><a href="#主题安装教程" class="headerlink" title="主题安装教程"></a>主题安装教程</h2><blockquote>
<p>安装教程： <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT官网</a><br>         <a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">jerry博客</a></p>
</blockquote>
<h3 id="下载主题-amp-启动"><a href="#下载主题-amp-启动" class="headerlink" title="下载主题&amp;启动"></a>下载主题&amp;启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line"><span class="comment"># 编辑_config.yml</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"><span class="comment"># 编辑_config.yml</span></span><br><span class="line">theme: Butterfly</span><br></pre></td></tr></table></figure>

<h2 id="NexT-主题配置"><a href="#NexT-主题配置" class="headerlink" title="NexT 主题配置"></a>NexT 主题配置</h2><h3 id="设定主题-语言"><a href="#设定主题-语言" class="headerlink" title="设定主题/语言"></a>设定主题/语言</h3><p>主题配置的文件在themes/NexT 文件夹下的_config.yml 中，我们按照官网教程，依次配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure>

<h3 id="添加标签-分类-关于页面"><a href="#添加标签-分类-关于页面" class="headerlink" title="添加标签/分类/关于页面"></a>添加标签/分类/关于页面</h3><p>hexo 新建命令 <code>hexo n [layout] title</code> 中 layout 有三个模板</p>
<p>post创建文章，生成在<code>/source/_posts</code>文件夹下，draft创建草稿，生成在<code>/source/ _drafts</code> 文件夹下，page创建页面，生成在<code>/source/YourPageName</code>文件夹下   </p>
<p>![image-20191027011714501](/Users/ppsteven/Library/Application Support/typora-user-images/image-20191027011714501.png)</p>
<ul>
<li><p>新建页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改菜单（编辑 themes/next/_config.yml）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span> <span class="comment"># 关于页面</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span>  <span class="comment"># 标签页面</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span> <span class="comment"># 分类页面</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span> <span class="comment"># 归档页面</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span> <span class="comment"># 公益404</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>_config.yml 在blog 文件和 theme/next 文件夹下都有</p>
<p>blog 下的为站点配置文件，主题下的为主题配置文件</p>
<p><code>mkdir themes/next/source/uploads</code> ，放置头像图片（jpg/gif 等）</p>
<p>修改配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># avatar: http://example.com/avatar.png</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/uploads/avatar_1.jpg</span></span><br></pre></td></tr></table></figure>

<h3 id="设置作者昵称"><a href="#设置作者昵称" class="headerlink" title="设置作者昵称"></a>设置作者昵称</h3><p>修改  <strong>站点配置文件</strong> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">author:</span> <span class="string">Your</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>

<h3 id="设置阅读字数与时长"><a href="#设置阅读字数与时长" class="headerlink" title="设置阅读字数与时长"></a>设置阅读字数与时长</h3><p>需要安装插件，<a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">地址</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="配置搜索服务"><a href="#配置搜索服务" class="headerlink" title="配置搜索服务"></a>配置搜索服务</h3><p>Local Search添加百度/谷歌/本地 自定义站点内容搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>编辑站点配置文件，新增如下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>编辑主题配置文件，启动本地搜索</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>设置摘要</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>



<h2 id="多端同步"><a href="#多端同步" class="headerlink" title="多端同步"></a>多端同步</h2><p>正常情况下，我们写的博客是备份在本地的，没有上传服务器，但是若是有多台电脑的话。如何保持同步是一个问题。最近用闲置的笔记本搞了一个manjaro 玩耍，需要进行多端同步</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>具体的步骤请参考上面的教程，主要安装</p>
<ul>
<li>node.js</li>
<li>git</li>
<li>hexo</li>
</ul>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>在<code>blog</code>文件夹下，我们用<code>hexo d</code> 命令提交的仅仅是public 文件夹里面的内容，默认的是提交在 master 分支上。为了在同一个repo 下管理我们的博客，我们可以建立新的分支hexo</p>
<ul>
<li><p>github 上创建一个新的分支 hexo。进入仓库在，点击Branch，输入新的分支名回车建立</p>
<p><a href="https://upload-images.jianshu.io/upload_images/4122543-a8884eab55430542.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在本地仓库创建hexo 分支，添加remote 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout -b hexo <span class="comment"># 代表创建并切换</span></span><br><span class="line"><span class="variable">$git</span> remote add origin git@github.com:PPsteven/hexo_source.git </span><br><span class="line"><span class="comment"># 添加远端地址</span></span><br><span class="line"><span class="variable">$git</span> remote -v <span class="comment"># 查看remote 地址</span></span><br><span class="line">origin	git@github.com:PPsteven/PPsteven.github.io.git (fetch)</span><br><span class="line">origin	git@github.com:PPsteven/PPsteven.github.io.git (push)<span class="comment"># 表示添加成功</span></span><br></pre></td></tr></table></figure>

<p>其实有一个取巧的方法，在GitHub上创建新的分支hexo 后，在blog 文件夹中直接将该仓库的hexo 分支克隆到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> -b git@github.com:PPsteven/PPsteven.github.io.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>向本地分支添加文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> add . <span class="comment"># 本地文件添加至暂存区</span></span><br><span class="line"><span class="variable">$git</span> commit -m <span class="string">"blog file backup"</span> <span class="comment"># 暂存区文件提交至本地分支</span></span><br><span class="line"><span class="variable">$git</span> push origin hexo <span class="comment"># 向远端hexo 分支提交文件</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>备注: 看到网上讨论，在提交文件的时候，themes 文件夹会出错。原因是themes 下文件夹的主题包含.git 文件，造成了冲突，删除即可。</p>
</blockquote>
<h3 id="同步分支"><a href="#同步分支" class="headerlink" title="同步分支"></a>同步分支</h3><p>进入新的电脑，同步到本地就可以编辑了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> pull origin hexo</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>电脑基本配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 入门基础环境搭建</title>
    <url>/2019/09/01/Mac%20%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Homebrew常用命令"><a href="#Homebrew常用命令" class="headerlink" title="Homebrew常用命令"></a>Homebrew常用命令</h2><blockquote>
<p>官网安装 Homebrew</p>
<p><a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">http://mxcl.github.com/homebrew/</a></p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>包管理软件</p>
<p>Win: 360软件管家</p>
<p>Debian/Ubuntu: apt包管理系统 </p>
<p>Redhat/Fedora: yum包管理系统</p>
<p>Mac OS X: Macports,Fink,AppStore</p>
<p>以及   <strong>Homebrew</strong> </p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>brew -v    查询Homebrew版本<br>brew -h    brew帮助<br>brew update    更新Homebrew<br>brew install <pkg_name>    安装任意软件<br>brew uninstall <pkg_name>    卸载任意软件<br>brew search <pkg_name>    查询任意包<br>brew list    列出安装列表<br>brew info <pkg_name>    查看任意包内容信息<br>brew upgrade <pkg_name>    更新任意包<br>brew cleanup <pkg_name>    删除具体旧软件<br>brew cleanup        删除所有旧软件<br>brew outdated        已安装的包是否需要更新</p>
<h2 id="item2-oh-my-zsh"><a href="#item2-oh-my-zsh" class="headerlink" title="item2+oh-my-zsh"></a>item2+oh-my-zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>

<p>chsh -s /bin/zsh. # 命令航切换bash为zsh shell<br>iterm的perference-&gt;profiles-&gt;commond 设置成/bin/zsh # iterm2 界面手动切换</p>
<ul>
<li>更改shell 语言<ol>
<li>cat /etc/shells # 查看所有 shell</li>
<li>chsh -s /bin/zsh #切换为zsh </li>
<li>修改文件<br>vi ~/.zshrc<br>source ~/.zshrc</li>
<li>echo $SHELL # 查看当前shell </li>
</ol>
</li>
</ul>
<h4 id="Iterm2-使用技巧"><a href="#Iterm2-使用技巧" class="headerlink" title="Iterm2 使用技巧"></a>Iterm2 使用技巧</h4><blockquote>
<p>参考 <a href="https://www.cnblogs.com/manastudent/p/7367718.html" target="_blank" rel="noopener">iTerm2常用的快捷键</a></p>
</blockquote>
<p>设置全局打开快捷键</p>
<p>Perferemance -&gt; Keys -&gt;Hotkey -&gt; show/hide all windows with a system-wide hotkey</p>
<p>command + shift + t  # 设置快捷键 打开iterm2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建标签：command + t</span><br><span class="line">关闭标签：command + w</span><br><span class="line">切换全屏：command + enter</span><br><span class="line">查找：command + f</span><br><span class="line">垂直分屏：command + d</span><br><span class="line">垂直上下分屏：command + shift + d</span><br><span class="line">左右 tab 之间来回切换：⌘ + 1 / 2</span><br><span class="line">查看历史命令：command + ; （输入常用命令的前缀后使用该快捷键可以实现补全的功能）</span><br><span class="line">除当前行：ctrl + u / ctrl +c </span><br><span class="line">上一条命令：ctrl + p</span><br><span class="line">搜索命令历史：ctrl + r</span><br><span class="line">清屏：clear</span><br><span class="line">重新打开：command + r</span><br><span class="line">iTerm2 剪切板历史：command + shift + h</span><br></pre></td></tr></table></figure>

<h4 id="zsh-插件配置"><a href="#zsh-插件配置" class="headerlink" title="zsh  插件配置"></a>zsh  插件配置</h4><p>目前已经有的自带插件在官网Github中可以看到，<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins。" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins。</a><br>凡是这里有的，都可以立刻生效。</p>
<h4 id="参考页面"><a href="#参考页面" class="headerlink" title="参考页面"></a>参考页面</h4><blockquote>
<p><a href="https://blog.e9china.net/lesson/yixieshiyongchangyongchajiantuijianforzshoh-my-zsh.html" target="_blank" rel="noopener">一些实用常用插件推荐 for zsh oh-my-zsh</a></p>
</blockquote>
<h5 id="git-默认自带"><a href="#git-默认自带" class="headerlink" title="git 默认自带"></a>git 默认自带</h5><h5 id="zsh-syntax-highlighting-语法高亮"><a href="#zsh-syntax-highlighting-语法高亮" class="headerlink" title="zsh-syntax-highlighting  语法高亮"></a>zsh-syntax-highlighting  语法高亮</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>将zsh-syntax-highlighting 下载到zsh 的plugins 目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=(其他的插件 zsh-autosuggestions)</span><br></pre></td></tr></table></figure>

<h5 id="zsh-autosuggestions-自动建议"><a href="#zsh-autosuggestions-自动建议" class="headerlink" title="zsh-autosuggestions 自动建议"></a>zsh-autosuggestions 自动建议</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=(其他的插件 zsh-autosuggestions)</span><br></pre></td></tr></table></figure>

<h5 id="sublime-默认自带"><a href="#sublime-默认自带" class="headerlink" title="sublime 默认自带"></a>sublime 默认自带</h5><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>st</td>
<td>打开sublime</td>
</tr>
<tr>
<td>st + 文件夹</td>
<td>打开文件夹</td>
</tr>
<tr>
<td>st + 文件</td>
<td>打开文件</td>
</tr>
<tr>
<td>stt</td>
<td>打开当前文件夹 ，等价于 st .</td>
</tr>
<tr>
<td>sst</td>
<td>管理员权限 相当于 sudo st</td>
</tr>
</tbody></table>
<h5 id="z-默认自带"><a href="#z-默认自带" class="headerlink" title="z 默认自带"></a>z 默认自带</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">z -x 无效路径</span><br><span class="line">z 目录名称</span><br></pre></td></tr></table></figure>

<h5 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install autojump </span><br><span class="line">plugins=(其他的插件 autojump)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是linux 系统可能比较麻烦一点，需要从github 上下源码安装（当然也可以保证是最新的）</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:wting/autojump.git  autojump</span><br><span class="line">$ <span class="built_in">cd</span> autojump</span><br><span class="line">$ ./install.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行完毕后就会出现如下信息</span></span><br><span class="line">Please manually add the following line(s) to ~/.zshrc:</span><br><span class="line"></span><br><span class="line">	[[ -s /home/ppsteven/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; <span class="built_in">source</span> /home/ppsteven/.autojump/etc/profile.d/autojump.sh</span><br><span class="line"></span><br><span class="line">	<span class="built_in">autoload</span> -U compinit &amp;&amp; compinit -u</span><br><span class="line"></span><br><span class="line">Please restart terminal(s) before running autojump.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照操作在 .zshrc 中添加，我是乖乖添加了，其实我们可以直接在plugins 中添加的</span></span><br><span class="line">plugins=(其他的插件 autojump)</span><br></pre></td></tr></table></figure>

<h4 id="附录-zshrc配置"><a href="#附录-zshrc配置" class="headerlink" title="附录.zshrc配置"></a>附录<code>.zshrc</code>配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="comment"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">"/Users/ppsteven/.oh-my-zsh"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set name of the theme to load --- if set to "random", it will</span></span><br><span class="line"><span class="comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"><span class="comment"># See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span></span><br><span class="line"><span class="comment"># ZSH_THEME="agnoster"</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set list of themes to pick from when loading at random</span></span><br><span class="line"><span class="comment"># Setting this variable when ZSH_THEME=random will cause zsh to load</span></span><br><span class="line"><span class="comment"># a theme from this variable instead of looking in ~/.oh-my-zsh/themes/</span></span><br><span class="line"><span class="comment"># If set to an empty array, this variable will have no effect.</span></span><br><span class="line"><span class="comment"># ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use case-sensitive completion.</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use hyphen-insensitive completion.</span></span><br><span class="line"><span class="comment"># Case-sensitive completion must be off. _ and - will be interchangeable.</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable bi-weekly auto-update checks.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_UPDATE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to automatically update without prompting.</span></span><br><span class="line"><span class="comment"># DISABLE_UPDATE_PROMPT="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to change how often to auto-update (in days).</span></span><br><span class="line"><span class="comment"># export UPDATE_ZSH_DAYS=13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if pasting URLs and other text is messed up.</span></span><br><span class="line"><span class="comment"># DISABLE_MAGIC_FUNCTIONS=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable colors in ls.</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable auto-setting terminal title.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to enable command auto-correction.</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to display red dots whilst waiting for completion.</span></span><br><span class="line"><span class="comment"># COMPLETION_WAITING_DOTS="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to change the command execution time</span></span><br><span class="line"><span class="comment"># stamp shown in the history command output.</span></span><br><span class="line"><span class="comment"># You can set one of the optional three formats:</span></span><br><span class="line"><span class="comment"># "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"</span></span><br><span class="line"><span class="comment"># or set a custom format using the strftime function format specifications,</span></span><br><span class="line"><span class="comment"># see 'man strftime' for details.</span></span><br><span class="line"><span class="comment"># HIST_STAMPS="mm/dd/yyyy"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load?</span></span><br><span class="line"><span class="comment"># Standard plugins can be found in ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">          git</span><br><span class="line"><span class="comment">#          zsh-syntax-highlighting</span></span><br><span class="line">          zsh-autosuggestions</span><br><span class="line">	        sublime</span><br><span class="line">	        autojump </span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export MANPATH="/usr/local/man:$MANPATH"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR='vim'</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR='mvim'</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># added by Anaconda3 2019.07 installer</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; conda init &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by 'conda init' !!</span></span><br><span class="line">__conda_setup=<span class="string">"<span class="variable">$(CONDA_REPORT_ERRORS=false '/Users/ppsteven/anaconda3/bin/conda' shell.bash hook 2&gt; /dev/null)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    \<span class="built_in">eval</span> <span class="string">"<span class="variable">$__conda_setup</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"/Users/ppsteven/anaconda3/etc/profile.d/conda.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">"/Users/ppsteven/anaconda3/etc/profile.d/conda.sh"</span></span><br><span class="line">        CONDA_CHANGEPS1=<span class="literal">false</span> conda activate base</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        \<span class="built_in">export</span> PATH=<span class="string">"/Users/ppsteven/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda init &lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS="-arch x86_64"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="built_in">alias</span> zshconfig=<span class="string">"vim ~/.zshrc"</span></span><br><span class="line"><span class="comment"># alias ohmyzsh="mate ~/.oh-my-zsh"</span></span><br></pre></td></tr></table></figure>



<h2 id="解压软件"><a href="#解压软件" class="headerlink" title="解压软件"></a>解压软件</h2><h3 id="解压软件-unrar"><a href="#解压软件-unrar" class="headerlink" title="解压软件 unrar"></a>解压软件 unrar</h3><p>brew install unrar</p>
<p>使用方法</p>
<p>unrar x test.rar # 解压到当前目录</p>
<h3 id="解压软件-7z"><a href="#解压软件-7z" class="headerlink" title="解压软件 7z"></a>解压软件 7z</h3><p>brew search 7z   # p7zip</p>
<p>brew install p7zip</p>
<p>使用方法</p>
<p>7z e filename.7z</p>
<h2 id="图床软件PicGo"><a href="#图床软件PicGo" class="headerlink" title="图床软件PicGo"></a>图床软件PicGo</h2><p>安装教程</p>
<blockquote>
<p><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p>
<p>看完上面的配置才发现也是找工作的学生，真是厉害</p>
</blockquote>
<p>Github 图床配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PPsteven/pictures</span><br><span class="line">master</span><br><span class="line">Token:XXXXX</span><br><span class="line">img/</span><br><span class="line">https://cdn.jsdelivr.net/gh/PPsteven/pictures</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>电脑基本配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
