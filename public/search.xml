<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker 实战:利用 docker 搭建服务</title>
    <url>/2020/06/18/docker-some-service-build-instruction/</url>
    <content><![CDATA[<p>用 <code>docker</code> 安装需要用到的服务实在是太方便了，我们下面介绍一些好的轮子来用。</p>
<ul>
<li>web-vscode: 搭建一个web版的vscode，不过实测下来不是特别好用。很多<code>vscode</code>上的插件用不了</li>
<li>redis web: web端的web管理工具，不过配置起来稍微有点麻烦。</li>
<li>lamp: php基础开发环境</li>
</ul>
<a id="more"></a>

<h2 id="web-vscode-安装"><a href="#web-vscode-安装" class="headerlink" title="web-vscode 安装"></a>web-vscode 安装</h2><blockquote>
<p> 传送门: <a href="https://github.com/cdr/code-server" target="_blank" rel="noopener">code-server</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建</span></span><br><span class="line">docker rm -f vscode </span><br><span class="line">docker run \</span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">-d \ </span><br><span class="line"><span class="comment"># 总是运行</span></span><br><span class="line">--restart=always \ </span><br><span class="line"><span class="comment"># Alias</span></span><br><span class="line">--name web_vscode \ </span><br><span class="line"><span class="comment"># hostname</span></span><br><span class="line">-h vscode \ </span><br><span class="line"><span class="comment"># 一定要以root账号运行,不然会报 Permission denied</span></span><br><span class="line">-u root \ </span><br><span class="line"><span class="comment"># 所有端口映射，而不要是127.0.0.1</span></span><br><span class="line">-p 8086:8080 \ </span><br><span class="line">-v <span class="string">"<span class="variable">$&#123;HOME&#125;</span>/.local/share/code-server:/home/coder/.local/share/code-server"</span> \ </span><br><span class="line"><span class="comment"># 密码是通过环境变量加入的</span></span><br><span class="line">-e PASSWORD=mycode \ </span><br><span class="line"><span class="comment"># $PWD 是当前希望项目放置的位置</span></span><br><span class="line">-v <span class="string">"<span class="variable">$PWD</span>:/home/coder/project"</span> \</span><br><span class="line"><span class="comment"># 镜像名，本地不存在的话，会从仓库拉取</span></span><br><span class="line">codercom/code-server:v2  </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">docker ps -l</span><br><span class="line">docker logs web_vscode</span><br></pre></td></tr></table></figure>

<p>运行成功后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info  Server listening on http://0.0.0.0:8080</span><br><span class="line">info    - Password is 558ba38067432e3beddf1228</span><br><span class="line">info      - To use your own password, <span class="built_in">set</span> the PASSWORD environment variable</span><br><span class="line">info      - To <span class="built_in">disable</span> use `--auth none`</span><br><span class="line">info    - Not serving HTTPS</span><br></pre></td></tr></table></figure>

<p>由于我们的 web-vscode 是运行在容器内的，所以很多环境我们需要自己配置，参考上述操作。</p>
<h2 id="redis-web-管理工具"><a href="#redis-web-管理工具" class="headerlink" title="redis web 管理工具"></a>redis web 管理工具</h2><p>mac 上 redis 管理工具破解版不好找，但是在 github 上找到了一个开源的工具，非常方便。拿来用一下</p>
<blockquote>
<p>传送门: <a href="https://github.com/erikdubbelboer/phpRedisAdmin" target="_blank" rel="noopener">phpRedisAdmin</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull erikdubbelboer/phpredisadmin</span><br><span class="line">docker run --rm -itd -e REDIS_1_HOST=redis -e REDIS_1_NAME=myredis  -p 8015:80  --link redis-test:redis --name redisadmin erikdubbelboer/phpredisadmin</span><br><span class="line"><span class="comment"># 需要注意的是 REDIS_1_HOST 填写的是自己 redis 服务器的地址</span></span><br><span class="line"><span class="comment"># 这里我采用的是容器链接的方式</span></span><br></pre></td></tr></table></figure>

<h3 id="redis-amp-redis可视化工具"><a href="#redis-amp-redis可视化工具" class="headerlink" title="redis &amp; redis可视化工具"></a>redis &amp; redis可视化工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br><span class="line">docker run -p 127.0.0.1:6379:6379 -d --name redis redis --requirepass &quot;mypassword&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看redis的ip地址 172.17.0.2</span><br><span class="line">docker inspect redis | grep -ai &apos;ipa&apos;</span><br><span class="line">docker run --rm -it -e REDIS_1_HOST=172.17.0.2 -e REDIS_1_NAME=redis -p 80:80 erikdubbelboer/phpredisadmin</span><br></pre></td></tr></table></figure>



<h2 id="php-LAMP-环境搭建"><a href="#php-LAMP-环境搭建" class="headerlink" title="php LAMP 环境搭建"></a>php LAMP 环境搭建</h2><p>利用 <code>docker</code> 搭建 LAMP 环境本身应该是比较省力气的方式，但是网上 <code>CSDN</code> 之类的教程很多都是复制黏贴，很多实现不了，优质教程很少。目前发现了国外的一个 <code>linode</code> 的 docke r镜像，有非常详细的教程，很好用。</p>
<blockquote>
<p>linode 详细配置，请看</p>
<ul>
<li><a href="https://hub.docker.com/r/linode/lamp" target="_blank" rel="noopener">https://hub.docker.com/r/linode/lamp</a></li>
<li><a href="https://www.linode.com/docs/applications/containers/how-to-install-docker-and-deploy-a-lamp-stack/" target="_blank" rel="noopener">https://www.linode.com/docs/applications/containers/how-to-install-docker-and-deploy-a-lamp-stack/</a></li>
</ul>
</blockquote>
<h3 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h3><p>docker 环境搭建请看我的 <a href="https://ppsteven.github.io/2020/01/12/centos-install-introduction/">Centos 环境配置（持续总结）</a> 这一篇教程</p>
<h3 id="拉取docker镜像"><a href="#拉取docker镜像" class="headerlink" title="拉取docker镜像"></a>拉取docker镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker search -s 10 lamp</span></span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mattrayner/lamp     A simple LAMP docker image running the prere…   211                                     [OK]</span><br><span class="line">linode/lamp         LAMP on Ubuntu 14.04.1 LTS Container            178</span><br><span class="line">... linode 的镜像 star数还是比较高的</span><br><span class="line"><span class="comment"># sudo docker pull linode/lamp</span></span><br></pre></td></tr></table></figure>

<h3 id="生成配置文件目录"><a href="#生成配置文件目录" class="headerlink" title="生成配置文件目录"></a>生成配置文件目录</h3><p>这一步很多教程里面都缺失的一部分，lamp 的很多文件需要映射到宿主机，方法后面的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动进入容器 </span></span><br><span class="line">$ docker run -itd --name lamp linode/lamp:latest /bin/bash</span><br><span class="line"><span class="comment"># 将需要映射的文件拷贝出来，主要就是 apache2, mysql的配置文件 和 www文件夹</span></span><br><span class="line">.</span><br><span class="line">├── apache2.conf</span><br><span class="line">├── my.cnf</span><br><span class="line">└── www</span><br><span class="line">    ├── example.com</span><br><span class="line">    │   ├── backups</span><br><span class="line">    │   ├── <span class="built_in">log</span></span><br><span class="line">    │   └── public_html</span><br><span class="line">    └── html</span><br><span class="line">        └── index.html</span><br><span class="line"> </span><br><span class="line">$ docker cp lamp:/var/www /Users/xxx/Documents/Dockerfile/lamp/www</span><br><span class="line">$ docker cp lamp:/etc/apache2/apache2.conf  /Users/xxx/Documents/Dockerfile/lamp/apache2.conf</span><br><span class="line">$ docker cp lamp:/etc/mysql/my.cnf /Users/xxx/Documents/Dockerfile/lamp/my.cnf</span><br><span class="line"><span class="comment"># 删除旧的容器</span></span><br><span class="line">$ docker container rm -f lamp</span><br></pre></td></tr></table></figure>



<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 8010:80 -p 3309:3306 \</span><br><span class="line">         -v /Users/ppsteven/Documents/Dockerfile/lamp/www:/var/www \</span><br><span class="line">         -v /Users/ppsteven/Documents/Dockerfile/lamp/apache2.conf:/etc/apache2/apache2.conf \</span><br><span class="line">         -v /Users/ppsteven/Documents/Dockerfile/lamp/my.cnf:/etc/mysql/my.cnf \</span><br><span class="line">         --name lamp \</span><br><span class="line">         -itd linode/lamp:latest /bin/bash</span><br></pre></td></tr></table></figure>



<h3 id="启动-Apache-和-MySQL-服务"><a href="#启动-Apache-和-MySQL-服务" class="headerlink" title="启动 Apache 和 MySQL 服务"></a>启动 Apache 和 MySQL 服务</h3><p>容器内部的 Apache 和 MySQL 服务是默认不自动启动的（当 LAMP 重启的时候需要注意查看这两个服务是否也启动了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line">service mysql start</span><br></pre></td></tr></table></figure>



<h3 id="MySQL-初始化配置"><a href="#MySQL-初始化配置" class="headerlink" title="MySQL 初始化配置"></a>MySQL 初始化配置</h3><p>这一步是很多地方没有提的，linode 的 MySQL 是有默认密码，<code>Admin2015</code>。我们需要初始化对于 MySQL 数据库的配置。</p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/111605563" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111605563</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如下命令即可</span></span><br><span class="line">mysql_secure_installation</span><br><span class="line">按下回城键你会看见结尾如下的对话。</span><br><span class="line"></span><br><span class="line">Enter current password <span class="keyword">for</span> root (enter <span class="keyword">for</span> none): <span class="comment">#</span></span><br><span class="line">Set root password? <span class="comment"># 是否设置root用户密码  y</span></span><br><span class="line">New password: <span class="comment"># 新密码</span></span><br><span class="line">Re-enter new password: </span><br><span class="line">Remove anonymous users? [Y/n] <span class="comment"># 是否删除匿名用户，回车 y</span></span><br><span class="line">Disallow root login remotely? [Y/n] <span class="comment"># 是否禁止root远程登录</span></span><br><span class="line">Remove <span class="built_in">test</span> database and access to it? [Y/n] <span class="comment"># 是否删除test数据库</span></span><br><span class="line">Reload privilege tables now? [Y/n] <span class="comment"># 是否重新加载权限表  y</span></span><br><span class="line">All <span class="keyword">done</span>! If you’ve completed all of the above steps, your MariaDB</span><br><span class="line">installation should now be secure.</span><br><span class="line">Thanks <span class="keyword">for</span> using MariaDB!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试登录</span></span><br><span class="line">mysql -uroot -p<span class="string">"自己的数据库密码"</span></span><br></pre></td></tr></table></figure>



<h3 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h3><p>游览器输入 <a href="http://localhost:8010/" target="_blank" rel="noopener">http://localhost:8010/</a> ，看到如下信息，表示成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The Docker LAMP stack is working.</span><br><span class="line">The configuration information can be found here or here</span><br><span class="line">This index.html file is located in the &quot;/var/www/example.com/public_html&quot; directory.</span><br></pre></td></tr></table></figure>



<h2 id="排查问题方法"><a href="#排查问题方法" class="headerlink" title="排查问题方法"></a>排查问题方法</h2><h3 id="docker-退出"><a href="#docker-退出" class="headerlink" title="docker 退出"></a>docker 退出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 千万不要用 exit，容器会跟着退出的</span><br><span class="line">CTRL + P + Q</span><br></pre></td></tr></table></figure>

<h3 id="docker-ip查看"><a href="#docker-ip查看" class="headerlink" title="docker ip查看"></a>docker ip查看</h3><ol>
<li><p>进入容器查看，这种方法可能会失败，因为可能容器的系统中没有对应的命令工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -ti &lt;NAME OR ID&gt; /bin/bash</span><br><span class="line"># ifconfig/ip addr</span><br></pre></td></tr></table></figure>
</li>
<li><p>最正统的写法(可以写在 shell 脚本里)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker inspect --format '&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;' 2e23d01384ac</span></span><br><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>最简单查询的写法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect lamp | grep -ai <span class="string">'ipa'</span></span><br><span class="line">            <span class="string">"SecondaryIPAddresses"</span>: null,</span><br><span class="line">            <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.2"</span>,</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: null,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.2"</span>,</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="docker-日志排查（tail-f-dev-null）"><a href="#docker-日志排查（tail-f-dev-null）" class="headerlink" title="docker 日志排查（tail -f /dev/null）"></a>docker 日志排查（tail -f /dev/null）</h3><p>利用 <code>tail -f /dev/null</code> 长命令阻塞，不让容器立马结束，这种用法非常好用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ti &lt;NAME OR ID&gt; tail -f /dev/null</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker, mysql, redis, ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>python并发编程——多线程编程 threading 协程</title>
    <url>/2020/06/07/python-threading-basic/</url>
    <content><![CDATA[<p>Python 并发编程可以分为三块：多进程编程，多线程编程，多协程编程。之前一篇文章已经讲解过了 <strong>多进程编程 multiprocessing</strong> 的用法，threading 的使用基本上和 multiprocessing 的差别不大，由于协程是共享同一个进程下的内存地址，所以无需使用 Manager/Array/Values 这种进程间通信的方法，更加简单。</p>
<p>本章主要介绍</p>
<ul>
<li>多线程threading 的基本使用方法</li>
<li>GIL锁概念</li>
</ul>
<a id="more"></a>

<h2 id="threading-库使用"><a href="#threading-库使用" class="headerlink" title="threading 库使用"></a>threading 库使用</h2><p>基本使用方法和 multiprocessing 一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"线程 %s 正在运行"</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = threading.Thread(target=worker, args=(i,))</span><br><span class="line">        t.start() <span class="comment">#启动线程，即让线程开始执行</span></span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threading</span>.<span class="title">Thread</span><span class="params">(group=None, target=None, name=None, args=<span class="params">()</span>, kwargs=&#123;&#125;, *, daemon=None)</span>¶</span></span><br></pre></td></tr></table></figure>

<ul>
<li>group 兼容逻辑，始终设置为默认 None</li>
<li>target 目标函数</li>
<li>args 传入tuple参数</li>
<li>kwargs 传入字典参数</li>
<li>name 线程名称，默认会自动起一个 <code>Thread-N</code> 的名字</li>
<li>daemon 守护线程</li>
</ul>
<h4 id="属性-amp-方法"><a href="#属性-amp-方法" class="headerlink" title="属性 &amp; 方法"></a>属性 &amp; 方法</h4><ul>
<li><p>ident 线程标识符<br>get_ident() </p>
</li>
<li><p>name &amp; get_name() &amp; setName() 获取/设置进程名</p>
</li>
<li><p>daemon &amp; isDaemon() &amp; setDaemon() 设置/判断 守护进程</p>
</li>
<li><p>is_alive() &amp; isAlive() 线程是否存活</p>
</li>
<li><p>join([timeout]) 线程阻塞</p>
</li>
<li><p>start() 和 run() 启动线程</p>
<p>如同进程一样，线程也有两种构造方法。</p>
<p>a. 通过 start() 启动线程，此方法每个线程对象只能调用一次。start()会调用run()方法。</p>
<p>​    标准的run() 方法会执行 target 函数，并使用 args, kwargs参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t = threading.Thread(target=worker, args=(i,))</span><br><span class="line">t.start() #启动线程，即让线程开始执行</span><br></pre></td></tr></table></figure>

<p>b. 通过继承 <code>threading.Thread</code> 的子类重写 <code>run</code> 方法实现我们上面的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreading</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(MyThreading, self).__init__() <span class="comment"># 有两种方法调用父类，注意self的区别</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"线程 %s 正在运行"</span> % self.args)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = MyThreading(i)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<p>或者，更加通用一点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreading</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group=None, target=None, name=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 args=<span class="params">()</span>, kwargs=None, *, daemon=None)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>,</span><br><span class="line">                 args=(), kwargs=<span class="literal">None</span>, daemon=<span class="literal">None</span>)</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line">        self.func = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.func(*self.args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = MyThreading(target=worker, args=(i,))</span><br><span class="line">        t.start() <span class="comment">#启动线程，即让线程开始执行</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="threading-提供的方法"><a href="#threading-提供的方法" class="headerlink" title="threading 提供的方法"></a>threading 提供的方法</h4><ul>
<li><p>threading.active_count() 当前存活的线程数目</p>
<p>len(threading.enumerate()) 也可以计算出相同的结果</p>
</li>
<li><p>threading.current_thread()  当前正在执行的线程对象</p>
</li>
<li><p>threading.enumerate() 当前活着的线程列表</p>
</li>
<li><p>threading.main_thread() 主线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; threading.enumerate())</span><br><span class="line">[&lt;_MainThread(MainThread, started <span class="number">4573310400</span>)&gt;, &lt;MyThreading(Thread<span class="number">-1</span>, started <span class="number">123145406984192</span>)&gt;, &lt;MyThreading(Thread<span class="number">-2</span>, started <span class="number">123145412239360</span>)&gt;, &lt;MyThreading(Thread<span class="number">-3</span>, started <span class="number">123145417494528</span>)&gt;, &lt;MyThreading(Thread<span class="number">-4</span>, started <span class="number">123145422749696</span>)&gt;, &lt;MyThreading(Thread<span class="number">-5</span>, started <span class="number">123145428004864</span>)&gt;]</span><br><span class="line">&gt;&gt; threading.main_thread()</span><br><span class="line">&lt;_MainThread(MainThread, started <span class="number">4573310400</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到我们有一个主线程和程序运行中自主创建的5个子线程</p>
</li>
</ul>
<blockquote>
<p>线程 threading 和 mutiprocessing 异同</p>
<ul>
<li><p>没有线程池</p>
</li>
<li><p>线程间共享全局变量，没有多进程间复杂的沟通方式</p>
</li>
<li><p>共享全局变量依旧会存在冲突的问题，使用的方法为互斥锁</p>
<p>Lock, RLock, Condtion, Semaphore, Event. Barrier<br>这一部分和 mutiprocessing一样</p>
</li>
</ul>
</blockquote>
<h2 id="GIL-锁"><a href="#GIL-锁" class="headerlink" title="GIL 锁"></a>GIL 锁</h2><h3 id="GIL的基本概念"><a href="#GIL的基本概念" class="headerlink" title="GIL的基本概念"></a>GIL的基本概念</h3><blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<p><strong>GIL(Global Interpreter Lock)，中文译为全局解释器锁。</strong></p>
<p>Python 虽然是近年来非常火的一个语言，但是它并不是一个新语言，1991年第一个Python编译器诞生。那时候的计算机大多是单核CPU，也就不存在并行计算的问题。随着CPU性能的提升，单核CPU逐渐被多核CPU替代。随着而来的问题是，如何保持数据间的一致性。解决的最简单的方法是加锁，只是Python的这把锁太大了点。</p>
<p>GIL本质上类似操作系统的 Mutex。GIL 的功能是：在 CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。</p>
<h3 id="GIL的工作原理"><a href="#GIL的工作原理" class="headerlink" title="GIL的工作原理"></a>GIL的工作原理</h3><p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200607024751.png" alt="GIL工作原理"></p>
<p>可以看到 Thread 1 和 Thread 3 并不是一次性执行完的，而是线程会主动释放。这里的原因是CPython中存在一个叫做 <code>间隔式检查（check_interval）</code> 的机制。CPython 解释器会轮询线程，每隔一段时间，CPython 就会强制当前线程释放GIL锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200607030558.png" alt=""></p>
<p><strong>这和CPU时间片的概念一样</strong> 在Python3 中，“时间片”大致为15毫秒。 </p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用-multiprocessing-替代-threading"><a href="#使用-multiprocessing-替代-threading" class="headerlink" title="使用 multiprocessing 替代 threading"></a>使用 multiprocessing 替代 threading</h3><blockquote>
<p>multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。</p>
<p>– 作者：<a href="https://www.jianshu.com/p/756c505ab828" target="_blank" rel="noopener">rookieyu</a></p>
</blockquote>
<p>multiprocessing 的问题在于，其占用的资源是高于多线程的。而且由于进程间不能读取对方的地址空间，导致了多进程沟通是较为复杂的，这个额外的成本使得原本就非常复杂的多线程编程变得更加困难了点。</p>
<p>不过 threading 也并非是一无是处，虽然在CPU 利用率上表现的不尽人意，但是在高I/O操作的时候，多线程可以起到避免阻塞的作用。</p>
<blockquote>
<p>计算密集型使用多进程，I/O密集型使用多线程或者多协程</p>
</blockquote>
<h3 id="改用其他编译器"><a href="#改用其他编译器" class="headerlink" title="改用其他编译器"></a>改用其他编译器</h3><p>使用JPython 或者 IronPython 编译器，可以解决这类问题</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://docs.python.org/zh-cn/3/library/threading.html#threading.Thread.run" target="_blank" rel="noopener">threading— 基于线程的并行</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/38147045" target="_blank" rel="noopener">食之无味，弃之可惜—Python threading——线程对象</a></p>
<p><a href="http://c.biancheng.net/view/5537.html" target="_blank" rel="noopener">Python GIL全局解释器锁详解（深度剖析）</a></p>
<p><a href="https://www.jianshu.com/p/756c505ab828" target="_blank" rel="noopener">rookieyu 简书– GIL</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>mac + VMware + Centos7 下的网络配置</title>
    <url>/2020/05/19/vmware-centos-environment-network/</url>
    <content><![CDATA[<p>本文介绍，如何在 mac 系统下配置一个 无图形化的 centos 环境，难点在于网络配置</p>
<p>教程参考:  <a href="https://www.bilibili.com/video/BV1bA411b7vs" target="_blank" rel="noopener">个人专属多节点Linux环境打造，Linux操作系统学习实验环境安装配置视频教程</a></p>
<p>用到的工具</p>
<ul>
<li><p>centos 系统 </p>
<blockquote>
<p>阿里云站点: <a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/" target="_blank" rel="noopener">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></p>
<p>各个版本的ISO镜像文件说明：</p>
<p>CentOS-7-x86_64-DVD-1708.iso        标准安装版（推荐）</p>
<p>CentOS-7-x86_64-Everything-1708.iso    完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像）</p>
<p>CentOS-7-x86_64-LiveGNOME-1708.iso     GNOME桌面版  </p>
<p>CentOS-7-x86_64-LiveKDE-1708.iso      KDE桌面版  </p>
<p>CentOS-7-x86_64-Minimal-1708.iso      精简版，自带的软件最少</p>
<p>CentOS-7-x86_64-NetInstall-1708.iso    网络安装版（从网络安装或者救援系统）</p>
<p>作者：Ada54<br>链接：<a href="https://www.jianshu.com/p/a63f47e096e8" target="_blank" rel="noopener">https://www.jianshu.com/p/a63f47e096e8</a></p>
</blockquote>
<p>这里 <code>CentOS-7-x86_64-DVD-1708.iso</code> 是标准安装版，如果选择最小安装，和 <code>CentOS-7-x86_64-Minimal-1708.iso</code> (无界面版本)一样。</p>
</li>
<li><p>vmware 或者 virtualbox </p>
</li>
<li><p>finalShell/terminal</p>
</li>
</ul>
<a id="more"></a>

<p>安装完 Linux 后的网络是默认不通的，为了使网络连通</p>
<h2 id="设置桥接模式"><a href="#设置桥接模式" class="headerlink" title="设置桥接模式"></a>设置桥接模式</h2><p>在虚拟机挂机的情况下</p>
<blockquote>
<p>虚拟机 -&gt; 网络适配器 -&gt; 桥接模式 -&gt; 勾选 Wi-Fi 模式</p>
</blockquote>
<p>勾选完毕后，我们就可以看到 IP 和 子网 掩码，</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200519012620.png" alt=""></p>
<p>这个 ip 和 子网掩码 同样也是 <code>宿主机</code> 的 ip 和 子网掩码</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200519013251.png" alt=""></p>
<h2 id="分配静态地址"><a href="#分配静态地址" class="headerlink" title="分配静态地址"></a>分配静态地址</h2><p>由于虚拟机默认的是走的 DHCP，我们需要主动请求去获取 ip 地址。我们在使用虚拟机的时候肯定是希望一个固定的 ip。</p>
<p>利用 <code>dhclient</code> 命令可以主动向 DHCP 服务器获取一个 ip 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># dhclient</span></span><br><span class="line">[root@192 ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:45:4d:90 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.8/24 brd 192.168.1.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 2409:8a1e:5e7a:f280:c9ed:976f:94f1:9901/64 scope global noprefixroute dynamic </span><br><span class="line">       valid_lft 209430sec preferred_lft 123030sec</span><br><span class="line">    inet6 fe80::9f8c:26f6:3c23:c4d3/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>我们获得了一个 ip 地址 <code>192.168.1.8</code></p>
<h2 id="设置固定-ip"><a href="#设置固定-ip" class="headerlink" title="设置固定 ip"></a>设置固定 ip</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote>
<ol>
<li>如果你上面的静态 ip 没有主动分配的话，直接在本小节中修改配置也是可以的。<br>但是这样做的话，你需要设置一个比较大的 ip，如 192.168.0.20。这是因为在同一个局域网下，可能有别的设备（手机，平板）占用了某个 ip 地址，你需要去避开这一点。</li>
<li>需要切换成 root 账号去操作</li>
</ol>
</blockquote>
<h3 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># vi /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none </span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line"><span class="deletion">- BOOTPROTO=dhcp</span></span><br><span class="line"><span class="addition">+ BOOTPROTO=static # 默认是 dhcp</span></span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=5bf952f3-8b37-4ded-b5bc-79ce0676e69d</span><br><span class="line">DEVICE=ens33</span><br><span class="line"><span class="deletion">- ONBOOT=no # 默认是no</span></span><br><span class="line"><span class="addition">+ ONBOOT=yes # 默认是no</span></span><br><span class="line"><span class="addition">+ IPADDR=192.168.1.8 # 填写刚刚分配给我们的 ip地址</span></span><br><span class="line"><span class="addition">+ NETMASK=255.255.255.0 # 填写刚刚查到的 子网掩码</span></span><br><span class="line"><span class="addition">+ GATEWAY=192.168.1.1 # 子网掩码 + ip 可得</span></span><br><span class="line"><span class="addition">+ DNS1=192.168.1.1 # 这里填写的 mac 上的 dns 服务器 mac-&gt;网络偏好设置-&gt;高级-&gt;DNS 可以查到</span></span><br></pre></td></tr></table></figure>

<h3 id="DNS服务器地址"><a href="#DNS服务器地址" class="headerlink" title="DNS服务器地址"></a>DNS服务器地址</h3><p>打开【系统偏好设置】-【网络】- 选中【Wi-Fi】项（如果您是WIFI上网请选择此项）- 点右侧【高级】<br>选择【TCP/IP】选项卡，记录好【子网掩码】、【路由器】地址、DNS选项卡下的DNS服务器地址（如果DNS服务器地址没有配置，也可以给配置个8.8.8.8）</p>
<h2 id="网络重启"><a href="#网络重启" class="headerlink" title="网络重启"></a>网络重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure>

<h2 id="查看是否连通"><a href="#查看是否连通" class="headerlink" title="查看是否连通"></a>查看是否连通</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (36.152.44.95) 56(84) bytes of data.</span><br><span class="line">64 bytes from 36.152.44.95 (36.152.44.95): icmp_seq=1 ttl=56 time=11.3 ms</span><br><span class="line">64 bytes from 36.152.44.95 (36.152.44.95): icmp_seq=2 ttl=56 time=11.2 ms</span><br><span class="line">64 bytes from 36.152.44.95 (36.152.44.95): icmp_seq=3 ttl=56 time=65.8 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2003ms</span><br><span class="line">rtt min/avg/max/mdev = 11.281/29.502/65.882/25.724 ms</span><br></pre></td></tr></table></figure>

<h2 id="有界面版如果切换成无界面"><a href="#有界面版如果切换成无界面" class="headerlink" title="有界面版如果切换成无界面"></a>有界面版如果切换成无界面</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">set</span>-default multi-user.target (关闭图形界面) <span class="comment"># 执行以后,输入命令 reboot 重启机器就可以</span></span><br><span class="line">$ systemctl <span class="built_in">set</span>-default graphical.target (开启图形界面) <span class="comment"># 执行以后,输入命令 reboot 重启机器就可以</span></span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000015227575" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015227575</a></p>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记:《剑指 Offer》</title>
    <url>/2020/05/14/jz-offer-solution/</url>
    <content><![CDATA[<p>用言简意赅的方法记录 《剑指》，作为复习《剑指offer》的笔记</p>
<a id="more"></a>

<h2 id="面试题03-数据中的重复数字"><a href="#面试题03-数据中的重复数字" class="headerlink" title="面试题03. 数据中的重复数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03. 数据中的重复数字</a></h2><h3 id="Best-Answer【利用下表法】"><a href="#Best-Answer【利用下表法】" class="headerlink" title="Best Answer【利用下表法】"></a>Best Answer【利用下表法】</h3><ul>
<li><p>解题思路：</p>
<p>利用 <code>nums 里的所有数字都在 0～n-1 的范围内</code> 这一条件，表示 <code>每个数字都只有一个坑位，一个坑位上不能有两个数字</code> </p>
<blockquote>
<p>时间复杂度 O(n) 空间复杂度O(1)</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">           <span class="keyword">while</span> i != nums[i]:</span><br><span class="line">               <span class="keyword">if</span> nums[i] == nums[nums[i]]: <span class="keyword">return</span> nums[i]</span><br><span class="line">               <span class="comment"># 原地交换</span></span><br><span class="line">               temp = nums[i]</span><br><span class="line">               nums[i] = nums[nums[i]]</span><br><span class="line">               nums[temp] = temp</span><br></pre></td></tr></table></figure>

<ul>
<li><p>交换数组的时候，需要注意利用 python 便捷的交换方式存在陷阱</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确方法一：</span></span><br><span class="line">temp = nums[i]</span><br><span class="line">nums[i] = nums[nums[i]]</span><br><span class="line">nums[temp] = temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确方法二：</span></span><br><span class="line">nums[nums[i]] , nums[i] = nums[i] , nums[nums[i]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误方式：</span></span><br><span class="line">nums[i], nums[nums[i]] = nums[nums[i]], nums[i]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Other-Answer【哈希表法】"><a href="#Other-Answer【哈希表法】" class="headerlink" title="Other Answer【哈希表法】"></a>Other Answer【哈希表法】</h3><ul>
<li><p>解题思路：<code>哈希表</code></p>
<blockquote>
<p>时间复杂度 O(n) 空间复杂度O(n)</p>
</blockquote>
<p>Python的实现哈希表的方式是通过 <code>字典</code> 和 <code>集合</code> 的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基于集合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       s = set()</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">           <span class="keyword">if</span> i <span class="keyword">in</span> s: <span class="keyword">return</span> i</span><br><span class="line">           <span class="keyword">else</span>: s.add(i)</span><br><span class="line"><span class="comment"># 基于字典</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       s = dict()</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">           <span class="keyword">if</span> i <span class="keyword">in</span> s: <span class="keyword">return</span> i</span><br><span class="line">           <span class="keyword">else</span>: s[i] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04. 二维数组中的查找</a></h2><blockquote>
<p>同 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a></p>
</blockquote>
<h3 id="Best-Answer【左下-右上元素移动法】"><a href="#Best-Answer【左下-右上元素移动法】" class="headerlink" title="Best Answer【左下/右上元素移动法】"></a>Best Answer【左下/右上元素移动法】</h3><ul>
<li><p>解题思路：</p>
<p>左下、右上角的特点是，排除式查找。</p>
<blockquote>
<p>时间复杂度 O(行高+列宽) 空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 以右上角为例</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(matrix) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target: i += <span class="number">1</span> <span class="comment"># 比目标值小，向下一行查找</span></span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span> <span class="comment"># 比目标值大，向上一行查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Other-Answer-【双折半查找】"><a href="#Other-Answer-【双折半查找】" class="headerlink" title="Other Answer 【双折半查找】"></a>Other Answer 【双折半查找】</h3><ul>
<li><p>解题思路 <code>折半法</code></p>
<blockquote>
<p>参考：<a href="https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318" target="_blank" rel="noopener">https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318</a></p>
<p>时间复杂度：O(logM + logN) 复杂度最坏情况为O(M * logN)</p>
</blockquote>
<p>二维数组分为上下左右四个边界top，bottom，left，right：</p>
<ul>
<li>根据上边界折半查找——确定 right 范围</li>
<li>根据下边界折半查找——确定 left 范围</li>
<li>根据左边界折半查找——确定 top 范围</li>
<li>根据右边界折半查找——确定 bottom 范围</li>
</ul>
<p>最直接的方法，代码量大，考察基本功</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(array[<span class="number">0</span>]) - <span class="number">1</span> </span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        bottom = len(array) - <span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right <span class="keyword">or</span> top &lt; bottom):</span><br><span class="line">             <span class="comment"># 对上边界进行折半，可以缩小右边界</span></span><br><span class="line">             l = left</span><br><span class="line">             r = right</span><br><span class="line">             <span class="keyword">while</span> (l &lt;= r):</span><br><span class="line">                  mid = (l+r) // <span class="number">2</span></span><br><span class="line">                  <span class="keyword">if</span> array[top][mid] == target:</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                  <span class="keyword">elif</span> array[top][mid] &gt; target:</span><br><span class="line">                       r = mid - <span class="number">1</span></span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                       l = mid + <span class="number">1</span></span><br><span class="line">             <span class="keyword">if</span> (mid &lt; right):</span><br><span class="line">                  right = mid</span><br><span class="line">             top += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 对下边界进行折半，可以缩小左边界</span></span><br><span class="line">             l = left</span><br><span class="line">             r = right</span><br><span class="line">             <span class="keyword">while</span> (l &lt;= r):</span><br><span class="line">                  mid = (l + r) // <span class="number">2</span> </span><br><span class="line">                  <span class="keyword">if</span> array[bottom][mid] == target:</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                  <span class="keyword">elif</span> array[bottom][mid] &gt; target:</span><br><span class="line">                       r = mid - <span class="number">1</span> </span><br><span class="line">                  <span class="keyword">else</span>: </span><br><span class="line">                       l = mid + <span class="number">1</span> </span><br><span class="line">             <span class="keyword">if</span> (mid &gt; left):</span><br><span class="line">                 left = mid </span><br><span class="line">             bottom -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 对左边界进行折半，可以缩小下边界</span></span><br><span class="line">             t = top</span><br><span class="line">             b = bottom</span><br><span class="line">             <span class="keyword">while</span> (t &lt;= b):</span><br><span class="line">                 mid = (t + b) // <span class="number">2</span> </span><br><span class="line">                 <span class="keyword">if</span> array[mid][left] == target:</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                 <span class="keyword">elif</span> array[mid][left] &gt; target:</span><br><span class="line">                      b = mid - <span class="number">1</span> </span><br><span class="line">                 <span class="keyword">else</span>: </span><br><span class="line">                      t = mid + <span class="number">1</span> </span><br><span class="line">             <span class="keyword">if</span> (t &lt; mid):</span><br><span class="line">                 t = mid</span><br><span class="line">             left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># 对右边界进行折半，可以缩小上边界</span></span><br><span class="line">             t = top</span><br><span class="line">             b = bottom</span><br><span class="line">             <span class="keyword">while</span> (t &lt;= b):</span><br><span class="line">                mid = (t + b) // <span class="number">2</span> </span><br><span class="line">                <span class="keyword">if</span> array[mid][right] == target:</span><br><span class="line">                     <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> array[mid][right] &gt; target:</span><br><span class="line">                     b = mid - <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                     t = mid + <span class="number">1</span> </span><br><span class="line">             <span class="keyword">if</span> (b &gt; mid):</span><br><span class="line">                 b = mid </span><br><span class="line">             right -= <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ret = Solution().Find(<span class="number">7</span>,[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>]])</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure>

<h2 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05. 替换空格</a></h2><ul>
<li>解题思路： <code>字符串相关操作</code></li>
</ul>
<h2 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h2><ul>
<li><p>递归法</p>
<p>递归是由计算机帮助实现 “栈” 结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.next) + [head.val]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据结构——栈 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            stack.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">       <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></h2><h3 id="Best-Answer"><a href="#Best-Answer" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路:</p>
<ul>
<li><p>数据结构——二叉树</p>
<p>根据 pre 确定 根节点</p>
<p>根据 vin 确定左右子树的大小</p>
</li>
<li><p>递归编程</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200512123358.png" style="zoom:50%;" />

<ul>
<li><p>注意点</p>
<p>需要根据中序遍历结果，确定左子树长度  <code>tin.index(value)</code> </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">          self.val = x</span><br><span class="line">          self.left = <span class="literal">None</span></span><br><span class="line">          self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">0</span> :</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span> :</span><br><span class="line">           <span class="keyword">return</span> TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        value = pre[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(value)</span><br><span class="line">        <span class="comment"># 截取左子树</span></span><br><span class="line">        preLeft = pre[<span class="number">1</span>:tin.index(value) + <span class="number">1</span>] <span class="comment"># 先序遍历，从第二个开始截图 左子树长度的 数组</span></span><br><span class="line">        tinLeft = tin[:tin.index(value)] <span class="comment"># 中序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 截取右子树</span></span><br><span class="line">        preRight = pre[tin.index(value) + <span class="number">1</span>:] <span class="comment"># 先序遍历， 左子树后的数组元素是 右子树</span></span><br><span class="line">        tinRight = tin[tin.index(value) + <span class="number">1</span>:] <span class="comment"># 中序遍历</span></span><br><span class="line"></span><br><span class="line">        root.left = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        root.right = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sol = Solution().reConstructBinaryTree([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br><span class="line">    print(sol)</span><br></pre></td></tr></table></figure>



<h2 id="面试题09-用两个栈实现一个队列"><a href="#面试题09-用两个栈实现一个队列" class="headerlink" title="面试题09. 用两个栈实现一个队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现一个队列</a></h2><h3 id="Best-Answer-1"><a href="#Best-Answer-1" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路:<br><strong>栈是后进先出(LIFO)，队列是先进先出(FIFO)。</strong><br>可以使用2个栈来表示，一个表示入栈，还有一个表示出栈，出栈的顺序与入栈的顺序相反。</p>
<p>第一个栈弹出后压入第二个栈就可以了</p>
</li>
<li><p>python 栈 &amp; 队列 实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python 栈实现</span></span><br><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">1</span>) <span class="comment"># 入栈</span></span><br><span class="line">stack.pop() <span class="comment"># 出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 队列实现</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line">queue = deque([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]) </span><br><span class="line">queue.append(<span class="string">'D'</span>) <span class="comment"># 入队</span></span><br><span class="line">queue.popleft() <span class="comment"># 出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># item = [] 这样的用法是错误的，因为此时有两个栈实例都会使用此变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       self.item = [] </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.item.append(node)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        v = self.item.pop()</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.item)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.length &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>图解</p>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/fu-zhu-zhan-python3-c-by-z1m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/fu-zhu-zhan-python3-c-by-z1m/</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200703134155.png" alt=""></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># s1 用于存储，相当于仓库; s2 用于输出</span></span><br><span class="line">        self.s1, self.s2 = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.s1.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.s2: <span class="keyword">return</span> self.s2.pop() </span><br><span class="line">        <span class="keyword">while</span> self.s1: <span class="comment"># 如果 s1 为空，尝试把 s2 数据换过来</span></span><br><span class="line">            self.s2.append(self.s1.pop())</span><br><span class="line">        <span class="keyword">if</span> self.s2: <span class="keyword">return</span> self.s2.pop() <span class="comment"># 再次尝试取数据</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="面试10-I-斐波那契数列【动态规划经典】"><a href="#面试10-I-斐波那契数列【动态规划经典】" class="headerlink" title="面试10- I. 斐波那契数列【动态规划经典】"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试10- I. 斐波那契数列【动态规划经典】</a></h2><h2 id="面试10-II-青蛙跳台阶问题【动态规划经典】"><a href="#面试10-II-青蛙跳台阶问题【动态规划经典】" class="headerlink" title="面试10- II. 青蛙跳台阶问题【动态规划经典】"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">面试10- II. 青蛙跳台阶问题【动态规划经典】</a></h2><h3 id="Best-Answer【动态规划】"><a href="#Best-Answer【动态规划】" class="headerlink" title="Best Answer【动态规划】"></a>Best Answer【动态规划】</h3><ul>
<li><p>解题思路：<code>动态规划</code>动态规划解析：</p>
<blockquote>
<p>作者：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener">jyd</a></p>
<p>时间复杂度：O(n) 空间复杂度O(n)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200703145136.png" alt=""></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        fibArr = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            fibArr.append(fibArr[i - <span class="number">1</span>] + fibArr[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> fibArr[n] % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>



<h3 id="Other-Answer-【循环求余法】"><a href="#Other-Answer-【循环求余法】" class="headerlink" title="Other Answer 【循环求余法】"></a>Other Answer 【循环求余法】</h3><ul>
<li><p>解题速率：<code>动态规划的改进</code> </p>
<blockquote>
<p>作者：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener">jyd</a></p>
<p>时间复杂度：O(n)   <strong>空间复杂度O(1)</strong></p>
</blockquote>
<p>动态规划的空间复杂度 O(n) ，可以不存储中间结果。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<h3 id="Other-Answer【分治法-记忆化搜索】"><a href="#Other-Answer【分治法-记忆化搜索】" class="headerlink" title="Other Answer【分治法+记忆化搜索】"></a>Other Answer【分治法+记忆化搜索】</h3><ul>
<li><p>解题思路： <code>分治法</code> + <code>记忆化搜索</code></p>
<p>传统的分治法会产生大量重复计算，一定会超时。通过将结果固定下来可以加快运算速度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">F</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> memory: <span class="keyword">return</span> memory[n]</span><br><span class="line">            value = F(n<span class="number">-1</span>) + F(n<span class="number">-2</span>)</span><br><span class="line">            memory[n] = value </span><br><span class="line">            <span class="keyword">return</span> memory[n]</span><br><span class="line">        memory = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> F(n) % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题11-旋转数组的最小数字【中高难】"><a href="#面试题11-旋转数组的最小数字【中高难】" class="headerlink" title="面试题11. 旋转数组的最小数字【中高难】"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11. 旋转数组的最小数字【中高难】</a></h2><h3 id="Best-Answer【变形二分查找】"><a href="#Best-Answer【变形二分查找】" class="headerlink" title="Best Answer【变形二分查找】"></a>Best Answer【变形二分查找】</h3><ul>
<li><p>解题思路：</p>
<blockquote>
<p>时间复杂度O(n)  空间复杂度 O(1) </p>
</blockquote>
<p>变形的二分查找，但是有一些坑</p>
<p>a. 正确情况下的二分查找</p>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200513113239.png" style="zoom: 67%;" />

<p>b. 特殊情况</p>
<p>当出现重复数字情形的时候，<strong>直接缩小左边界（因为最小值总是在右侧出现）</strong></p>
<p>情形4 可以适应非递增数列的最小值为队首元素的情形。最后的代码非常巧妙</p>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200513113538.png" style="zoom:67%;" />

</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(rotateArray) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right: <span class="comment"># 不能是 &lt;=</span></span><br><span class="line">            <span class="comment"># 加入特殊情况，非递减数组的最小值就是队首</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[left] &lt; rotateArray[right]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[left]</span><br><span class="line">            mid = (left + right) // <span class="number">2</span> </span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt; rotateArray[left]:</span><br><span class="line">                 left = mid + <span class="number">1</span>  <span class="comment"># 一般都是在右侧，所以放心加1</span></span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                 right = mid <span class="comment"># 此时 mid 可能是最小值，不能排除</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                 left += <span class="number">1</span>  <span class="comment"># 巧妙避免了offer书上说的坑点（1 0 1 1 1）</span></span><br><span class="line">        <span class="keyword">return</span> rotateArray[left]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二分法解题需要考虑的情况</p>
<ul>
<li><p><code>while left &lt;= right</code> 是错误的</p>
<p>实例：[2,2,2,0,1]  </p>
<p>错误输出 2 ，实际上是 0</p>
</li>
<li><p><code>right = mid</code> 提现了最小值一般是在右侧</p>
</li>
<li><p>考虑到存在有序的情况，单独处理</p>
</li>
</ul>
</li>
</ul>
<h3 id="Other-Answer-【直接搜索】"><a href="#Other-Answer-【直接搜索】" class="headerlink" title="Other Answer 【直接搜索】"></a>Other Answer 【直接搜索】</h3><blockquote>
<p>时间复杂度： O(n)  空间复杂度: O(1)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i<span class="number">-1</span>] &gt; rotateArray[i]:</span><br><span class="line">                <span class="keyword">return</span> rotateArray[i]</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h2 id="面试题12-矩阵中的路径"><a href="#面试题12-矩阵中的路径" class="headerlink" title="面试题12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12. 矩阵中的路径</a></h2><h3 id="Best-Answer-2"><a href="#Best-Answer-2" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li>解题思路:  <code>DFS 深度搜索</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, word)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> word: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 已经找到</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= i &lt;= len(board) - <span class="number">1</span> <span class="keyword">and</span> \</span><br><span class="line">               <span class="number">0</span> &lt;= j &lt;= len(board[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> \</span><br><span class="line">               board[i][j] == word[<span class="number">0</span>]): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            flag.append((i, j)) <span class="comment"># 加入访问过的节点</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> dirction:</span><br><span class="line">                ni, nj = i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> (ni, nj) <span class="keyword">not</span> <span class="keyword">in</span> flag: <span class="comment"># 判断有无走过</span></span><br><span class="line">                     <span class="keyword">if</span> dfs(ni, nj, word[<span class="number">1</span>:]): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            flag.remove((i, j)) <span class="comment"># 走完一定要回溯回状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        dirction = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">        flag = []  <span class="comment"># 标记走过的格子</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, word): </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>重点元素：</p>
<blockquote>
<ul>
<li><p>终止条件 <code>if not word: return True</code> 不能漏掉</p>
</li>
<li><p>访问过的节点矩阵：两种实现方法  <strong>邻接矩阵表示法、稀疏矩阵标识方式</strong></p>
<p> <code>flags = [[0]*ncol for _ in range(nrow)]</code>  ，通过设置 <code>flags[j][i] = True</code></p>
<p><code>flags = [(1, 2), (3,4)]</code></p>
</li>
<li><p>一定要注意结束后 <code>回溯状态</code></p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Graceful-Answer-【精妙写法】"><a href="#Graceful-Answer-【精妙写法】" class="headerlink" title="Graceful Answer 【精妙写法】"></a>Graceful Answer 【精妙写法】</h3><blockquote>
<p>参考自: <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/" target="_blank" rel="noopener">Krahets-Leetcode 题解</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> \</span><br><span class="line">               <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">               board[i][j] != word[k]: </span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 判断都放在这里</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp, board[i][j] = board[i][j], <span class="string">'/'</span> <span class="comment"># 直接修改原矩阵</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = tmp</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">面试题13. 机器人的运动范围</a></h2><h3 id="My-Answer【DFS-深度搜索改进】"><a href="#My-Answer【DFS-深度搜索改进】" class="headerlink" title="My Answer【DFS 深度搜索改进】"></a>My Answer【DFS 深度搜索改进】</h3><ul>
<li><p>解题思路：<code>DFS 深度搜索</code> + <code>剪枝</code></p>
<p>上一题同样是 <code>DFS</code> 算法，其中提到一定要注意 <code>状态回溯</code> 。本题则不同，因为是求的  <strong><em>最多访问到的格子</em></strong>，    <strong><em>最多访问的路径</em></strong>  。所以 辅助矩阵 <code>visited</code> 是记录访问到的格子，最后返回的结果也是 <code>len(visited)</code></p>
<ul>
<li>终止条件： <code>下标越界、题目条件限制、节点已访问</code></li>
<li>计算节点位数和的方法可以尝试 <code>memory</code> 记忆矩阵做缓存</li>
<li>剪枝体现在：根据题意，只需要访问 <code>右</code>、<code>下</code> 两个方向即可。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cal_digit</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> memory:</span><br><span class="line">                ret = sum([int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> str(x)])</span><br><span class="line">                memory[x] = ret</span><br><span class="line">            <span class="keyword">return</span> memory[x]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;=n: <span class="keyword">return</span>  <span class="comment"># 下表越界</span></span><br><span class="line">            <span class="keyword">if</span> cal_digit(i) + cal_digit(j)&gt; k: <span class="keyword">return</span> <span class="comment"># 题目条件限制 </span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">return</span> <span class="comment"># 节点已访问过</span></span><br><span class="line">            visited.append((i, j))</span><br><span class="line">            dfs(i + <span class="number">1</span>, j)</span><br><span class="line">            dfs(i, j + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        visited = []</span><br><span class="line">        memory = &#123;&#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>

<p>计算位数的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环取余</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_digit</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> memory:</span><br><span class="line">        ret, y = <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">while</span> y:</span><br><span class="line">            ret += y % <span class="number">10</span></span><br><span class="line">            y = y // <span class="number">10</span></span><br><span class="line">        memory[x] = ret</span><br><span class="line">    <span class="keyword">return</span> memory[x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_digit</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> memory:</span><br><span class="line">       ret = sum([int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> str(x)])</span><br><span class="line">       memory[x] = ret</span><br><span class="line">    <span class="keyword">return</span> memory[x]</span><br></pre></td></tr></table></figure>

<h3 id="Best-Answer【DFS-深度搜索】"><a href="#Best-Answer【DFS-深度搜索】" class="headerlink" title="Best Answer【DFS 深度搜索】"></a>Best Answer【DFS 深度搜索】</h3><ul>
<li><p>解题思路：<code>DFS 搜索</code> + <code>数位和计算方式改进</code></p>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">Krahets-解题</a></p>
<p><a href="https://krahets.gitee.io/" target="_blank" rel="noopener">Krahets’s Blog</a> 这个大神些的东西，真的比原书的作者写的解法好，而且是python版</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200704123005.png" alt=""></p>
<p>数位和增量公式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s_x + <span class="number">1</span> <span class="keyword">if</span> (x + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> s_x - <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200514214717.png" alt=""> </p>
<p><strong>代码如下【很精妙的写法】：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, si, sj)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj) \</span><br><span class="line">                     + dfs(i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Best-Answer-【BFS-广度搜索】"><a href="#Best-Answer-【BFS-广度搜索】" class="headerlink" title="Best Answer 【BFS 广度搜索】"></a>Best Answer 【BFS 广度搜索】</h3><p>解题思路：<code>BFS 广度搜索</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        queue, visited,  = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], set()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i, j, si, sj = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))</span><br><span class="line">            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))</span><br><span class="line">        <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>



<h2 id="面试题14-I-剪绳子【非常经典】"><a href="#面试题14-I-剪绳子【非常经典】" class="headerlink" title="面试题14- I. 剪绳子【非常经典】"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14- I. 剪绳子【非常经典】</a></h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/" target="_blank" rel="noopener">腐烂的橘子🍊</a></p>
</blockquote>
<h3 id="Answer-01-【暴力法】"><a href="#Answer-01-【暴力法】" class="headerlink" title="Answer 01 【暴力法】"></a>Answer 01 【暴力法】</h3><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200514215522.png" style="zoom: 50%;" />

<p>下面我们手算一下 $F(4)$ 的取值是从 $F(3)\times1, 3 \times 1;F(2)\times 2, 2\times 2;F(1)\times3, 1\times3$ 中挑选出最大的值。可以归纳出如下递归函数</p>
<p>$$<br>F(n)=max(i\times(n-i),i\times F(n-i)),i=1,2,…,n-2<br>$$</p>
<p>暴力法存在大量计算一定会<strong>超时</strong>，所以一般暴力法都是搭配 <code>记忆化矩阵</code> 一起 <code>食用</code></p>
<h3 id="Answer-02-【记忆化搜索】【自顶向下】"><a href="#Answer-02-【记忆化搜索】【自顶向下】" class="headerlink" title="Answer 02 【记忆化搜索】【自顶向下】"></a>Answer 02 【记忆化搜索】【自顶向下】</h3><ul>
<li><p>解题思路：<strong>记忆化技术（自顶向下）</strong></p>
<p>递归函数中存在大量重复的计算，记忆化技术，可以帮助缩小时间，通过计算机验证</p>
<blockquote>
<p>时间复杂度 $O(n^2)$  空间复杂度 $O(n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> memory: <span class="keyword">return</span> memory[n]</span><br><span class="line">            res = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                res = max(res, f(i) * (n - i), i * (n - i))</span><br><span class="line">            memory[n] = res</span><br><span class="line">            <span class="keyword">return</span> memory[n]</span><br><span class="line">        memory = &#123;<span class="number">1</span>: <span class="number">1</span>&#125; <span class="comment"># 可以将终止条件设置在 记忆化矩阵中</span></span><br><span class="line">        <span class="keyword">return</span> f(n)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="Best-Answer-【动态规划】【自底向上】"><a href="#Best-Answer-【动态规划】【自底向上】" class="headerlink" title="Best Answer 【动态规划】【自底向上】"></a>Best Answer 【动态规划】【自底向上】</h3><ul>
<li><p><strong>解题思路：动态规划（自底向上）(推荐方法)</strong></p>
<blockquote>
<p>时间复杂度 <code>O(n)</code> 空间复杂度 O(n)</p>
</blockquote>
<p>动态规划的核心是，设定边界条件 和 状态转移方程 。</p>
<p>建议一维动态数组 <code>dp</code> :</p>
<ul>
<li>边界条件：$dp[1] = dp[2] = 1$ ，表示长度为 2 的绳子最大乘积为 1；</li>
<li>状态转移方程： $dp[i] = max(dp[i], max((i-j)<em>j, j</em>dp[i-j]))$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200704150131.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        d = [ <span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        d[<span class="number">1</span>], d[<span class="number">2</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            res = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                res = max(res, j * (i - j), j * d[i-j])</span><br><span class="line">            d[i] = res</span><br><span class="line">        <span class="keyword">return</span> d[n]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Best-Answer-【动态规划空间优化】【自底向上】"><a href="#Best-Answer-【动态规划空间优化】【自底向上】" class="headerlink" title="Best Answer 【动态规划空间优化】【自底向上】"></a>Best Answer 【动态规划空间优化】【自底向上】</h3><blockquote>
<p>同 面试题10-I 斐波那契数列一样。同样可以针对空间复杂度优化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作者：z1m</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                    <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                    <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Best-Answer-【数学推导】"><a href="#Best-Answer-【数学推导】" class="headerlink" title="Best Answer 【数学推导】"></a>Best Answer 【数学推导】</h3><p>这一部分属于数据公式的证明，可以参考如下教程，比较清晰</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/" target="_blank" rel="noopener">面试题14- I. 剪绳子（数学推导 / 贪心思想，清晰图解）</a></p>
</blockquote>
<h2 id="面试题15-二进制中的1"><a href="#面试题15-二进制中的1" class="headerlink" title="面试题15-二进制中的1"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15-二进制中的1</a></h2><ul>
<li><p>解题思路：<code>位操作</code></p>
<ul>
<li><p>原码、反码、补码相关概念。 原码 取反 + 1 ==&gt; 补码</p>
<blockquote>
<p>教程：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></p>
</blockquote>
</li>
<li><p>相关位运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &amp; 1 # n &amp; 1 验证最后一位是否是1</span><br><span class="line">n &gt;&gt; 1 # 等价于 n // 2 </span><br><span class="line">n &amp; (n - 1) #</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="My-Answer-【无符号位】【逐位判断】"><a href="#My-Answer-【无符号位】【逐位判断】" class="headerlink" title="My Answer 【无符号位】【逐位判断】"></a>My Answer 【无符号位】【逐位判断】</h3><blockquote>
<p>时间复杂度 $O(log_2n)$ 空间复杂度 $O(1)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="Graceful-Answer【无符号】【技巧法】"><a href="#Graceful-Answer【无符号】【技巧法】" class="headerlink" title="Graceful Answer【无符号】【技巧法】"></a>Graceful Answer【无符号】【技巧法】</h3><ul>
<li><p>解题思路：技巧： <code>n &amp; (n - 1)</code></p>
<ul>
<li>$(n - 1)$ 二进制最右边的 1变成0，0变成1</li>
<li>$n\times(n - 1)$ 二进制最右边的 1 变成 0，其余保持不变 。每一次 $n\times(n - 1)$都会消去一个0，直到消完为止。</li>
</ul>
<blockquote>
<p>时间复杂度 $O(M),M 代表数字N中1的个数$ 空间复杂度: $O(1)$</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200704162344.png" style="zoom: 50%;" />

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题16. 数值的整数次方</a></h2><h3 id="Best-Answer-【递归法】【快速幂】"><a href="#Best-Answer-【递归法】【快速幂】" class="headerlink" title="Best Answer 【递归法】【快速幂】"></a>Best Answer 【递归法】【快速幂】</h3><ul>
<li><p>解题思路：<code>快速幂</code></p>
<p>二分推导：</p>
<ul>
<li>当 n 为偶数： $x^n=x^{n/2}\times x^{n/2}$</li>
<li>当 n 为奇数： $x^n=x^{n/2}\times x^{n/2}\times x$</li>
</ul>
<blockquote>
<p>时间复杂度为 $O(log_2n)$ 空间复杂度 $O(1)$</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">""" 分治法: 递归版 """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"0 is not invalid"</span>)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 这个特别容易漏</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> x </span><br><span class="line"></span><br><span class="line">        postivate_n = abs(n)</span><br><span class="line">        temp = self.myPow(x, postivate_n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        res = temp * temp * (x <span class="keyword">if</span> postivate_n &amp; <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure>



<h3 id="Graceful-Answer-【数学递推法】【快速幂】"><a href="#Graceful-Answer-【数学递推法】【快速幂】" class="headerlink" title="Graceful Answer 【数学递推法】【快速幂】"></a>Graceful Answer 【数学递推法】【快速幂】</h3><ul>
<li><p>解题思路： <code>数据递推法</code> + <code>位运算</code></p>
<p>举例 $n = 9$ ，用二进制可表示为 $n = 9 = 1001_b$<br>$$<br>x^9 = 1\times x^{2^0} \times x^{2^3}<br>$$<br>这里，发现 $x^{2^0} = x$， 此时公式就变成<br>$$<br>x^9 = 1\times y \times y^3<br>$$<br>可以发现，只要对应二进制位为 0 的话，就不乘上去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        pos_n = abs(n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pos_n:</span><br><span class="line">            res = res * (x <span class="keyword">if</span> (pos_n &amp; <span class="number">1</span>) <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">            pos_n = pos_n &gt;&gt; <span class="number">1</span></span><br><span class="line">            x = x * x</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17. 打印从1到最大的n位数</a></h2><h3 id="Simple-Answer【简单版本】"><a href="#Simple-Answer【简单版本】" class="headerlink" title="Simple Answer【简单版本】"></a>Simple Answer【简单版本】</h3><ul>
<li><p>题解，本题对于 <code>Python</code>并不是一道简单的题目。难点是如何处理  <code>大数情况</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(range(<span class="number">1</span>, <span class="number">10</span>**n))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Hard-Answer-【大数版本】【全排列】"><a href="#Hard-Answer-【大数版本】【全排列】" class="headerlink" title="Hard Answer 【大数版本】【全排列】"></a>Hard Answer 【大数版本】【全排列】</h3><ul>
<li><p>解题思路：<code>全排列</code></p>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/mian-shi-ti-17-da-yin-cong-1-dao-zui-da-de-n-wei-2/" target="_blank" rel="noopener">面试题17. 打印从 1 到最大的 n 位数（分治算法 / 全排列，清晰图解）</a></p>
<p>时间复杂度  $O(10^n)$  空间复杂度 $O(1)$</p>
</blockquote>
<p>首先实现简单的实现  两个数字<code>0~9</code> 的全排列。可以通过 <code>递归</code> 去实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用递归实现 全排列问题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n: int)</span> -&gt; [int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n: <span class="comment"># 终止条件：已固定完所有位</span></span><br><span class="line">                res.append(<span class="string">''</span>.join(num)) <span class="comment"># 拼接 num 并添加至 res 尾部</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 遍历 0 - 9</span></span><br><span class="line">                num[x] = str(i) <span class="comment"># 固定第 x 位为 i</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位</span></span><br><span class="line">        </span><br><span class="line">        num = [<span class="string">'0'</span>] * n <span class="comment"># 起始数字定义为 n 个 0 组成的字符列表</span></span><br><span class="line">        res = [] <span class="comment"># 数字字符串列表</span></span><br><span class="line">        dfs(<span class="number">0</span>) <span class="comment"># 开启全排列递归</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    res = printNumbers(<span class="number">2</span>)</span><br><span class="line">    print(res)</span><br><span class="line"><span class="comment"># output:  </span></span><br><span class="line"><span class="comment"># ['00', '01', '02', '03', '04', '05', ...., '97', '98', '99']</span></span><br></pre></td></tr></table></figure>

<p>接下来，需要对 <code>全排列</code> 做一下优化，去除多余的 0 和 从1开始输出</p>
<p>这样的改进，感觉就是修复逻辑漏洞一样，比较考察是否细心，这里就比较见仁见智了。这里我参考的是 <a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener">Krahets</a> 给的解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == n: <span class="comment"># 这一步复杂筛选和生产数字序列</span></span><br><span class="line">                s = <span class="string">''</span>.join(self.num)[self.digit:] <span class="comment"># '0001' =&gt; '1'</span></span><br><span class="line">                <span class="keyword">if</span> s == <span class="string">'0'</span>: <span class="keyword">return</span> <span class="comment"># 只处理 ’0000‘ 全零的这一情况</span></span><br><span class="line">                <span class="keyword">if</span> self.digit + self.nine == n : self.digit -= <span class="number">1</span></span><br><span class="line">                self.res.append(s)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 这一步复杂生产 '00', '01', '02' 这样的序列 </span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">9</span>: self.nine += <span class="number">1</span></span><br><span class="line">                self.num[x] = str(i)</span><br><span class="line">                dfs(x + <span class="number">1</span>)</span><br><span class="line">        self.num = [<span class="string">'0'</span>] * n</span><br><span class="line">        self.digit = n - <span class="number">1</span> <span class="comment"># 代表是从最后一位开始</span></span><br><span class="line">        self.nine = <span class="number">0</span> <span class="comment"># 记录是不是从 9</span></span><br><span class="line">        self.res = []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    res = Solution().printNumbers(<span class="number">2</span>)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></h2><h3 id="My-Answer【单指针】"><a href="#My-Answer【单指针】" class="headerlink" title="My Answer【单指针】"></a>My Answer【单指针】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">""" 单指针法 """</span></span><br><span class="line">        <span class="comment"># 删除头结点</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.next</span><br><span class="line">        </span><br><span class="line">        temp = head</span><br><span class="line">        <span class="comment"># 非头结点</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">and</span> temp.next:</span><br><span class="line">            <span class="keyword">if</span> temp.next.val == val <span class="keyword">and</span> temp.next:</span><br><span class="line">                temp.next = temp.next.next</span><br><span class="line">            temp = temp.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>



<h3 id="My-Answer【双指针】【较为清晰】"><a href="#My-Answer【双指针】【较为清晰】" class="headerlink" title="My Answer【双指针】【较为清晰】"></a>My Answer【双指针】【较为清晰】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">""" 双指针法 """</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.next <span class="comment"># 如果正好是头结点</span></span><br><span class="line">        pre, cur = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre, cur = pre.next, cur.next</span><br></pre></td></tr></table></figure>



<h3 id="Other-Answer-【递归】"><a href="#Other-Answer-【递归】" class="headerlink" title="Other Answer 【递归】"></a>Other Answer 【递归】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        head.next = self.deleteNode(head.next, val)</span><br><span class="line">        <span class="keyword">return</span> head.next <span class="keyword">if</span> head.val == val <span class="keyword">else</span> head</span><br></pre></td></tr></table></figure>



<h2 id="面试题19-正则表达式匹配【困难】"><a href="#面试题19-正则表达式匹配【困难】" class="headerlink" title="面试题19. 正则表达式匹配【困难】"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">面试题19. 正则表达式匹配【困难】</a></h2><p>本题的 【Hard】模式，正是因为考虑的情形比较多，很容易一些小细节漏做。尽管整理的时候已经是二次刷题了，但是还是花了 <code>1H</code> 调试+重写才成功</p>
<h3 id="My-Answer-【递归法】"><a href="#My-Answer-【递归法】" class="headerlink" title="My Answer 【递归法】"></a>My Answer 【递归法】</h3><ul>
<li><p>解题思路：<code>递归法</code></p>
<p>考虑到的极端情况</p>
<ul>
<li>ab &lt;–&gt; ab</li>
<li>ab &lt;–&gt; .*</li>
<li>ab* 的时候，b 零次的信息很容易漏掉</li>
<li>终止条件： <code>if not p: return not a</code></li>
<li>判断相等逻辑： <code>p[0] in {s[i], &#39;.&#39;}</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># ab &lt;--&gt; a* 带星号的一定要先处理，不然在 s='' p='*b'的时候会出错</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">             <span class="keyword">if</span> self.isMatch(s, p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 零次情况考虑到</span></span><br><span class="line">             i = <span class="number">0</span></span><br><span class="line">             <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;: <span class="comment"># aaab a*b</span></span><br><span class="line">                <span class="keyword">if</span> self.isMatch(s[i+<span class="number">1</span>:], p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;: <span class="comment"># ab &lt;--&gt; ab</span></span><br><span class="line">             <span class="keyword">return</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>于此，我们又发现可以改进的地方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;: <span class="comment"># aaab a*b</span></span><br><span class="line">     <span class="keyword">if</span> self.isMatch(s[i+<span class="number">1</span>:], p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>可以列一张表，看到这里的 <code>while</code> 循环是不必要的，因为递归程序会帮我们一次次最终走到 <code>* 三次</code> 的情况，不需要我们自己显式的去写出，而且就算写出了，程序也走不到。</p>
<table>
<thead>
<tr>
<th></th>
<th>s</th>
<th>p</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>原始</td>
<td>aaab</td>
<td>a*b</td>
<td><em>True</em></td>
</tr>
<tr>
<td>* 零次</td>
<td>aaab</td>
<td>b</td>
<td>False</td>
</tr>
<tr>
<td>* 一次</td>
<td>aab</td>
<td>b</td>
<td>False–&gt; * 二次</td>
</tr>
<tr>
<td>* 二次</td>
<td>ab</td>
<td>b</td>
<td>False–&gt;* 三次</td>
</tr>
<tr>
<td>* 三次</td>
<td>b</td>
<td>b</td>
<td>True</td>
</tr>
</tbody></table>
<p>改进的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># ab &lt;--&gt; a* 带星号的一定要先处理，不然在 s='' p='*b'的时候会出错</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">             <span class="keyword">if</span> self.isMatch(s, p[<span class="number">2</span>:]): <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 零次情况考虑到</span></span><br><span class="line">             <span class="keyword">if</span> p <span class="keyword">and</span> s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125; <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p): <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>], <span class="string">'.'</span>&#125;: <span class="comment"># ab &lt;--&gt; ab</span></span><br><span class="line">             <span class="keyword">return</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Graceful-Answer【递归法】【大神代码】"><a href="#Graceful-Answer【递归法】【大神代码】" class="headerlink" title="Graceful Answer【递归法】【大神代码】"></a>Graceful Answer【递归法】【大神代码】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作者：z1m</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="comment"># 第一个字母是否匹配</span></span><br><span class="line">        first_match = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;)</span><br><span class="line">        <span class="comment"># 如果 p 第二个字母是 *</span></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">            first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h3 id="Graceful-Answer-【倒查递归】【大神代码】"><a href="#Graceful-Answer-【倒查递归】【大神代码】" class="headerlink" title="Graceful Answer 【倒查递归】【大神代码】"></a>Graceful Answer 【倒查递归】【大神代码】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       倒查递归，思路参考</span></span><br><span class="line"><span class="string">       https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">       1. 正则串是 正常字符串匹配/. s[:n-2] p[:m-2]</span></span><br><span class="line"><span class="string">       2. 正则串带 * </span></span><br><span class="line"><span class="string">             a. 先直接去除 c* s,p[:m-2] </span></span><br><span class="line"><span class="string">             b. 如果匹配*前的字符串， s[:n-1] p</span></span><br><span class="line"><span class="string">       3、 正常字符串 不匹配 直接返回False</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> p : <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">       <span class="keyword">if</span> s <span class="keyword">and</span> p[<span class="number">-1</span>] <span class="keyword">in</span> &#123;s[<span class="number">-1</span>], <span class="string">'.'</span>&#125;: </span><br><span class="line">           <span class="keyword">return</span> self.isMatch(s[:<span class="number">-1</span>], p[:<span class="number">-1</span>])</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> p[<span class="number">-1</span>] == <span class="string">'*'</span>:</span><br><span class="line">           <span class="keyword">return</span> self.isMatch(s, p[:<span class="number">-2</span>]) <span class="keyword">or</span> \</span><br><span class="line">                  bool(s <span class="keyword">and</span> p[<span class="number">-2</span>] <span class="keyword">in</span> &#123;s[<span class="number">-1</span>], <span class="string">'.'</span>&#125; <span class="keyword">and</span> self.isMatch(s[:<span class="number">-1</span>], p))</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="Graceful-Answer-【动态规划】"><a href="#Graceful-Answer-【动态规划】" class="headerlink" title="Graceful Answer 【动态规划】"></a>Graceful Answer 【动态规划】</h3><p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200705160832.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作者：z1m</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 边界条件，考虑 s 或 p 分别为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> len(p) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        m, n = len(s) + <span class="number">1</span>, len(p) + <span class="number">1</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            j = c - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][c] = dp[<span class="number">0</span>][c - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            i = r - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                j = c - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'.'</span>:</span><br><span class="line">                    dp[r][c] = dp[r - <span class="number">1</span>][c - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:       <span class="comment"># ‘*’前面的字符匹配s[i] 或者为'.'</span></span><br><span class="line">                    <span class="keyword">if</span> p[j - <span class="number">1</span>] == s[i] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>:</span><br><span class="line">                        dp[r][c] = dp[r - <span class="number">1</span>][c] <span class="keyword">or</span> dp[r][c - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:                       <span class="comment"># ‘*’匹配了0次前面的字符</span></span><br><span class="line">                        dp[r][c] = dp[r][c - <span class="number">2</span>] </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[r][c] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="面试题21-调整数组顺序使奇数位于偶数前面"><a href="#面试题21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21. 调整数组顺序使奇数位于偶数前面</a></h2><h3 id="Best-Answer【快排思路】【首尾双指针】"><a href="#Best-Answer【快排思路】【首尾双指针】" class="headerlink" title="Best Answer【快排思路】【首尾双指针】"></a>Best Answer【快排思路】【首尾双指针】</h3><ul>
<li><p>解题思路： <code>快排思想</code></p>
<p>主要变动的是在判断的依据上</p>
<blockquote>
<p>时间复杂度 $O(n)$   空间复杂度 $O(1)$</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums) - <span class="number">1</span> </span><br><span class="line">        temp = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            nums[right] = nums[left]</span><br><span class="line">        nums[right] = temp</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<p>更加简单一点的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/mian-shi-ti-21-diao-zheng-shu-zu-shun-xu-shi-qi-4/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &amp; <span class="number">1</span> == <span class="number">0</span>: j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h3 id="Best-Answer-【首端快慢指针】"><a href="#Best-Answer-【首端快慢指针】" class="headerlink" title="Best Answer 【首端快慢指针】"></a>Best Answer 【首端快慢指针】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 首端快慢指针</span></span><br><span class="line">        i, j, size = <span class="number">-1</span>, <span class="number">-1</span>, len(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; size - <span class="number">1</span>: </span><br><span class="line">             i += <span class="number">1</span></span><br><span class="line">             <span class="keyword">if</span> nums[i] &amp; <span class="number">1</span> == <span class="number">1</span>: <span class="comment"># 找到奇数</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h3 id="Simple-Answer-【辅助数组】"><a href="#Simple-Answer-【辅助数组】" class="headerlink" title="Simple Answer 【辅助数组】"></a>Simple Answer 【辅助数组】</h3><blockquote>
<p>时间复杂度 $O(n)$   空间复杂度 $O(n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        num1, num2 = [], []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: num1.append(n)</span><br><span class="line">            <span class="keyword">else</span>: num2.append(n)</span><br><span class="line">        <span class="keyword">return</span> num1 + num2</span><br></pre></td></tr></table></figure>



<h2 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h2><h3 id="Simple-Answer【辅助数组】"><a href="#Simple-Answer【辅助数组】" class="headerlink" title="Simple Answer【辅助数组】"></a>Simple Answer【辅助数组】</h3><blockquote>
<p>时间复杂度 $O(n)$  空间复杂度 $O(n)$ </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        arr = []</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head)</span><br><span class="line">            head = head.next </span><br><span class="line">        return arr[-1*k]</span><br></pre></td></tr></table></figure>



<h3 id="Best-Answer-【双指针】"><a href="#Best-Answer-【双指针】" class="headerlink" title="Best Answer 【双指针】"></a>Best Answer 【双指针】</h3><ul>
<li>解题思路： <code>双指</code> ，<code>两步走</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        h1, h2 = head, head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k): <span class="comment"># h1 先走 k 步</span></span><br><span class="line">            h1 = h1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> h1: <span class="comment"># h1 走完</span></span><br><span class="line">            h1 = h1.next</span><br><span class="line">            h2 = h2.next <span class="comment"># 此时 h2 走了 n-k 步，即倒数第k个节点</span></span><br><span class="line">        <span class="keyword">return</span> h2</span><br></pre></td></tr></table></figure>



<h2 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a></h2><h3 id="My-Answer-1-【双指针头尾交换】"><a href="#My-Answer-1-【双指针头尾交换】" class="headerlink" title="My Answer 1 【双指针头尾交换】"></a>My Answer 1 【双指针头尾交换】</h3><blockquote>
<p>图参考：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/" target="_blank" rel="noopener">【反转链表】：双指针，递归，妖魔化的双指针</a></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200705211833.png" style="zoom: 50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="string">""" 双指针"""</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur_next_bak = cur.next <span class="comment"># 因为cur.next 马上要指向前节点，这里做个备份</span></span><br><span class="line">            cur.next = pre</span><br><span class="line"></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur_next_bak</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>



<h3 id="My-Answer-2【递归】【理解有点难度】"><a href="#My-Answer-2【递归】【理解有点难度】" class="headerlink" title="My Answer 2【递归】【理解有点难度】"></a>My Answer 2【递归】【理解有点难度】</h3><blockquote>
<p>动图来自：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/dong-hua-yan-shi-duo-chong-jie-fa-206-fan-zhuan-li/" target="_blank" rel="noopener">动画演示+多种解法 面试题24. 反转链表</a></p>
</blockquote>
<p><img src="https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur = self.reverseList(head.next)</span><br><span class="line">        </span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>



<h3 id="My-Answer-3【辅助空间】"><a href="#My-Answer-3【辅助空间】" class="headerlink" title="My Answer 3【辅助空间】"></a>My Answer 3【辅助空间】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node = ListNode(head.val)</span><br><span class="line">            node.next = ret</span><br><span class="line">            ret = node</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



<h2 id="面试题25-合并两个排序的链表【经典】"><a href="#面试题25-合并两个排序的链表【经典】" class="headerlink" title="面试题25. 合并两个排序的链表【经典】"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表【经典】</a></h2><h3 id="Best-Answer-3"><a href="#Best-Answer-3" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li>引入一个头节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        sortedList = ListNode(<span class="literal">None</span>) <span class="comment"># 伪节点</span></span><br><span class="line">        head = sortedList</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l2.val &gt; l1.val:</span><br><span class="line">                node = ListNode(l1.val)</span><br><span class="line">                sortedList.next = node</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = ListNode(l2.val)</span><br><span class="line">                sortedList.next = node</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            sortedList = sortedList.next</span><br><span class="line">        sortedList.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2 <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>



<h2 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></h2><h3 id="Best-Answer-【递归】"><a href="#Best-Answer-【递归】" class="headerlink" title="Best Answer 【递归】"></a>Best Answer 【递归】</h3><ul>
<li>解题技巧<ul>
<li>在  return 中，加入<code>bool(A and B)</code> 来代替 <code>if not A and not B: return False</code> ，显得更加简洁</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B: <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">and</span> A.val != B.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 头结点匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> recur(A.left, B.left) <span class="keyword">and</span> recur(A.right, B.right)</span><br><span class="line">        <span class="keyword">return</span> bool(A <span class="keyword">and</span> B) <span class="keyword">and</span>  <span class="comment"># 空树不是任意一个树的子节点\ </span></span><br><span class="line">               (recur(A, B) <span class="keyword">or</span> recur(A.left, B) <span class="keyword">or</span> recur(A.right, B))</span><br></pre></td></tr></table></figure>



<h2 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></h2><h3 id="Best-Answer【递归】"><a href="#Best-Answer【递归】" class="headerlink" title="Best  Answer【递归】"></a>Best  Answer【递归】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></h2><h3 id="Best-Answer-【递归】-1"><a href="#Best-Answer-【递归】-1" class="headerlink" title="Best Answer 【递归】"></a>Best Answer 【递归】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compareTree</span><span class="params">(treeA, treeB)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> treeA <span class="keyword">and</span> <span class="keyword">not</span> treeB: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> treeA <span class="keyword">or</span> <span class="keyword">not</span> treeB: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> treeA.val != treeB.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> compareTree(treeA.left, treeB.right) <span class="keyword">and</span> \</span><br><span class="line">                   compareTree(treeA.right, treeB.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> compareTree(root.left, root.right)</span><br></pre></td></tr></table></figure>



<h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></h2><p>My Answer 【寻找规律】</p>
<ul>
<li><p>解题思路：</p>
<p>可以通过观察，发现每次 横向移动的时候，移动的长度会减一。纵向移动同样如此。</p>
<p>如一个 $3 \times 3$ 的矩阵，规律为：向右移动3次，向下移动2次，向左移动2次，向上移动1次，向右移动1次。</p>
<p>我们给横向移动设置初始值值 3，纵向移动 2。每次移动完了就减一。</p>
<blockquote>
<p>这里需要考虑终止条件的位置：一定是在移动之前检查本方向是否已终止</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        xlen, ylen = len(matrix[<span class="number">0</span>]), len(matrix) - <span class="number">1</span></span><br><span class="line">        x, y = <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">        direction = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>)] <span class="comment"># 右下左上</span></span><br><span class="line">        dflag = <span class="number">0</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> xlen: <span class="keyword">break</span> <span class="comment"># 在横向移动之前，检查能否移动，不能的话一定是代表结束</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(xlen): <span class="comment"># 横向打印</span></span><br><span class="line">                x = x + direction[dflag][<span class="number">0</span>]</span><br><span class="line">                y = y + direction[dflag][<span class="number">1</span>]</span><br><span class="line">                ret.append(matrix[y][x])</span><br><span class="line">            </span><br><span class="line">            xlen -= <span class="number">1</span></span><br><span class="line">            dflag = (dflag + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ylen: <span class="keyword">break</span> <span class="comment"># 在纵向向移动之前，检查能否移动，不能的话一定是代表结束</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(ylen): <span class="comment"># 横向打印</span></span><br><span class="line">                x = x + direction[dflag][<span class="number">0</span>]</span><br><span class="line">                y = y + direction[dflag][<span class="number">1</span>]</span><br><span class="line">                ret.append(matrix[y][x])</span><br><span class="line">            ylen -= <span class="number">1</span></span><br><span class="line">            dflag = (dflag + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题30-包含min函数的栈【思路经典】"><a href="#面试题30-包含min函数的栈【思路经典】" class="headerlink" title="面试题30. 包含min函数的栈【思路经典】"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈【思路经典】</a></h2><h3 id="Best-Answer-4"><a href="#Best-Answer-4" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li>解题思路：<code>辅助栈</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.B <span class="keyword">or</span> self.B[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">            self.B.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.A.pop() == self.B[<span class="number">-1</span>]:</span><br><span class="line">            self.B.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.B[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="面试题31-栈的压入、弹出序列"><a href="#面试题31-栈的压入、弹出序列" class="headerlink" title="面试题31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></h2><h3 id="Best-Answer-【模拟法】"><a href="#Best-Answer-【模拟法】" class="headerlink" title="Best Answer 【模拟法】"></a>Best Answer 【模拟法】</h3><ul>
<li>解题思路：<br>由于题目中假定了两个队列长度相等，栈内元素不同。这一假设大大简化了问题的复杂程度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed: List[int], popped: List[int])</span> -&gt; bool:</span></span><br><span class="line">        tempList = []</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> pushed:</span><br><span class="line">            tempList.append(each)</span><br><span class="line">            <span class="keyword">while</span> tempList <span class="keyword">and</span> tempList[<span class="number">-1</span>] == popped[<span class="number">0</span>]:</span><br><span class="line">                tempList.pop()</span><br><span class="line">                popped = popped[<span class="number">1</span>:]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> popped <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></h2><h3 id="Best-Answer【经典算法】【二叉树的层次遍历】"><a href="#Best-Answer【经典算法】【二叉树的层次遍历】" class="headerlink" title="Best Answer【经典算法】【二叉树的层次遍历】"></a>Best Answer【经典算法】【二叉树的层次遍历】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root : <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, queue = queue[<span class="number">0</span>], queue[<span class="number">1</span>:]</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 利用 collection.deque 实现队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root : <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="面试题32-II-从上到下打印二叉树-II"><a href="#面试题32-II-从上到下打印二叉树-II" class="headerlink" title="面试题32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a></h2><h3 id="Best-Answer-【层次遍历升级】"><a href="#Best-Answer-【层次遍历升级】" class="headerlink" title="Best Answer 【层次遍历升级】"></a>Best Answer 【层次遍历升级】</h3><ul>
<li><p>解题思路：</p>
<p>核心解决的就是层与层的区分</p>
<ul>
<li>通过标记层号解决</li>
<li>通过queue的长度来区分层</li>
</ul>
</li>
<li><p>【标记层号】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, level = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> level &gt; len(res) - <span class="number">1</span>: res.append([])</span><br><span class="line">            res[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append((node.left, level + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append((node.right, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>【根据queue长度】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            _res = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                _res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(_res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题32-III-从上到下打印二叉树-III"><a href="#面试题32-III-从上到下打印二叉树-III" class="headerlink" title="面试题32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III（层序遍历 BFS / 双端队列，清晰图解）</a> </p>
</blockquote>
<h3 id="Best-Answer-5"><a href="#Best-Answer-5" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：</p>
<ul>
<li><p><code>层次遍历</code> + <code>双端队列</code> </p>
<p>在奇偶层节点加入上，奇数层从左端加入，偶数层在右端加入 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp.appendleft()</span><br><span class="line">temp.append()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            temp = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> len(res) &amp; <span class="number">1</span> == <span class="number">0</span>: temp.append(node.val)</span><br><span class="line">                <span class="keyword">else</span>: temp.appendleft(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(list(temp))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>层次遍历</code> + <code>奇偶逻辑分开</code> （略）</p>
<p>在出队的时候，奇数层从左端出队，偶数层从右端出队</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queue.popleft()</span><br><span class="line">queue.pop()</span><br></pre></td></tr></table></figure>
</li>
<li><p>仅对 <code>面试题32-II</code> 的顺序进行调整 （略）</p>
</li>
</ul>
</li>
</ul>
<h2 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a></h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列（递归分治 / 单调栈，清晰图解）</a></p>
</blockquote>
<h3 id="Best-Answer-6"><a href="#Best-Answer-6" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：<code>递归分治</code></p>
<ul>
<li>判断当前根是否存在错误 ，即 <code>是否符合  左 &lt; 根 &lt; 右</code></li>
<li><code>self.verifyPostorder(postorder[: m])</code> 判断左子树是否正确</li>
<li><code>self.verifyPostorder(postorder[m : -1])</code> 判断右子树是否正确</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200707205301.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断是否符合 左&lt;根&lt;右</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &gt; root: <span class="keyword">break</span></span><br><span class="line">        m = i <span class="comment"># m 为右子树的第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, len(postorder) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> postorder[i] &lt; root: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 右子树出现了比根节点小的节点。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.verifyPostorder(postorder[: m]) <span class="keyword">and</span> \</span><br><span class="line">               self.verifyPostorder(postorder[m : <span class="number">-1</span>])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h2><p>待整理</p>
<h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></h2><p>待整理</p>
<h2 id="面试题36-二叉搜索树与双向链表【困难】"><a href="#面试题36-二叉搜索树与双向链表【困难】" class="headerlink" title="面试题36. 二叉搜索树与双向链表【困难】"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表【困难】</a></h2><h3 id="My-Answer-【中序遍历】【辅助队列】"><a href="#My-Answer-【中序遍历】【辅助队列】" class="headerlink" title="My Answer 【中序遍历】【辅助队列】"></a>My Answer 【中序遍历】【辅助队列】</h3><ul>
<li><p>解题思路：<code>中序遍历</code> + <code>辅助队列</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span> <span class="comment"># 中序遍历</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> []</span><br><span class="line">            dfs(cur.left) <span class="comment"># 左</span></span><br><span class="line">            res.append(cur) <span class="comment"># 中</span></span><br><span class="line">            dfs(cur.right) <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 根据 队列，前后链接链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(res) - <span class="number">1</span>):</span><br><span class="line">            res[i].right = res[i + <span class="number">1</span>]</span><br><span class="line">            res[i+<span class="number">1</span>].left = res[i]</span><br><span class="line">        <span class="comment"># 头尾特殊处理</span></span><br><span class="line">        res[<span class="number">0</span>].left = res[<span class="number">-1</span>] </span><br><span class="line">        res[<span class="number">-1</span>].right = res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Best-Answer-【中序遍历】【双指针改进】"><a href="#Best-Answer-【中序遍历】【双指针改进】" class="headerlink" title="Best Answer 【中序遍历】【双指针改进】"></a>Best Answer 【中序遍历】【双指针改进】</h3><ul>
<li><p>解题思路</p>
<p>上述方法虽然简单，但是借助了 <code>辅助队列</code> ，可以利用双指针改进</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            <span class="keyword">if</span> self.pre:</span><br><span class="line">                self.pre.right, cur.left = cur, self.pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.head = cur <span class="comment"># 此时记录的是头结点</span></span><br><span class="line">            self.pre = cur <span class="comment"># 最后遍历的是尾结点</span></span><br><span class="line">            dfs(cur.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        self.head.left, self.pre.right = self.pre, self.head </span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题37-序列化二叉树【困难】"><a href="#面试题37-序列化二叉树【困难】" class="headerlink" title="面试题37. 序列化二叉树【困难】"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树【困难】</a></h2><h3 id="Best-Answer-7"><a href="#Best-Answer-7" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：<code>层次遍历</code></p>
<p>我们可以根据 level 层级，限制最后生成 <code>队列</code> 的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        res, queue = [], collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                   res.append(node.val)</span><br><span class="line">                   queue.append(node.left)</span><br><span class="line">                   queue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                   res.append(<span class="string">"null"</span>)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        level -= <span class="number">1</span> <span class="comment"># 减一后的level是真实的 层数</span></span><br><span class="line">        res = res[:<span class="number">2</span>**level - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + <span class="string">","</span>.join([str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> res]) + <span class="string">"]"</span></span><br><span class="line">             </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">"[]"</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        vals, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">','</span>), <span class="number">1</span></span><br><span class="line">        root = TreeNode(int(vals[<span class="number">0</span>])) </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> i &lt; len(vals):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                 node.left = TreeNode(int(vals[i]))</span><br><span class="line">                 queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> vals[i] != <span class="string">"null"</span>:</span><br><span class="line">                 node.right = TreeNode(int(vals[i]))</span><br><span class="line">                 queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题38-字符串的排列【全排列】"><a href="#面试题38-字符串的排列【全排列】" class="headerlink" title="面试题38. 字符串的排列【全排列】"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38. 字符串的排列【全排列】</a></h2><h3 id="Best-Answer-8"><a href="#Best-Answer-8" class="headerlink" title="Best Answer"></a>Best Answer</h3><ul>
<li><p>解题思路：<code>回溯</code> + <code>交换</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        c, res = list(s), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == len(c) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="string">''</span>.join(c)) <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dic = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x, len(c)):</span><br><span class="line">                <span class="keyword">if</span> c[i] <span class="keyword">in</span> dic: <span class="keyword">continue</span> <span class="comment"># 重复，因此剪枝</span></span><br><span class="line">                dic.add(c[i])</span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 交换，将 c[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>) <span class="comment"># 开启固定第 x + 1 位字符</span></span><br><span class="line">                c[i], c[x] = c[x], c[i] <span class="comment"># 恢复交换</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="My-Answer"><a href="#My-Answer" class="headerlink" title="My Answer"></a>My Answer</h3><ul>
<li><p>解题思路： <code>回溯</code> + <code>辅助站</code></p>
<p>每一位上只能使用一次，故用 <code>visited 矩阵</code> 记录的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(st)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(st) == len(s):</span><br><span class="line">                 res.append(st)</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.append(i)</span><br><span class="line">                    recur(st + s[i])</span><br><span class="line">                    visited.remove(i)</span><br><span class="line"></span><br><span class="line">        visited, res = [], []</span><br><span class="line">        recur(<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> list(set(res))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题39-数组中出现次数超过一半的数字"><a href="#面试题39-数组中出现次数超过一半的数字" class="headerlink" title="面试题39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>哈希表统计法： 遍历数组 nums ，用 HashMap 统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为 $O(N)$ 。</li>
<li>数组排序法： 将数组 nums 排序，由于众数的数量超过数组长度一半，因此 数组中点的元素 一定为众数。此方法时间复杂度 $O(N log_2 N)$</li>
<li><strong>摩尔投票法：</strong> 核心理念为 <strong>“正负抵消”</strong> ；时间和空间复杂度分别为 $O(N)$ 和 $O(1)$；是本题的最佳解法。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200708172711.png" style="zoom:50%;" />

</li>
</ul>
<h3 id="Best-Answer-【摩尔投票法】"><a href="#Best-Answer-【摩尔投票法】" class="headerlink" title="Best Answer 【摩尔投票法】"></a>Best Answer 【摩尔投票法】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        votes, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>: x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 验证 x 是否为众数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == x: count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 当无众数时返回 0</span></span><br></pre></td></tr></table></figure>



<h2 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a></h2><ul>
<li><p>解题思路：</p>
<ul>
<li><p><code>快排</code> + <code>筛选</code></p>
<blockquote>
<p>时间复杂度: $O(N log_2 N)$， 空间复杂度 $O(1)$</p>
</blockquote>
</li>
<li><p><code>堆排</code></p>
<blockquote>
<p>时间复制度：$O(Nlog_2k)$ ，空间复杂度 $O(N)$</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="My-Answer1【快排】"><a href="#My-Answer1【快排】" class="headerlink" title="My Answer1【快排】"></a>My Answer1【快排】</h3><ul>
<li><p><code>快排</code> + <code>筛选</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快排 + 筛选</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span> </span><br><span class="line">            pivot = nums[start]</span><br><span class="line">            low, high = start, end</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] &gt;= pivot: high -= <span class="number">1</span></span><br><span class="line">                nums[low] = nums[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] &lt; pivot: low += <span class="number">1</span></span><br><span class="line">                nums[high] = nums[low]</span><br><span class="line">            nums[low] = pivot</span><br><span class="line">            quicksort(nums, start, low - <span class="number">1</span>)</span><br><span class="line">            quicksort(nums, low + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">        quicksort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]  <span class="comment"># 筛选</span></span><br></pre></td></tr></table></figure>

<p>上面的方法没有利用到 <code>快排</code> 的性质，由于每次排完之后，存在 <code>左 &lt; 中 &lt; 右</code> </p>
<ul>
<li><code>中 == k - 1</code> 我们已经获得了前K个元素，但是也没有排序</li>
<li><code>中 &gt; k - 1</code> 只需要在左边找</li>
<li><code>中 &lt; k - 1</code> 只需要在右边找</li>
</ul>
</li>
<li><p>利用<code>快排</code> 性质</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span> </span><br><span class="line">            pivot = nums[start]</span><br><span class="line">            low, high = start, end</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] &gt;= pivot: high -= <span class="number">1</span></span><br><span class="line">                nums[low] = nums[high]</span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] &lt; pivot: low += <span class="number">1</span></span><br><span class="line">                nums[high] = nums[low]</span><br><span class="line">            nums[low] = pivot</span><br><span class="line">            <span class="keyword">if</span> low == k - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> arr[:k]</span><br><span class="line">            <span class="keyword">elif</span> low &lt; k - <span class="number">1</span>:</span><br><span class="line">                quicksort(nums, low + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                quicksort(nums, start, low - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="My-Answer2-【堆排】"><a href="#My-Answer2-【堆排】" class="headerlink" title="My Answer2 【堆排】"></a>My Answer2 【堆排】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span><span class="params">(nums, i, size)</span>:</span></span><br><span class="line">           lchild = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">           rchild = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">           max = i</span><br><span class="line">           <span class="keyword">if</span> i &lt; size / <span class="number">2</span>:</span><br><span class="line">               <span class="keyword">if</span> lchild &lt; size <span class="keyword">and</span> nums[lchild] &gt; nums[max]: max = lchild</span><br><span class="line">               <span class="keyword">if</span> rchild &lt; size <span class="keyword">and</span> nums[rchild] &gt; nums[max]: max = rchild</span><br><span class="line">               <span class="keyword">if</span> max != i:</span><br><span class="line">                   nums[max], nums[i] = nums[i], nums[max]</span><br><span class="line">                   adjust_heap(nums, max, size)</span><br><span class="line">        </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(nums)</span>:</span></span><br><span class="line">            size = len(nums)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size &gt;&gt; <span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">                adjust_heap(nums, i, size)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> arr: <span class="keyword">return</span> []</span><br><span class="line">       arr = [<span class="number">-1</span> * _ <span class="keyword">for</span> _ <span class="keyword">in</span> arr]</span><br><span class="line">       build_heap(arr)</span><br><span class="line">       size = len(arr)</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>, len(arr) - <span class="number">1</span> - k, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment">#    print(arr)</span></span><br><span class="line">           arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">           adjust_heap(arr, <span class="number">0</span>, i)</span><br><span class="line">       arr = [<span class="number">-1</span> * _ <span class="keyword">for</span> _ <span class="keyword">in</span> arr][::<span class="number">-1</span>]</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure>

<p>堆排可以直接使用 <code>python</code> 自带的 <code>堆结构</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k: int)</span> :</span></span><br><span class="line">        shuffle(arr)  <span class="comment"># 随机排序</span></span><br><span class="line">        heapq.heapify(arr) <span class="comment"># 建立堆结构</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nsmallest(k, arr)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>heapq 模块的使用 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heapq.heappush(heap, item) <span class="comment"># 添加元素</span></span><br><span class="line">heapq.heappop(heap) <span class="comment"># 弹出元素</span></span><br><span class="line">heapq.heappushpop(heap, item) <span class="comment">#添加元素后，再弹出一个元素，比 heappush + heappop 更高效</span></span><br><span class="line">heapq.heapreplace(heap, item) <span class="comment">#添加元素后，返回的是原数组中最小的元素</span></span><br><span class="line">heapq.heapify(x) <span class="comment"># 堆的初始化</span></span><br><span class="line">heapq.nlargest(n, heap) <span class="comment"># 最大n个元素</span></span><br><span class="line">heapq.nsmallest(n, heap) <span class="comment"># 最小n个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heapreplace vs heappushpop </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapify(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappushpop(a, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapreplace(b, <span class="number">-1</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="面试题41-数据流中的中位数【困难】"><a href="#面试题41-数据流中的中位数【困难】" class="headerlink" title="面试题41. 数据流中的中位数【困难】"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数【困难】</a></h2><h3 id="Best-Answer【优先队列】"><a href="#Best-Answer【优先队列】" class="headerlink" title="Best Answer【优先队列】"></a>Best Answer【优先队列】</h3><ul>
<li><p>解题思路：</p>
<p>维持两个根堆，一个是大顶堆A，一个是小顶堆B。其中A的最大元素 小于 B的最小元素。</p>
<p>寻找中位数的思路：<strong>令m为A的长度，n为B的长度，N为总长度​</strong></p>
<ul>
<li>当 m = n 时，证明N为偶数，中位数为 (A的堆顶 + B的堆顶)/2</li>
<li>当 m != n 时，证明N为奇数，中位数为A的堆顶(也可以取B的堆顶，类推)</li>
<li>Tips:<ul>
<li>为了保存中位数一直在A的堆顶，要保证A的长度始终要大于等于B。而且所有元素一定要在A，B中都调整过。</li>
<li>当 m = n 时，应该向A推元素，故应<strong>先推B，再推A</strong>，此时 A 有 m + 1 个，B有 n 个</li>
<li>当 m != n 时，应该向B推元素，因为我们始终保持的是A的数量大于B。即 m &gt;= n。故应<strong>先推A再推B</strong>，此时 A 有 m，B 有 n + 1 个</li>
<li>我们可以看出，先推的那个总是长度不变的，可以直接使用 <code>heapq.hashpushpop()</code> 方法</li>
<li>A 是大堆顶，故 <code>push&amp;pop</code> 的时候应该注意使用负数。heapq 实现了小顶堆，需要借助 负号 实现大根堆</li>
</ul>
</li>
</ul>
<blockquote>
<p>时间复杂度：$O(logn)$。堆插入和删除需要$O(logn)$，查找中位数需要$O(1)$。<br>空间复杂度：$O(n)$</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max_heap, self.min_heap = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">             heapq.heappush(self.max_heap,</span><br><span class="line">                            -heapq.heappushpop(self.min_heap, num)) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             heapq.heappush(self.min_heap,</span><br><span class="line">                            -heapq.heappushpop(self.max_heap, -num))</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">            <span class="keyword">return</span> (- self.max_heap[<span class="number">0</span>] + self.min_heap[<span class="number">0</span>])/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> - self.max_heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Best-Answer【折半直接插入】"><a href="#Best-Answer【折半直接插入】" class="headerlink" title="Best Answer【折半直接插入】"></a>Best Answer【折半直接插入】</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/u/z1m/" target="_blank" rel="noopener">腐烂的橘子🍊</a>  <a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/you-xian-dui-lie-by-z1m/" target="_blank" rel="noopener">图解 排序+二分查找+优先队列</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<p>排序法是针对无序数组，本题中最适合的排序方法是 <strong>直接插入排序</strong>，Python 自带的 <code>bisect</code> 已经为我们提前实现了 <code>二分插入</code> </p>
<p>Tips:</p>
<ul>
<li><p>当 数组长度为奇数时，直接返回中位数：<code>nums[len(nums)&gt;&gt;1]</code></p>
</li>
<li><p>当 数组长度为偶数时，直接返回平均数：</p>
<p><code>(nums[len(nums)//2] + nums[len(nums)//2 +1])/2</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a 查找数组；x为插入的元素；lo,hi 约定为数组的范围</span></span><br><span class="line">bisect.insort(a, x, lo=<span class="number">0</span>, hi=len(a)) <span class="comment"># 折半插入，若存在x则插入x的右侧</span></span><br><span class="line">bisect.insort_right <span class="comment"># 同 bisect.insort</span></span><br><span class="line">bisect.insort_left <span class="comment">#  折半插入，若存在x则插入x的左侧</span></span><br><span class="line"><span class="comment"># 有以下三种方法，对应上面的插入方法。不同的是，它们只返回应插入的位置</span></span><br><span class="line">bisect.bisect</span><br><span class="line">bisect.bisect_left</span><br><span class="line">bisect.bisect_right</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        bisect.insort(self.A, num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        size = len(self.A)</span><br><span class="line">        <span class="keyword">if</span> size &amp; <span class="number">1</span> == <span class="number">0</span>: <span class="comment"># even</span></span><br><span class="line">            <span class="keyword">return</span> (self.A[size &gt;&gt; <span class="number">1</span>] + self.A[(size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>]) / <span class="number">2</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.A[size &gt;&gt; <span class="number">1</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42. 连续子数组的最大和</a></h2><blockquote>
<p>参考<a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener">Krahets</a> 的 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" target="_blank" rel="noopener">方法总结</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>常见解法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>暴力搜索</td>
<td>$O(N^2)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>分治思想</td>
<td>$O(NlogN)$</td>
<td>$O(logN)$</td>
</tr>
<tr>
<td>动态规划</td>
<td>$O(N)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>剪枝法</td>
<td>$O(N)$</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<h3 id="Best-Answer-【暴力-剪枝】"><a href="#Best-Answer-【暴力-剪枝】" class="headerlink" title="Best Answer 【暴力+剪枝】"></a>Best Answer 【暴力+剪枝】</h3><ul>
<li><p>解题思路：</p>
<p>只需要 保证求出的 sum 始终大于 0 即可，若是小于0，完全可以直接丢弃。</p>
<blockquote>
<p>本质算是暴力法的剪枝，这种剪枝巧妙的利用了规律</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 64ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        s, ret = <span class="number">0</span>, <span class="number">-101</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> s &lt; <span class="number">0</span>: s = <span class="number">0</span></span><br><span class="line">            s += i</span><br><span class="line">            ret = max(ret, s)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Best-Answer-【动态规划】"><a href="#Best-Answer-【动态规划】" class="headerlink" title="Best Answer 【动态规划】"></a>Best Answer 【动态规划】</h3><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200710162955.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(nums[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：jyd</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</span></span><br></pre></td></tr></table></figure>

<p>上面 jyd 在处理的时候，直接在 nums 基础上进行了运算，可以说节约了 $O(N)$ 的空间使用，非常精妙</p>
<h3 id="Other-Answer-【分治法】"><a href="#Other-Answer-【分治法】" class="headerlink" title="Other Answer 【分治法】"></a>Other Answer 【分治法】</h3><blockquote>
<p>参考资料：</p>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/bao-li-qiu-jie-by-pandawakaka/" target="_blank" rel="noopener">最大子序和（暴力法 + 分治法 + DP）- Python3</a></p>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/chao-quan-4zhong-jie-fa-dong-tai-gui-hua-ji-you-hu/" target="_blank" rel="noopener">【超全·4种解法】动态规划及优化、贪心法、分治法（JavaScript实现）</a></p>
</blockquote>
<ul>
<li><p>解题思路：</p>
<ul>
<li>将数组分为 2 部分。例如 [1, 2, 3, 4] 被分为 [1, 2] 和 [3, 4]</li>
<li>通过递归计算，得到左右两部分的最大子序列和是 lsum，rsum</li>
<li>从数组中间开始向两边计算最大子序列和 cross</li>
<li>返回 max(lsum, cross, rsum)</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200710162955.png" style="zoom:50%;" />

<p><strong>Tips:</strong></p>
<ul>
<li>由于 <code>len(nums)==1</code> 保证了 <code>mid=len(nums)//2 - 1</code> 和 <code>mid - 1</code> 是存在的</li>
<li>中间值计算一定是从 mid 开始的连续值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 544 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">crossSum</span><span class="params">(nums)</span>:</span></span><br><span class="line">            mid = len(nums) // <span class="number">2</span> - <span class="number">1</span> </span><br><span class="line">            left_max_sum, left_sum = nums[mid], <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[mid: : <span class="number">-1</span>]:</span><br><span class="line">                left_sum += i</span><br><span class="line">                left_max_sum = max(left_max_sum, left_sum)</span><br><span class="line">            </span><br><span class="line">            right_max_sum, right_sum = nums[mid + <span class="number">1</span>], <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums[mid + <span class="number">1</span>: : <span class="number">1</span>]:</span><br><span class="line">                right_sum += i</span><br><span class="line">                right_max_sum = max(right_max_sum, right_sum)</span><br><span class="line">            <span class="keyword">return</span> left_max_sum + right_max_sum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        mid = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">        left_max = self.maxSubArray(nums[:mid])</span><br><span class="line">        right_max = self.maxSubArray(nums[mid:])</span><br><span class="line">        mid_max = crossSum(nums)</span><br><span class="line">        <span class="keyword">return</span> max(left_max, right_max, mid_max)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="剑指-Offer-43-1～n整数中1出现的次数"><a href="#剑指-Offer-43-1～n整数中1出现的次数" class="headerlink" title="剑指 Offer 43. 1～n整数中1出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 43. 1～n整数中1出现的次数</a></h2><p>待整理</p>
<h2 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 44. 数字序列中某一位的数字</a></h2><p>待整理</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指Offer，刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>提升 git 速度的几个加速方法</title>
    <url>/2020/05/03/several-tips-git-speed-up/</url>
    <content><![CDATA[<p>最近经常需要从github上拉代码下来，速度实在是太慢了。所以写这篇文件，来好好总结一下提速的方法。</p>
<p>总的来说，方法有 替换 <strong>镜像源/修改hosts/使用国内托管平台/使用代理</strong></p>
<p>经过实验下来，使用代理的效果最好</p>
<a id="more"></a>

<h2 id="使用镜像源-推荐"><a href="#使用镜像源-推荐" class="headerlink" title="使用镜像源(推荐)"></a>使用镜像源(推荐)</h2><blockquote>
<p>参考 <a href="https://www.zhihu.com/question/27159393" target="_blank" rel="noopener">知乎Don.hub</a></p>
</blockquote>
<p>替换 github 镜像网站，把 <code>github.com</code> 替换成 <code>github.com.cnpmjs.org</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/graykode/nlp-tutorial</span><br><span class="line">https://github.com.cnpmjs.org/graykode/nlp-tutorial</span><br></pre></td></tr></table></figure>

<p>这个方法最简单，提速效果还是很明显的。当然缺点也是很明显的，就是如果是一些不知名的项目，就没有对应的镜像源可以用了。</p>
<h2 id="修改hosts（不推荐）"><a href="#修改hosts（不推荐）" class="headerlink" title="修改hosts（不推荐）"></a>修改hosts（不推荐）</h2><p>DNS污染是GFW的一个重要手段，通过修改 hosts 文件来直接绕过DNS解析是一个不错的方法。这是一个主流的解决方法，但是实测下来效果并不显著。</p>
<p><strong>第一步: 找到以下两个域名对应最快的 ip 地址</strong></p>
<p>查 ip 地址： <a href="https://www.ipaddress.com" target="_blank" rel="noopener">https://www.ipaddress.com</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.global.ssl.fastly.net  </span><br><span class="line">github.com</span><br></pre></td></tr></table></figure>

<p><strong>第二步: 将找到的对应的 ip 添加至 hosts ( 地址: /etc/hosts)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 举个例子</span><br><span class="line">213.54.23.32 github.global.ssl.fastly.net  </span><br><span class="line">212.44.53.42 github.com</span><br></pre></td></tr></table></figure>



<h2 id="使用国内托管平台"><a href="#使用国内托管平台" class="headerlink" title="使用国内托管平台"></a>使用国内托管平台</h2><p>通过国内托管平台，如码云 <code>gitee/阿里云/oschaina</code> 等作为中转，将代码 fork 到自己的仓库下。然后去 clone 对应仓库的repo，基本可以到达满速。</p>
<p>搬运教程：<a href="https://zhuanlan.zhihu.com/p/111697412" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111697412</a></p>
<p>这也是一个不错的方法，就是稍微有点烦。而且对于小白来说，还容易碰到一个问题是，在使用 SSH 方式拉代码的话，需要碰到多个秘钥管理的麻烦事情。</p>
<h2 id="代理服务器（选择方案）"><a href="#代理服务器（选择方案）" class="headerlink" title="代理服务器（选择方案）"></a>代理服务器（选择方案）</h2><p>最后我采用的是这个方案，参考 <a href="https://zhuanlan.zhihu.com/p/87559002" target="_blank" rel="noopener">这篇教程</a>。如果你手里有一台海外的VPS，就非常简单。</p>
<h3 id="本地代理加速"><a href="#本地代理加速" class="headerlink" title="本地代理加速"></a>本地代理加速</h3><p><strong>第一步: 查看你的连接工具的监听端口</strong></p>
<p>连接 VPS 的工具各不相同，这里以最常使用的 <code>shadowssocks</code> 为例，选择 <code>偏好设置-&gt;高级</code> 就可以查看 socks5 监听的端口。</p>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200507235526.png" style="zoom:50%;" />

<p><strong>第二步：设置代理转发的端口</strong></p>
<p><strong>设置全局代理</strong></p>
<p>全局代理设置后，所有 git 的 http/https 都会走我们的代理端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SOCKS5 协议，1080 端口修改成自己的本地 SOCKS5 代理端口</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP 协议，1081 端口修改成自己的本地 HTTP 代理端口</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1081</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1081</span><br></pre></td></tr></table></figure>

<p><strong>设置局部代理</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SOCKS5 协议，1080 端口修改成自己的本地 SOCKS5 代理端口</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP 协议，1081 端口修改成自己的本地 HTTP 代理端口</span></span><br><span class="line">git config --global http.https://github.com.proxy https://127.0.0.1:1081</span><br><span class="line">git config --global https.https://github.com.proxy https://127.0.0.1:1081</span><br></pre></td></tr></table></figure>

<p>设置后，我们可以打开 <code>~/.gitconfig</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[http &quot;https://github.com&quot;]</span><br><span class="line">        proxy = socks5://127.0.0.1:1080</span><br><span class="line">[https &quot;https://github.com&quot;]</span><br><span class="line">        proxy = socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>或者 <code>git config --global -l</code> 查看配置是否生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.https://github.com.proxy=socks5://127.0.0.1:1080</span><br><span class="line">https.https://github.com.proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p><strong>取消代理</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消局部代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.https://github.com.proxy</span><br><span class="line"><span class="comment"># 取消全局代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h3 id="远程代理加速"><a href="#远程代理加速" class="headerlink" title="远程代理加速"></a>远程代理加速</h3><p>本地代理的话，对于在个人电脑上开发是很有帮助的。但是如果服务器也要 <code>git加速</code> 的话就比较麻烦了，还要在服务器上配置一遍本地代理。与其这样做，不如直接在服务器端开一个代理来的方便。</p>
<h4 id="服务器端的基本配置"><a href="#服务器端的基本配置" class="headerlink" title="服务器端的基本配置"></a>服务器端的基本配置</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># 安装 shadowsocks</span><br><span class="line">sudo pip install shadowsocks</span><br><span class="line"># 创建配置文件</span><br><span class="line">&#123;</span><br><span class="line">    "server":"*.*.*.*",</span><br><span class="line">    "server_port":***,</span><br><span class="line"><span class="addition">+    "local_server":"0.0.0.0", # 默认127.0.0.1</span></span><br><span class="line">    "local_port":1081,</span><br><span class="line">    "password":"<span class="comment">*****",</span></span><br><span class="line"><span class="comment">    "timeout":600,</span></span><br><span class="line"><span class="comment">    "method":"aes-256-cfb"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="comment">nohup /root/miniconda2/envs/base/bin/sslocal -c ss.json &gt;&gt; ss.log 1&gt;2&amp;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 这里需要添加一行配置，<code>0.0.0.0</code> 表示监听所有端口，原先默认 <code>127.0.0.1</code> 只监听本地端口</p>
<p>P.S. 查看服务器绑定端口的命令:  <code>netstat -tunlp</code><br><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200508005806.png" alt=""></p>
</blockquote>
<p>有了远端代理，所有东西突然就方便了很多。所有的配置都只要走 <code>x.x.x.x:1081</code> 转发一下就可以了。因为我们本地的代理并不是会一直开着的，而远端的代理是一直存在的。</p>
<h3 id="Baacloud-加速"><a href="#Baacloud-加速" class="headerlink" title="Baacloud 加速"></a>Baacloud 加速</h3><p>由于我是用的我弟弟的 Baacloud，这种FQ工具提供的不是一台机器，而是多台机器的地址。由于有很多人用，所以每个节点拥挤程度不同。我自己编了一个小脚本，获取每个节点的 PING 值，选择延时最低的节点连接。</p>
<p>具体的文章后续更新</p>
<ul>
<li><input disabled="" type="checkbox"> Baacloud 优化方法</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>经过测试下来，我的 github 拉代码的速度从 4kb 一下子提到了 100+ kb/s。有人觉得这个速度也并不快，但是实际上已经达到了速度的上线了。</p>
<p>我远端服务器使用的是国内腾讯云的服务器 (学生优惠时候办的)，但是只有 1M 的小水管 (带宽的上限制也就是125kb/s) ，所以 git 也到达满速了。</p>
<p>经过这个事情，我比较了一下国内外VPS的价格，发现除了考虑 硬盘/内存 以外，国内外的VPS带宽的差距是真的打。国内的带宽普遍是1/2M的小水管，国外的都能到达 1G。</p>
<p>后续我可能考虑找一个稳定的海外VPS重新搞一下。</p>
<h2 id="Socks5-http-https代理的区别"><a href="#Socks5-http-https代理的区别" class="headerlink" title="Socks5/http/https代理的区别"></a>Socks5/http/https代理的区别</h2><blockquote>
<p>作者：黎明<br>链接：<a href="https://www.zhihu.com/question/65960461/answer/505625432" target="_blank" rel="noopener">https://www.zhihu.com/question/65960461/answer/505625432</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>知乎上看到一个回答</p>
<p> HTTP 代理是基于 HTTP 协议的，属于<strong>应用层协议</strong>，一般只会代理转发 HTTP 请求，也可以通过CONNECT 方法来实现一般 TCP 的代理转发。</p>
<p>而 Socks5 代理则相对底层一些，属于 <strong>会话层协议</strong> ，它直接通过协议握手来进行连接，并直接修改报头来实现转发，所以速度非常快，并且支持对 FTP 甚至是 UDP 进行代理转发，功能比 HTTP 代理要强大很多。</p>
<p>两个代理在 OSI 模型中的位置：</p>
<p><strong>物理层 &lt; 数据链路层 &lt; 网络层 &lt; 传输层 &lt; 会话层[socks5] &lt; 表示层 &lt; 应用层[http]</strong></p>
<p>实际使用时，一般建议是在支持的时候使用 Socks5，不支持 Socks5 的话就用 HTTP。</p>
<h2 id="腾讯云被封"><a href="#腾讯云被封" class="headerlink" title="腾讯云被封"></a>腾讯云被封</h2><p>博客写好没一天，我的这个远程代理就被腾讯云检测到了。不知道是哪个”用户”举报的我。为了解决这个方法，我感觉最好的还是买一个国外的VPS。</p>
<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200508183725.png" style="zoom:50%;" />

<h3 id="方案流程图"><a href="#方案流程图" class="headerlink" title="方案流程图"></a>方案流程图</h3><p>为了不让腾讯云发现的话，可以选择使用 frp 代理，在腾讯云上做一个端口转发，发到我家里闲置的电脑上，然后在本地搭代理。这样饶了一圈，会特别烦，但是应该可以躲避腾讯云的监控（虽然我不知道怎么被发现的）。</p>
<p>此外，socks5 代理开启的时候，最好要加上演验证策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200508190504.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/87559002" target="_blank" rel="noopener">Git 命令行加速</a></p>
<p><a href="https://www.zhihu.com/question/65960461/answer/505625432" target="_blank" rel="noopener">Socks5/http/https代理的区别</a></p>
<p>知乎上还有一位大佬深入整理了一套代理的技术文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/28645864" target="_blank" rel="noopener">由浅入深写代理(3) -socks5 代理</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python并发编程——多进程编程 multiprocessing 模块</title>
    <url>/2020/04/05/python-multiprocessing-basic/</url>
    <content><![CDATA[<p>Python 并发编程可以分为三块：多进程编程，多线程编程，多协程编程。前两者是由于操作系统控制的，协程是由用户控制。所以在多进程的编程上，不同操作系统的效果不一样。如果是为了学习多进程编辑，建议在Mac Os 或者 Linux 上。</p>
<p>本篇介绍基于进程的并行操作，主要用到的模块是 <code>multiprocessing</code> </p>
<a id="more"></a>

<h2 id="简单多进程编程"><a href="#简单多进程编程" class="headerlink" title="简单多进程编程"></a>简单多进程编程</h2><p>简单多进程用 <code>Process</code>  和 <code>Pool</code> 两个基础类就可以实现</p>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()  <span class="comment"># 启动进程</span></span><br><span class="line">    p.join()  <span class="comment"># 阻塞进程，只有当本次进程完成后才运行下一进程。进程同步逻辑。</span></span><br></pre></td></tr></table></figure>

<p>下面我们可以详细看看 Process 类的属性，构造方法和方法</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">Process</span><span class="params">(group=None, target=None, name=None, args=<span class="params">()</span>, kwargs=&#123;&#125;, *, daemon=None)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>group</em>    兼容逻辑，始终设置为None</p>
</li>
<li><p><em>target</em>     目标函数</p>
</li>
<li><p><em>args, kwargs</em>    传入目标函数的参数，列表参数和字典参数</p>
</li>
<li><p><em>name</em>   进程名称</p>
</li>
<li><p><em>daemon</em>  后台运行，守护进程。若 daemon =True，该进程会一直存在于主进程中，伴随着父进程终止而终止。</p>
<blockquote>
<p>Tips： 守护进程</p>
<p>主进程结束后，子进程不一定会运行结束。如果我们需要让父进程终止的时候，可以设置子进程为守护进程。注意的是，守护进程不能够再创造子进程了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multiprocessing.Process(group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>, args=(), kwargs=&#123;&#125;, *, daemon=<span class="literal">True</span>) <span class="comment"># 创建Process类时设置</span></span><br><span class="line">p.daemon = <span class="literal">True</span> <span class="comment"># 主动设置deemon 属性</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><em>pid</em>  进程ID</li>
<li><em>name</em>  进程名</li>
<li><em>deamon</em> 设置后台守护进程</li>
<li><em>exitcode</em> 子进程退出代码。如果进程尚未终止，这将是 <code>None</code> 。负值 <em>-N</em> 表示孩子被信号 <em>N</em> 终止。</li>
</ul>
<p>我们可以轻松的通过访问任一 Process 类的变量获取基本信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multiprocessing.current_process().pid</span><br><span class="line">multiprocessing.current_process().name</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>run()  进程活动的方法</p>
<blockquote>
<p>通过重载 run 方法实现进程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        name = multiprocessing.current_process().name</span><br><span class="line">        pid = multiprocessing.current_process().pid</span><br><span class="line">        print(<span class="string">f'name:<span class="subst">&#123;name&#125;</span>, pid:<span class="subst">&#123;pid&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     p = MyProcess()</span><br><span class="line">     p.start()</span><br><span class="line">     p.join()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，尽管我们修改的是 run 方法。我们启动进程的方法还是 p.start</p>
</blockquote>
</li>
<li><p>start()   启动进程</p>
</li>
<li><p>join([timeout]) 进程阻塞，直到进程终止。</p>
<p>timeout 是阻塞的时间，默认None，一直阻塞直到进程终止。</p>
</li>
<li><p>is_alive()  进程存在返回 True， 否则 False</p>
</li>
<li><p>terminate()/kill() 在Unix上，这是使用 <code>SIGTERM</code> 信号完成的</p>
</li>
<li><p>close() 关闭 <code>Process</code>对象，释放与之关联的所有资源</p>
</li>
</ul>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果需要运行多个子进程，采用进程池 <code>Pool</code> 的方式可以节省程序开销。进程的创建和销毁都是需要操作系统资源的。</p>
<h4 id="进程池Pool-vs-Process"><a href="#进程池Pool-vs-Process" class="headerlink" title="进程池Pool vs Process"></a>进程池Pool vs Process</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"%s is now running, process id: %s"</span> % (msg, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    po = multiprocessing.Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        po.apply_async(worker, args=(i,))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"main process starting...."</span>)</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"main process stoping...."</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">''' 输出</span></span><br><span class="line"><span class="string">main process starting....</span></span><br><span class="line"><span class="string">0 is now running, process id: 3436</span></span><br><span class="line"><span class="string">1 is now running, process id: 3437</span></span><br><span class="line"><span class="string">2 is now running, process id: 3438</span></span><br><span class="line"><span class="string">4 is now running, process id: 3436</span></span><br><span class="line"><span class="string">3 is now running, process id: 3439</span></span><br><span class="line"><span class="string">5 is now running, process id: 3437</span></span><br><span class="line"><span class="string">6 is now running, process id: 3438</span></span><br><span class="line"><span class="string">7 is now running, process id: 3436</span></span><br><span class="line"><span class="string">8 is now running, process id: 3437</span></span><br><span class="line"><span class="string">9 is now running, process id: 3439</span></span><br><span class="line"><span class="string">main process stoping....</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>使用进程池的优点提现在</p>
<ul>
<li><p>限制同一时间进程并行的数目<br>多进程可以提高程序运行的效率，但是过多的进程切换反而会降低效率。原因是a.进程会占用计算机资源，资源决定了进程不能开启过多。b.进程的切换开销比较大，占用过多CPU资源。</p>
</li>
<li><p>进程池减少不必要的创建，销毁过程。</p>
<p>程序中，Pool(4) 的进程号只有 3436，3437，3438，3439 这四个进程号。证明进程池省去了创建和销毁的过程。</p>
</li>
</ul>
<p>当进程数和计算机的内核数一致的时候，效率最高。我们可以先看看自己计算机的内核个数，使用 <code>os.cpu_count()</code> 或者 <code>multiprocess.cpu_count()</code> 来查看内核个数。<br>如果不填写内核参数，Pool 默认采取机器的内核个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line">p = Pool(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p.apply_async(f, args=(i,))  <span class="comment"># 异步调用</span></span><br><span class="line">    p.apply(f, args=(i,)) <span class="comment"># 同步调用</span></span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">pool</span>.<span class="title">Pool</span><span class="params">([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</span></span></span><br><span class="line"><span class="class"># 一个进程池对象，它控制可以提交作业的工作进程池。它支持带有超时和回调的异步结果，以及一个并行的 <span class="title">map</span> 实现。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>processes 进程数，默认采用 <code>os.cpu_count()</code></li>
<li>initializer(*initargs) 进程池调用前的初始化方法</li>
</ul>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>apply(<em>func</em>[, <em>args</em>[, <em>kwds</em>]]) </p>
<p>返回结果前阻塞。这种情况下，<a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" target="_blank" rel="noopener"><code>apply_async()</code></a> 更适合并行化工作。另外 <em>func</em> 只会在一个进程池中的一个工作进程中执行。</p>
</li>
<li><p>apply_async(<em>func</em>[, <em>args</em>[, <em>kwds</em>[, <em>callback</em>[, <em>error_callback</em>]]]])  非阻塞操作</p>
<p>callback 是一个只接受一个参数的可调用对象。成功则执行callback，失败执行 error_callback</p>
</li>
<li><p>map(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>]) </p>
<p>内置函数 <code>map</code> 的并行版本，map会 <strong>保持阻塞</strong> 直到获得结果。</p>
<p><em>iterable</em> 可以切分成多块运行，chunksize 指定块的大小。</p>
<p>当 iterable 太大的时候，为了节省内存，可以使用 imap 和 imap_unordered</p>
</li>
<li><p>map_async(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>[, <em>callback</em>[, <em>error_callback</em>]]]) </p>
<p>map 的对应的<strong>异步</strong>回调方法</p>
</li>
<li><p>imap(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>] 需要显式的设置 chunksize，可以极大的加快 map  的速度。原先map中的默认值为1。</p>
</li>
<li><p>imap_unordered    imap 的无序版本</p>
</li>
</ul>
<blockquote>
<p>apply_async 和 map_async 除了是异步执行的以外，它们还会放回一个 <strong>AsyncResult</strong> 对象，它有如下方法</p>
</blockquote>
<ul>
<li>get([<em>timeout</em>]) 获取执行的结果</li>
<li>wait([<em>timeout</em>]) 阻塞，直到返回结果</li>
<li>ready 是否已完成结果</li>
<li>successful 是否已完成且没有发生异常</li>
</ul>
<h2 id="进程间通信——数据传递"><a href="#进程间通信——数据传递" class="headerlink" title="进程间通信——数据传递"></a>进程间通信——数据传递</h2><p>multiprocessing  支持两种通信方式：Queue(队列) , Pipe(管道) </p>
<h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q = Queue(maxsize=<span class="number">4</span>)</span><br><span class="line">q.put(obj, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>) <span class="comment"># 存入队列中</span></span><br><span class="line">q.get(obj, block=<span class="literal">False</span>) <span class="comment"># 读取队列</span></span><br><span class="line"><span class="comment"># block: 是否主动阻塞，阻塞的时间为timeout。timeout=None 代表一直阻塞。block为 False 的时候，会主动抛出 queue.Full 和 queue.Empty 的错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pipe 建立的是一个双全工的连接</span></span><br><span class="line">parent_conn, child_conn = Pipe()</span><br><span class="line">parent_conn.send([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>]) <span class="comment"># 发送</span></span><br><span class="line">parent_conn.close() <span class="comment"># 关闭 一端的连接，关闭后不可以再次进行 send 和 recv 操作</span></span><br><span class="line">child_conn.recv() <span class="comment"># 接收</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，Pipe 是只能在两个进程进行通信，而 Queue 可以支持多个队列。Pipe 解决了进程之间的通信问题，Queue 还加上了一个缓冲区的作用。</p>
</blockquote>
<p>那么multiprocessing.Queue 和 标准库中的 queue 的区别是什么？</p>
<ol>
<li>需要注意的是这里是多进程编程，进程是资源分配的最小单位。不同的进程是无法获取对方堆栈的。Queue 可以解决这一个数据共享的问题。如果我们现在采用的是多线程编程，那么就可以直接采用标准库的queue 来替代。</li>
<li>multiprocessing 中的 Queue 实现了标准库中的 queue 中的所有方法，除了<code>task_done</code> 和 <code>join</code> 方法</li>
</ol>
<h3 id="Pipe-的使用"><a href="#Pipe-的使用" class="headerlink" title="Pipe 的使用"></a>Pipe 的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn1, conn2 = multiprocessing.Pipe([duplex])</span><br><span class="line"><span class="comment"># 返回 Connection 对象 conn1,conn2 分别代表管道的两端。Connection 类型</span></span><br><span class="line"><span class="keyword">while</span> conn1.poll():</span><br><span class="line">   conn1.recv()</span><br></pre></td></tr></table></figure>

<p>duplex: True 代表双全工，即管道的两端是可以双向的通信的。False 代表单向， <code>conn1</code> 只能用于接收消息，而 <code>conn2</code> 仅能用于发送消息。</p>
<p><strong>Connect 对象的方法有</strong></p>
<ul>
<li><p>send/recv 发送的对象必须是可序列化的</p>
</li>
<li><p>send_bytes(<em>buffer</em>[, <em>offset</em>[, <em>size<em>]]) / recv_bytes([</em>maxlength<em>]) / <code>recv_bytes_into</code>(</em>buffer</em>[, <em>offset</em>]) </p>
<p>发送 和 接受 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 字节类对象</p>
</li>
<li><p>poll([<em>timeout</em>]) 返回连接对象中是否有可以读取的数据</p>
</li>
<li><p>close() 关闭</p>
</li>
</ul>
<blockquote>
<p>注意的一点是，Connect 的仅仅支持少量数据的发送，对于多大的对象（32M+），可能会引发异常</p>
</blockquote>
<h3 id="Queue-的使用"><a href="#Queue-的使用" class="headerlink" title="Queue 的使用"></a>Queue 的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiprocessing</span>.<span class="title">Queue</span><span class="params">([maxsize])</span></span></span><br></pre></td></tr></table></figure>

<p>主要实现了如下属性&amp;方法，基本和 queue 一样</p>
<ul>
<li><p>qsize 队列大小，由于是多进程的上下文，这个数字不是很可靠，而且在Mac OS X 上可能存在异常。</p>
</li>
<li><p>empty 是否为空</p>
</li>
<li><p>full 是否为满</p>
</li>
<li><p>put(<em>obj</em>[, <em>block</em>[, <em>timeout</em>]])  当没有可用缓冲槽的时，抛出 <a href="https://docs.python.org/zh-cn/3.7/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>queue.Empty</code></a> 异常</p>
<p>put_nowait(<em>obj</em>) 等价于 put(obj, False)</p>
</li>
<li><p>get([<em>block</em>[, <em>timeout</em>]]) 当没有可取用对象时，抛出 <a href="https://docs.python.org/zh-cn/3.7/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>queue.Empty</code></a> 异常</p>
<p>get_nowait() 等价于 get(False)</p>
</li>
<li><p>close() 指示当前进程将不会再往队列中放入对象</p>
</li>
</ul>
<h3 id="Queue的几种变形"><a href="#Queue的几种变形" class="headerlink" title="Queue的几种变形"></a>Queue的几种变形</h3><ol>
<li><p>multiprocessing.SimpleQueue() 简化的队列，其只具有empty、get、put3个方法。</p>
<p>这个队列实际上是用 Pipe 实现的</p>
</li>
<li><p>multiprocessing.JoinableQueue(maxsize=0)  建立<strong>可阻塞的队列实例</strong>，采用一般队列的方式访问。加上了 <code>join</code>  和 <code>task_done</code> 两个方法。</p>
</li>
</ol>
<h2 id="进程间通信——数据共享"><a href="#进程间通信——数据共享" class="headerlink" title="进程间通信——数据共享"></a>进程间通信——数据共享</h2><p>进程间的通信 Pipe 和 Queue 能解决小批量数据的传输，如 <strong>Pipe.send() 方法发送的数据一般不超过 32M</strong>。对于大量的数据，可以借助 <code>共享内存</code> 和 <code>Manager 类</code>实现。<code>Manager</code>实现了两个重要的类型 <code>list</code> 和 <code>dict</code>。</p>
<h3 id="Manager-类（共享进程）"><a href="#Manager-类（共享进程）" class="headerlink" title="Manager 类（共享进程）"></a>Manager 类（共享进程）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(list, x)</span>:</span></span><br><span class="line">    print(list, x)</span><br><span class="line">    list.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     manager = multiprocessing.Manager()</span><br><span class="line">     mag_list = manager.list([]) </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">     <span class="keyword">with</span> multiprocessing.Pool(<span class="number">4</span>) <span class="keyword">as</span> p:</span><br><span class="line">         <span class="keyword">for</span> item <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">            p.apply(f, args=(mag_list, item))</span><br><span class="line">         p.close()</span><br><span class="line">     print(mag_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># [] 1</span></span><br><span class="line"><span class="comment"># [1] 2</span></span><br><span class="line"><span class="comment"># [1, 2] 3</span></span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以尝试 mag_list=[] ,最后的结果是不会发生任何变化</span></span><br><span class="line"><span class="comment"># [] 1</span></span><br><span class="line"><span class="comment"># [] 2</span></span><br><span class="line"><span class="comment"># [] 3</span></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>

<h3 id="Value-Array（共享内存）"><a href="#Value-Array（共享内存）" class="headerlink" title="Value, Array（共享内存）"></a>Value, Array（共享内存）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multiprocessing.Value(typecode_or_type, *args, lock=<span class="literal">True</span>)</span><br><span class="line">multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>typecode_or_type  类型码</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200406150352.png" alt=""></p>
</li>
<li><p>size_or_initializer 大小，或者初始化操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multiprocessing.Array(<span class="string">'i'</span>, <span class="number">3</span>) <span class="comment"># 结果 [0,0,0]</span></span><br><span class="line">multiprocessing.Array(<span class="string">'i'</span>, range(<span class="number">3</span>)) <span class="comment"># 结果 [0,1,2]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Lock 锁操作，在修改访问数据的时候，通过设置为 True 能锁定资源，阻塞其他进程的访问。</p>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = multiprocessing.Value(<span class="string">'d'</span>, <span class="number">10</span>, lock=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> v.get_lock(): <span class="comment"># 修改值前，加锁</span></span><br><span class="line">    v.value += <span class="number">1</span>  <span class="comment"># 属性 value 取值</span></span><br></pre></td></tr></table></figure>



<h2 id="数据进程锁"><a href="#数据进程锁" class="headerlink" title="数据进程锁"></a>数据进程锁</h2><p>上一部分解决了进程间共享数据的操作。但是不同进程若是需要对于共享数据进行修改，可能会发生冲突。解决这一类问题的方式就是在 重要数据修改的时候加上锁，修改完毕再释放。</p>
<p>multiprocessing 的 互斥&amp;同步操作有： <code>Lock</code>,  <code>Semaphore</code> , <code>Event</code> 和 <code>Barrier</code></p>
<h3 id="Lock-原始锁"><a href="#Lock-原始锁" class="headerlink" title="Lock 原始锁"></a>Lock 原始锁</h3><p>原始锁（非递归锁）对象，一旦一个进程或者线程拿到了锁，后续的任何其他进程或线程的其他请求都会被阻塞直到锁被释放。<strong>任何进程或线程都可以释放锁。</strong></p>
<blockquote>
<p>Lock 一般只针对一个资源同步访问</p>
</blockquote>
<h3 id="RLock-递归锁"><a href="#RLock-递归锁" class="headerlink" title="RLock 递归锁"></a>RLock 递归锁</h3><p><strong>递归锁必须由持有线程、进程亲自释放。</strong>递归锁和原始锁的区别是，一个进程可以多次加锁，每次加锁，锁加一。每次释放，锁减一。所以当获得锁和释放锁的数量相等的时候，才能释放锁住的资源。使用方法和Lock 一样。</p>
<h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><p>Semaphore 一般是针对多个(有限)资源的访问的，它的操作和Lock一样。只是初始化的时候，需要给出型号量的初始值。可以认为Semaphore(1) 和 RLock是相同的。</p>
<blockquote>
<p>上面三个锁的使用方法都可以使用 acquire/release 操作</p>
</blockquote>
<h3 id="Barrier-屏障"><a href="#Barrier-屏障" class="headerlink" title="Barrier 屏障"></a>Barrier 屏障</h3><p>当若干个进程没有到达屏障点的时候，会自动阻塞，一旦到达屏障点，将会自动解除阻塞并启动运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200406020450.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threading</span>.<span class="title">Barrier</span><span class="params">(parties, action=None, timeout=None)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>parties  栅栏的个数</li>
<li>action  当突破栅栏后，会在被释放的其中一个进程中运行</li>
</ul>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li>n_waiting  当前时刻正在栅栏中阻塞的线程数量。</li>
<li>broken  值为 <code>True</code> 表明栅栏为破损态。</li>
</ul>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li>wait(<em>timeout=None</em>) 阻塞操作，函数会返回一个范围在 0~parties-1 内的整数。当为0 的时候，代表栅栏破裂</li>
<li>reset() 重置为初始状态</li>
<li>abort() 与reset() 相反，设置为破损状态</li>
</ul>
<h3 id="Event-事件锁"><a href="#Event-事件锁" class="headerlink" title="Event 事件锁"></a>Event 事件锁</h3><p>这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li>is_set()   判断内部标识位是否为True</li>
<li>set()  设置内部标识位为True</li>
<li>clear()  设置内部标识位为False</li>
<li>wait()  阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>由于之前没有接触过Event，这里自己练手写了一个Event 的小例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(e, car_id)</span>:</span></span><br><span class="line">    print(<span class="string">f'car <span class="subst">&#123;car_id&#125;</span> is coming '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> e.is_set():</span><br><span class="line">        print(<span class="string">f'car <span class="subst">&#123;car_id&#125;</span> is waiting'</span>)</span><br><span class="line">        e.wait()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> e.is_set():</span><br><span class="line">        print(<span class="string">f'car <span class="subst">&#123;car_id&#125;</span> pass the cross road'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traffic_light</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    红绿灯切换的时候，e.clear 和 e.set 是成队出现的。</span></span><br><span class="line"><span class="string">    因为红绿本省就是相互同步的一个操作</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 每5秒切换一次红绿灯</span></span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">'&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>)</span><br><span class="line">            e.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> e.is_set():</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">'&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>)</span><br><span class="line">            e.set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = multiprocessing.Event()</span><br><span class="line">    event.clear()  <span class="comment"># 默认设置红灯</span></span><br><span class="line">    cars = [multiprocessing.Process(target=car, args=(event,car_id)) <span class="keyword">for</span> car_id <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    lights = multiprocessing.Process(target=traffic_light, args=(event,))</span><br><span class="line">    lights.daemon = <span class="literal">True</span>  <span class="comment"># 设置完这一步，可以在小汽车都开走后，结束整个程序。</span></span><br><span class="line">    lights.start()</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> cars:</span><br><span class="line">        each.start()</span><br><span class="line">        time.sleep(<span class="number">1</span>) <span class="comment"># 间隔一秒钟发车</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> cars:</span><br><span class="line">        each.join()</span><br><span class="line">    <span class="comment"># 当 each.join 执行完毕，此时 traffic_light 还在后台运行</span></span><br><span class="line">    <span class="comment"># 但是由于没有添加 traffic_light.join() 所以此时 mian 结束，带着守护进程 traffic_light一起结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">car <span class="number">0</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">0</span> <span class="keyword">is</span> waiting</span><br><span class="line">car <span class="number">1</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">1</span> <span class="keyword">is</span> waiting</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">....</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">car <span class="number">8</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">8</span> <span class="keyword">is</span> waiting</span><br><span class="line">car <span class="number">9</span> <span class="keyword">is</span> coming </span><br><span class="line">car <span class="number">9</span> <span class="keyword">is</span> waiting</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">car <span class="number">8</span> <span class="keyword">pass</span> the cross road</span><br><span class="line">car <span class="number">9</span> <span class="keyword">pass</span> the cross road</span><br></pre></td></tr></table></figure>

<p>如果我们不启动守护进程，而是一直让程序在后台运行。这样我们可以感受到  <strong>守护进程</strong>  的作用</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> cars = [multiprocessing.Process(target=car, args=(event,car_id)) for car_id in range(10)]</span><br><span class="line"> lights = multiprocessing.Process(target=traffic_light, args=(event,))</span><br><span class="line"><span class="deletion">-   lights.daemon = True  # 设置完这一步，可以在小汽车都开走后，结束整个程序。</span></span><br><span class="line">    lights.start()</span><br><span class="line">    for each in cars:</span><br><span class="line">        each.start()</span><br><span class="line">        time.sleep(1) # 间隔一秒钟发车</span><br><span class="line"></span><br><span class="line">    for each in cars:</span><br><span class="line">        each.join()</span><br><span class="line"><span class="addition">+   lights.join() # </span></span><br><span class="line"># 输出结果如下</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">car 9 pass the cross road</span><br><span class="line">car 8 pass the cross road</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; green to red &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; red to green &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Condition-条件锁"><a href="#Condition-条件锁" class="headerlink" title="Condition 条件锁"></a>Condition 条件锁</h3><h3 id="几种方法的比较"><a href="#几种方法的比较" class="headerlink" title="几种方法的比较"></a>几种方法的比较</h3><table>
<thead>
<tr>
<th>方法</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Lock</td>
<td>原始锁</td>
<td>当多个进程需要访问共享资源的时候，、</td>
</tr>
<tr>
<td>RLock</td>
<td>递归锁</td>
<td>Lock 的升级</td>
</tr>
<tr>
<td>Semaphore</td>
<td>信号量（计数器锁）</td>
<td>Semaphore用来控制对共享资源的访问数量，例如池的最大连接数。</td>
</tr>
<tr>
<td>Barrier</td>
<td>时间锁</td>
<td>进程间同步通信</td>
</tr>
<tr>
<td>Barrier</td>
<td>障碍锁</td>
<td>等待足够资源启动</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#cleanup" target="_blank" rel="noopener">python官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1pJ411h7YS?p=17" target="_blank" rel="noopener">B站【李兴华编程训练营】Python并发编程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/46798399" target="_blank" rel="noopener">知乎python并行计算（上）：multiprocessing、multiprocess模块</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 常用命令</title>
    <url>/2020/03/01/mysql-freq-command/</url>
    <content><![CDATA[<p>慢慢总结常用的的mysql 命令，看做是平时工作的“缓存”</p>
<a id="more"></a>

<h2 id="修改密码强度"><a href="#修改密码强度" class="headerlink" title="修改密码强度"></a>修改密码强度</h2><p>修改密码强度一般是mysql5.7 升级到 mysql8.0，或者是刚刚安装mysql8.0时候很容易碰到的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看密码需要满足的条件</span><br><span class="line">SHOW VARIABLES LIKE &apos;validate_password%&apos;; </span><br><span class="line"></span><br><span class="line"># validate_password_policy代表密码策略，默认是1：符合长度，且必须含有数字，小写或大写字母，特殊字符。设置为0判断密码的标准就基于密码的长度了。一定要先修改两个参数再修改密码</span><br><span class="line">set global validate_password.policy=0;</span><br><span class="line"></span><br><span class="line"># validate_password_length代表密码长度，最小值为4</span><br><span class="line">set global validate_password.length=4;</span><br></pre></td></tr></table></figure>



<h2 id="yum安装mysql-下载速度慢"><a href="#yum安装mysql-下载速度慢" class="headerlink" title="yum安装mysql 下载速度慢"></a>yum安装mysql 下载速度慢</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份系统自带yum源配置文件</span></span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="comment"># 下载ailiyun的yum源配置文件(阿里云速度比较快)</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="comment"># 生成缓存</span></span><br><span class="line">yum makecache</span><br><span class="line"><span class="comment"># yum 升级</span></span><br><span class="line">yum -y update</span><br><span class="line"><span class="comment"># 安装yum</span></span><br><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure>







<h2 id="创建新的用户"><a href="#创建新的用户" class="headerlink" title="创建新的用户"></a>创建新的用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建新用户 reader01， 赋予密码&apos;onlyread@123&apos;</span><br><span class="line">CREATE USER `reader01`@`%` IDENTIFIED by &apos;onlyread@123&apos;;</span><br><span class="line"># 赋予 select 权限， 赋予nongwei_syn所有数据表的访问权限</span><br><span class="line">GRANT SELECT ON `nongwei_syn`.* TO `reader01`@`%` ;</span><br><span class="line"># 降低 mysql 加密规则</span><br><span class="line">ALTER USER `reader01`@`%` IDENTIFIED WITH mysql_native_password BY &apos;onlyread@123&apos;;</span><br><span class="line"># 刷新一下权限</span><br><span class="line">flush privileges;</span><br><span class="line"># 查看用户的权限</span><br><span class="line">show grants for reader01;</span><br><span class="line">GRANT USAGE ON *.* TO `reader01`@`%`</span><br><span class="line">GRANT SELECT ON `nongwei_syn`.* TO `reader01`@`%`</span><br></pre></td></tr></table></figure>



<h2 id="数据字典显示"><a href="#数据字典显示" class="headerlink" title="数据字典显示"></a>数据字典显示</h2><p><strong>显示字段的详细信息（包含COMMENT）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show full columns from d_dbname.t_table_name</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200322184343.png" alt=""></p>
<p>建议每次建表的时候，都带上COMMENT</p>
<p>如果你一开始并没有这样做的话，需要借助 <code>alter</code> 来添加 <code>COMMENT</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table `d_dbname`.`t_table_name` modify column foodtype   varchar(20)                              COMMENT &apos;品种&apos;;</span><br></pre></td></tr></table></figure>

<p><strong>显示建表的SQL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table  `d_dbname`.`t_table_name`</span><br><span class="line"></span><br><span class="line"># output:</span><br><span class="line">CREATE TABLE `t_vegnet_price_202003` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT COMMENT &apos;序号&apos;,</span><br><span class="line">  `foodtype` varchar(20) DEFAULT NULL COMMENT &apos;品种&apos;,</span><br><span class="line">  `market` varchar(30) DEFAULT NULL COMMENT &apos;批发市场&apos;,</span><br><span class="line">  `lprice` float(10,2) DEFAULT NULL COMMENT &apos;最低价&apos;,</span><br><span class="line">  `hprice` float(10,2) DEFAULT NULL COMMENT &apos;最高价&apos;,</span><br><span class="line">  `avgprice` float(10,2) DEFAULT NULL COMMENT &apos;平均价&apos;,</span><br><span class="line">  `unit` varchar(20) DEFAULT NULL COMMENT &apos;计量单位&apos;,</span><br><span class="line">  `date` varchar(10) DEFAULT NULL COMMENT &apos;日期&apos;,</span><br><span class="line">  `pagenum` int DEFAULT NULL COMMENT &apos;页码&apos;,</span><br><span class="line">  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `date` (`date`,`foodtype`,`market`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=42501 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】 mysql触发器trigger 实例详解</title>
    <url>/2020/03/01/%E8%BD%AC%E8%BD%BD/mysql%E8%A7%A6%E5%8F%91%E5%99%A8trigger%20%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="mysql触发器trigger-实例详解"><a href="#mysql触发器trigger-实例详解" class="headerlink" title="mysql触发器trigger 实例详解"></a><a href="https://www.cnblogs.com/phpper/p/7587031.html" target="_blank" rel="noopener">mysql触发器trigger 实例详解</a></h1><p>MySQL好像从5.0.2版本就开始支持触发器的功能了，本次博客就来介绍一下触发器，首先还是谈下概念性的东西吧：</p>
<h2 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h2><p>触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。</p>
<p>举个例子，比如你现在有两个表【用户表】和【日志表】，当一个用户被创建的时候，就需要在日志表中插入创建的log日志，如果在不使用触发器的情况下，你需要编写程序语言逻辑才能实现，但是如果你定义了一个触发器，触发器的作用就是当你在用户表中插入一条数据的之后帮你在日志表中插入一条日志信息。当然触发器并不是只能进行插入操作，还能执行修改，删除。</p>
<a id="more"></a>

<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>创建触发器的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tb_name FOR EACH ROW trigger_stmt</span><br><span class="line">trigger_name：触发器的名称</span><br><span class="line">tirgger_time：触发时机，为BEFORE或者AFTER</span><br><span class="line">trigger_event：触发事件，为INSERT、DELETE或者UPDATE</span><br><span class="line">tb_name：表示建立触发器的表明，就是在哪张表上建立触发器</span><br><span class="line">trigger_stmt：触发器的程序体，可以是一条SQL语句或者是用BEGIN和END包含的多条语句</span><br><span class="line">所以可以说MySQL创建以下六种触发器：</span><br><span class="line">BEFORE INSERT,BEFORE DELETE,BEFORE UPDATE</span><br><span class="line">AFTER INSERT,AFTER DELETE,AFTER UPDATE</span><br></pre></td></tr></table></figure>

<p>其中，触发器名参数指要创建的触发器的名字</p>
<p>BEFORE和AFTER参数指定了触发执行的时间，在事件之前或是之后</p>
<p>FOR EACH ROW表示任何一条记录上的操作满足触发事件都会触发该触发器</p>
<h5 id="创建有多个执行语句的触发器"><a href="#创建有多个执行语句的触发器" class="headerlink" title="创建有多个执行语句的触发器"></a>创建有多个执行语句的触发器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</span><br><span class="line">ON 表名 FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    执行语句列表</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>其中，BEGIN与END之间的执行语句列表参数表示需要执行的多个语句，不同语句用分号隔开</p>
<p><strong>tips：</strong>一般情况下，mysql默认是以 ; 作为结束执行语句，与触发器中需要的分行起冲突</p>
<p>　　  为解决此问题可用DELIMITER，如：DELIMITER ||，可以将结束符号变成||</p>
<p>　　  当触发器创建完成后，可以用DELIMITER ;来将结束符号变成;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELIMITER ||</span><br><span class="line">mysql&gt; CREATE TRIGGER demo BEFORE DELETE</span><br><span class="line">    -&gt; ON users FOR EACH ROW</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; INSERT INTO logs VALUES(NOW());</span><br><span class="line">    -&gt; INSERT INTO logs VALUES(NOW());</span><br><span class="line">    -&gt; END</span><br><span class="line">    -&gt; ||</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>上面的语句中，开头将结束符号定义为||，中间定义一个触发器，一旦有满足条件的删除操作</p>
<p>就会执行BEGIN和END中的语句，接着使用||结束</p>
<p>最后使用DELIMITER ; 将结束符号还原</p>
<p>tigger_event：</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200301023456.png" alt=""></p>
<p>load data语句是将文件的内容插入到表中，相当于是insert语句，而replace语句在一般的情况下和insert差不多，但是如果表中存在primary 或者unique索引的时候，如果插入的数据和原来的primary key或者unique相同的时候，会删除原来的数据，然后增加一条新的数据，所以有的时候执行一条replace语句相当于执行了一条delete和insert语句。</p>
<p>触发器可以是一条SQL语句，也可以是多条SQL代码块，那如何创建呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $  #将语句的分隔符改为$</span><br><span class="line">BEGIN</span><br><span class="line">sql1;</span><br><span class="line">sql2;</span><br><span class="line">...</span><br><span class="line">sqln</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;  #将语句的分隔符改回原来的分号&quot;;&quot;</span><br></pre></td></tr></table></figure>

<p>在BEGIN…END语句中也可以定义变量，但是只能在BEGIN…END内部使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE var_name var_type [DEFAULT value] #定义变量，可指定默认值</span><br><span class="line">SET var_name = value  #给变量赋值</span><br></pre></td></tr></table></figure>

<p>NEW和OLD的使用:</p>
<p> <img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200301023524.png" alt=""></p>
<p> 根据以上的表格，可以使用一下格式来使用相应的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW.columnname：新增行的某列数据</span><br><span class="line">OLD.columnname：删除行的某列数据</span><br></pre></td></tr></table></figure>

<p>说了这么多现在我们来创建一个触发器吧！</p>
<p>现在有表如下：<br>用户users表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL,</span><br><span class="line">  `add_time` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name` (`name`(250)) USING BTREE</span><br><span class="line">) ENGINE=MyISAM AUTO_INCREMENT=1000001 DEFAULT CHARSET=latin1;</span><br></pre></td></tr></table></figure>

<p>日志logs表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `logs` (</span><br><span class="line">  `Id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `log` varchar(255) DEFAULT NULL COMMENT &apos;日志说明&apos;,</span><br><span class="line">  PRIMARY KEY (`Id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&apos;日志表&apos;;</span><br></pre></td></tr></table></figure>

<p>需求是：当在users中插入一条数据，就会在logs中生成一条日志信息。</p>
<p>创建触发器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE TRIGGER user_log AFTER INSERT ON users FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE s1 VARCHAR(40)character set utf8;</span><br><span class="line">DECLARE s2 VARCHAR(20) character set utf8;#后面发现中文字符编码出现乱码，这里设置字符集</span><br><span class="line">SET s2 = &quot; is created&quot;;</span><br><span class="line">SET s1 = CONCAT(NEW.name,s2);     #函数CONCAT可以将字符串连接</span><br><span class="line">INSERT INTO logs(log) values(s1);</span><br><span class="line">END $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>这里我用的navicat:<br><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200301023620.png" alt=""></p>
<h4 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h4><h5 id="SHOW-TRIGGERS语句查看触发器信息"><a href="#SHOW-TRIGGERS语句查看触发器信息" class="headerlink" title="SHOW TRIGGERS语句查看触发器信息"></a>SHOW TRIGGERS语句查看触发器信息</h5><p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200301023711.png" alt=""></p>
<p>Tip:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面我用的navicat直接创建，如果大家用的mysql front，name这里会有个区别，我们删除刚才的触发器，在Mysql front中测试</span><br><span class="line">drop trigger  user_log;#删除触发器</span><br></pre></td></tr></table></figure>

<p>打开Mysql Front：</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200301023752.png" alt=""></p>
<p>mysql front在编译sql时，不用定义结尾分隔符，修改后的sql直接这样既可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#DELIMITER $</span><br><span class="line">CREATE TRIGGER user_log AFTER INSERT ON users FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE s1 VARCHAR(40)character set utf8;</span><br><span class="line">DECLARE s2 VARCHAR(20) character set utf8;</span><br><span class="line">SET s2 = &quot; is created&quot;;</span><br><span class="line">SET s1 = CONCAT(NEW.name,s2);     #函数CONCAT可以将字符串连接</span><br><span class="line">INSERT INTO logs(log) values(s1);</span><br><span class="line">END #$</span><br><span class="line">#DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200301023832.png" alt=""></p>
<p>这里再啰嗦几句：</p>
<p><strong>tips：</strong>SHOW TRIGGERS语句无法查询指定的触发器</p>
<h5 id="在triggers表中查看触发器信息"><a href="#在triggers表中查看触发器信息" class="headerlink" title="在triggers表中查看触发器信息"></a>在triggers表中查看触发器信息</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.triggers;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2017.cnblogs.com/blog/1102222/201709/1102222-20170924123529415-704881400.png" alt="img"></p>
<p>结果显示了所有触发器的详细信息，同时，该方法可以查询制定触发器的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME=&apos;user_log&apos;;</span><br></pre></td></tr></table></figure>

<p><strong>tips：</strong>所有触发器信息都存储在information_schema数据库下的triggers表中</p>
<p>　　  可以使用SELECT语句查询，如果触发器信息过多，最好通过TRIGGER_NAME字段指定查询</p>
<p>回到上面,我们创建好了触发器,继续在users中插入数据并查看数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into users(name,add_time) values(&apos;周伯通&apos;,now());</span><br></pre></td></tr></table></figure>

<p>好吧，我们再来查看一下logs表吧！</p>
<p><img src="https://images2017.cnblogs.com/blog/1102222/201709/1102222-20170924134754837-519590854.png" alt="img"></p>
<p>通过上面的例子，可以看到只需要在users中插入用户的信息，日志会自动记录到logs表中，这也许就是触发器给我带来的便捷吧！</p>
<h2 id="限制和注意事项"><a href="#限制和注意事项" class="headerlink" title="限制和注意事项"></a>限制和注意事项</h2><p>触发器会有以下两种限制：</p>
<p>1.触发程序不能调用将数据返回客户端的存储程序，也不能使用采用CALL语句的动态SQL语句，但是允许存储程序通过参数将数据返回触发程序，也就是存储过程或者函数通过OUT或者INOUT类型的参数将数据返回触发器是可以的，但是不能调用直接返回数据的过程。</p>
<p>2.不能再触发器中使用以显示或隐式方式开始或结束事务的语句，如START TRANS-ACTION,COMMIT或ROLLBACK。</p>
<p>注意事项：MySQL的触发器是按照BEFORE触发器、行操作、AFTER触发器的顺序执行的，其中任何一步发生错误都不会继续执行剩下的操作，如果对事务表进行的操作，如果出现错误，那么将会被回滚，如果是对非事务表进行操作，那么就无法回滚了，数据可能会出错。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>触发器是基于行触发的，所以删除、新增或者修改操作可能都会激活触发器，所以不要编写过于复杂的触发器，也不要增加过得的触发器，这样会对数据的插入、修改或者删除带来比较严重的影响，同时也会带来可移植性差的后果，所以在设计触发器的时候一定要有所考虑。</p>
<p>触发器是一种特殊的存储过程，它在插入，删除或修改特定表中的数据时触发执行，它比数据库本身标准的功能有更精细和更复杂的数据控制能力。</p>
<p>数据库触发器有以下的作用：</p>
<p>1.安全性。可以基于数据库的值使用户具有操作数据库的某种权利。</p>
<p> # 可以基于时间限制用户的操作，例如不允许下班后和节假日修改数据库数据。</p>
<p> # 可以基于数据库中的数据限制用户的操作，例如不允许股票的价格的升幅一次超过10%。</p>
<p>2.审计。可以跟踪用户对数据库的操作。  </p>
<p> # 审计用户操作数据库的语句。</p>
<p> # 把用户对数据库的更新写入审计表。</p>
<p>3.实现复杂的数据完整性规则</p>
<p> # 实现非标准的数据完整性检查和约束。触发器可产生比规则更为复杂的限制。与规则不同，触发器可以引用列或数据库对象。例如，触发器可回退任何企图吃进超过自己保证金的期货。</p>
<p> # 提供可变的缺省值。</p>
<p>4.实现复杂的非标准的数据库相关完整性规则。触发器可以对数据库中相关的表进行连环更新。例如，在auths表author_code列上的删除触发器可导致相应删除在其它表中的与之匹配的行。</p>
<p> # 在修改或删除时级联修改或删除其它表中的与之匹配的行。</p>
<p> # 在修改或删除时把其它表中的与之匹配的行设成NULL值。</p>
<p> # 在修改或删除时把其它表中的与之匹配的行级联设成缺省值。</p>
<p> # 触发器能够拒绝或回退那些破坏相关完整性的变化，取消试图进行数据更新的事务。当插入一个与其主健不匹配的外部键时，这种触发器会起作用。例如，可以在books.author_code 列上生成一个插入触发器，如果新值与auths.author_code列中的某值不匹配时，插入被回退。</p>
<p>5.同步实时地复制表中的数据。</p>
<p>6.自动计算数据值，如果数据的值达到了一定的要求，则进行特定的处理。例如，如果公司的帐号上的资金低于5万元则立即给财务人员发送警告数据。</p>
<p>无论从事什么行业，只要做好两件事就够了，一个是你的专业、一个是你的人品，专业决定了你的存在，人品决定了你的人脉，剩下的就是坚持，用善良專業和真诚赢取更多的信任。</p>
<p>分类: <a href="https://www.cnblogs.com/phpper/category/944100.html" target="_blank" rel="noopener">mysql笔记</a></p>
<p>标签: <a href="https://www.cnblogs.com/phpper/tag/mysql/" target="_blank" rel="noopener">mysql</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>转载</tag>
        <tag>数据库同步</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建elasticsearch+kibana</title>
    <url>/2020/02/25/docker-elasticsearch-Kibana-installation/</url>
    <content><![CDATA[<p>工作中需要对公司的es服务器进行配置，小白不敢直接在公司的开发机上直接修改。故需要在测试机上临时搭建一个es+kibana环境。</p>
<p>为了避开基础的环境问题和快速搭建，docker是我们非常好的伙伴</p>
<a id="more"></a>

<h2 id="elasticsearch安装"><a href="#elasticsearch安装" class="headerlink" title="elasticsearch安装"></a>elasticsearch安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:6.6.1</span><br></pre></td></tr></table></figure>

<p>创建配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/elasticsearch.yml</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">"docker-cluster"</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 允许任何端口访问</span></span><br><span class="line"><span class="string">transport.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=es -p 9200:9200 -p 9300:9300 -e <span class="string">"discovery.type=single-node"</span> -v /etc/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:6.6.1</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>开放了9300端口</li>
<li>挂载配置文件：/usr/share/elasticsearch/config/elasticsearch.yml</li>
</ol>
</blockquote>
<p>查看容器是否启动，以及端口是否正常开放</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">acc39c54a0d8        elasticsearch:6.6.1   <span class="string">"/usr/local/bin/dock…"</span>   18 hours ago        Up 18 hours         0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp   es</span><br></pre></td></tr></table></figure>

<p>更加直观的判断是否启动成功的提示是，直接访问 <code>9200</code> 端口号。成功的话，会返回如下信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里假设一个公网的ip   http://111.111.111.111:9200/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;cWz9ZWm&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;5v3SilrTQyCjjQO-a5heBA&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.2.4&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ccec39f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kibana安装"><a href="#kibana安装" class="headerlink" title="kibana安装"></a>kibana安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull kibana:6.6.1</span><br></pre></td></tr></table></figure>

<p>接下来，如果我们手里没有kibana配置文件的信息的话，需要先从容器中copy一份过来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器 temp</span><br><span class="line">docker run -di -p 5601:5601 --name temp kibana:6.6.1</span><br><span class="line"></span><br><span class="line"># 创建文件夹存放配置文件</span><br><span class="line">mkdir -p /etc/kibana</span><br><span class="line"></span><br><span class="line"># 从容器中复制过来，注意配置文件地址是 /usr/share/kibana/config</span><br><span class="line">docker cp temp:/usr/share/kibana/config /etc/kibana/config</span><br><span class="line"></span><br><span class="line"># 删除临时的temp文件，强制删除</span><br><span class="line">docker container rm -f temp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意挂载的配置文件地址为： /usr/share/kibana/config</p>
</blockquote>
<p>修改本地配置文件 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/kibana/config/kibana.yml</span></span><br><span class="line"><span class="string">server.name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="comment"># 允许所有地址访问</span></span><br><span class="line"><span class="string">server.host:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="comment"># elasticsearch的地址，注意这里我直接填写的公网ip。</span></span><br><span class="line"><span class="comment"># 有的教程里面填写elasticsearch，127.0.0.1，localhost 等</span></span><br><span class="line"><span class="comment"># docker容器的网络问题是我的弱项，采用上述方案，需要在docker容器互联，网络方面有一定的知识，不然会出问题。</span></span><br><span class="line"><span class="string">elasticsearch.url:</span> <span class="attr">http://111.111.111.111:9200</span></span><br><span class="line"><span class="string">xpack.monitoring.ui.container.elasticsearch.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name=kibana  -p 5601:5601 -v /etc/kibana/config:/usr/share/kibana/config kibana:6.6.1</span><br></pre></td></tr></table></figure>

<p>这里开放了新的端口 5601</p>
<p>验证是否成功，直接访问  <code>http://111.111.111.111:5601</code> 就可以看到如下界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200225110755.png" alt=""></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>elasticsearch 和 kibana 的版本最好保持一致，这里我都使用了 6.6.1 </p>
</li>
<li><p>elasticsearch 和 kibana 都是比较吃内存的家伙，所以如果你的服务器的内存少于4G，可能就会出很多问题。</p>
</li>
<li><p>kibana 端口可能会被封掉。注意你的服务器有没有打开 <code>5601</code> 端口，若是没有的话，换一个端口映射即可。<br><code>-p 7899:5601</code> </p>
</li>
<li><p>配置修改后可能会需要重启服务/容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启/查看 服务状态</span></span><br><span class="line">service kibana restart/status</span><br><span class="line">systemctl restart/status kibana</span><br><span class="line"><span class="comment"># 容器重启</span></span><br><span class="line">docker restart kibana</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>如果是搭建ELK，我们可能还需要 Filebeat 和 Logstash 的配和，这些还要后续的进行搭建。<br><code>ELK</code> 是好东西，只是太吃内存了。如果不是公司基本的项目，只是做的玩票性质的小服务，估计买服务器的开销就不小，所以我暂时不太会用 <code>ELK</code> 搭建日志系统。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq1031893936/article/details/93798646" target="_blank" rel="noopener">Docker安装ELK</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>kibana</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 环境变量读取顺序</title>
    <url>/2020/02/22/linux-environment-variable-config-file-order/</url>
    <content><![CDATA[<h2 id="linux-环境变量读取顺序"><a href="#linux-环境变量读取顺序" class="headerlink" title="linux 环境变量读取顺序"></a>linux 环境变量读取顺序</h2><p>参考了许多优秀的教程，总结了 linux 读取配置文件的顺序</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>系统/用户</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/environment</td>
<td>系统</td>
<td>系统环境变量</td>
</tr>
<tr>
<td>/etc/profile</td>
<td>系统</td>
<td>此文件为系统的<strong>每个用户</strong>设置环境信息<br />当用户<strong>第一次登录</strong>时,该文件被执行<br />并从<code>/etc/profile.d</code>目录的配置文件中搜集shell的设置.</td>
</tr>
<tr>
<td>/etc/profile.d/test.sh</td>
<td>系统</td>
<td>新建文件，没有文件夹可略过</td>
</tr>
<tr>
<td>/etc/bashrc<br />/etc/bash.bashrc</td>
<td>系统</td>
<td>为每一个运行 <code>bash shell</code>的用户执行此文件<br />当 <code>bash</code> shell被打开时,该文件被读取.</td>
</tr>
<tr>
<td><code>~/.bash_profile</code><br /><code>~/.bash_login</code></td>
<td>用户</td>
<td>每个用户输入专用于自己使用的shell信息<br />当用户登录时,该文件<strong>仅仅执行一次</strong>!<br />默认情况下,设置一些环境变量,执行用户的.bashrc文件</td>
</tr>
<tr>
<td>~/.profile</td>
<td>用户</td>
<td>只在用户登录的时候读取一次</td>
</tr>
<tr>
<td>~/.bashrc</td>
<td>用户</td>
<td><strong>每次打开新 bash shell 或 登录时生效</strong></td>
</tr>
<tr>
<td>~/.bash_logout</td>
<td>用户</td>
<td>每次退出 bash shell 或 系统时生效</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/youyoui/p/10680329.html" target="_blank" rel="noopener">Linux环境变量配置全攻略</a></p>
<p><a href="https://www.cnblogs.com/perserv/p/11718421.html" target="_blank" rel="noopener">/etc/profile和~/.bash_profile等文件的区别和联系</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Linux环境变量配置全攻略</title>
    <url>/2020/02/22/%E8%BD%AC%E8%BD%BD/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%85%A8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h1 id="Linux环境变量配置全攻略"><a href="#Linux环境变量配置全攻略" class="headerlink" title="Linux环境变量配置全攻略"></a>Linux环境变量配置全攻略</h1><blockquote>
<p>注：本文是转载文章</p>
<p>原文链接：<a href="https://www.cnblogs.com/youyoui/p/10680329.html" target="_blank" rel="noopener">Linux环境变量配置全攻略</a></p>
</blockquote>
<h2 id="Linux环境变量配置"><a href="#Linux环境变量配置" class="headerlink" title="Linux环境变量配置"></a>Linux环境变量配置</h2><p>在自定义安装软件的时候，经常需要配置环境变量，下面列举出各种对环境变量的配置方法。</p>
<p>下面所有例子的环境说明如下：</p>
<ul>
<li>系统：Ubuntu 14.0</li>
<li>用户名：uusama</li>
<li>需要配置MySQL环境变量路径：/home/uusama/mysql/bin</li>
</ul>
<h3 id="Linux读取环境变量"><a href="#Linux读取环境变量" class="headerlink" title="Linux读取环境变量"></a>Linux读取环境变量</h3><p>读取环境变量的方法：</p>
<ul>
<li><code>export</code>命令显示当前系统定义的所有环境变量</li>
<li><code>echo $PATH</code>命令输出当前的<code>PATH</code>环境变量的值</li>
</ul>
<a id="more"></a>

<p>这两个命令执行的效果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uusama@ubuntu:~$ export</span><br><span class="line">declare -x HOME=&quot;/home/uusama&quot;</span><br><span class="line">declare -x LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">declare -x LANGUAGE=&quot;en_US:&quot;</span><br><span class="line">declare -x LESSCLOSE=&quot;/usr/bin/lesspipe %s %s&quot;</span><br><span class="line">declare -x LESSOPEN=&quot;| /usr/bin/lesspipe %s&quot;</span><br><span class="line">declare -x LOGNAME=&quot;uusama&quot;</span><br><span class="line">declare -x MAIL=&quot;/var/mail/uusama&quot;</span><br><span class="line">declare -x PATH=&quot;/home/uusama/bin:/home/uusama/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">declare -x SSH_TTY=&quot;/dev/pts/0&quot;</span><br><span class="line">declare -x TERM=&quot;xterm&quot;</span><br><span class="line">declare -x USER=&quot;uusama&quot;</span><br><span class="line"></span><br><span class="line">uusama@ubuntu:~$ echo $PATH</span><br><span class="line">/home/uusama/bin:/home/uusama/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>

<p>其中<code>PATH</code>变量定义了运行命令的查找路径，以冒号<code>:</code>分割不同的路径，使用<code>export</code>定义的时候可加双引号也可不加。</p>
<h3 id="Linux环境变量配置方法一：export-PATH"><a href="#Linux环境变量配置方法一：export-PATH" class="headerlink" title="Linux环境变量配置方法一：export PATH"></a>Linux环境变量配置方法一：<code>export PATH</code></h3><p>使用<code>export</code>命令直接修改<code>PATH</code>的值，配置MySQL进入环境变量的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=/home/uusama/mysql/bin:$PATH</span><br><span class="line"></span><br><span class="line"># 或者把PATH放在前面</span><br><span class="line">export PATH=$PATH:/home/uusama/mysql/bin</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>生效时间：立即生效</li>
<li>生效期限：当前终端有效，窗口关闭后无效</li>
<li>生效范围：仅对当前用户有效</li>
<li>配置的环境变量中不要忘了加上原来的配置，即<code>$PATH</code>部分，避免覆盖原来配置</li>
</ul>
<h3 id="Linux环境变量配置方法二：vim-bashrc"><a href="#Linux环境变量配置方法二：vim-bashrc" class="headerlink" title="Linux环境变量配置方法二：vim ~/.bashrc"></a>Linux环境变量配置方法二：<code>vim ~/.bashrc</code></h3><p>通过修改用户目录下的<code>~/.bashrc</code>文件进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"># 在最后一行加上</span><br><span class="line">export PATH=$PATH:/home/uusama/mysql/bin</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>生效时间：使用相同的用户打开新的终端时生效，或者手动<code>source ~/.bashrc</code>生效</li>
<li>生效期限：永久有效</li>
<li>生效范围：仅对当前用户有效</li>
<li>如果有后续的环境变量加载文件覆盖了<code>PATH</code>定义，则可能不生效</li>
</ul>
<h3 id="Linux环境变量配置方法三：vim-bash-profile"><a href="#Linux环境变量配置方法三：vim-bash-profile" class="headerlink" title="Linux环境变量配置方法三：vim ~/.bash_profile"></a>Linux环境变量配置方法三：<code>vim ~/.bash_profile</code></h3><p>和修改<code>~/.bashrc</code>文件类似，也是要在文件最后加上新的路径即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 在最后一行加上</span><br><span class="line">export PATH=$PATH:/home/uusama/mysql/bin</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>生效时间：使用相同的用户打开新的终端时生效，或者手动<code>source ~/.bash_profile</code>生效</li>
<li>生效期限：永久有效</li>
<li>生效范围：仅对当前用户有效</li>
<li>如果没有<code>~/.bash_profile</code>文件，则可以编辑<code>~/.profile</code>文件或者新建一个</li>
</ul>
<h3 id="Linux环境变量配置方法四：vim-etc-bashrc"><a href="#Linux环境变量配置方法四：vim-etc-bashrc" class="headerlink" title="Linux环境变量配置方法四：vim /etc/bashrc"></a>Linux环境变量配置方法四：<code>vim /etc/bashrc</code></h3><p>该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果/etc/bashrc文件不可编辑，需要修改为可编辑</span><br><span class="line">chmod -v u+w /etc/bashrc</span><br><span class="line"></span><br><span class="line">vim /etc/bashrc</span><br><span class="line"></span><br><span class="line"># 在最后一行加上</span><br><span class="line">export PATH=$PATH:/home/uusama/mysql/bin</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>生效时间：新开终端生效，或者手动<code>source /etc/bashrc</code>生效</li>
<li>生效期限：永久有效</li>
<li>生效范围：对所有用户有效</li>
</ul>
<h3 id="Linux环境变量配置方法五：vim-etc-profile"><a href="#Linux环境变量配置方法五：vim-etc-profile" class="headerlink" title="Linux环境变量配置方法五：vim /etc/profile"></a>Linux环境变量配置方法五：<code>vim /etc/profile</code></h3><p>该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和<code>vim /etc/bashrc</code>类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果/etc/profile文件不可编辑，需要修改为可编辑</span><br><span class="line">chmod -v u+w /etc/profile</span><br><span class="line"></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"># 在最后一行加上</span><br><span class="line">export PATH=$PATH:/home/uusama/mysql/bin</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>生效时间：新开终端生效，或者手动<code>source /etc/profile</code>生效</li>
<li>生效期限：永久有效</li>
<li>生效范围：对所有用户有效</li>
</ul>
<h3 id="Linux环境变量配置方法六：vim-etc-environment"><a href="#Linux环境变量配置方法六：vim-etc-environment" class="headerlink" title="Linux环境变量配置方法六：vim /etc/environment"></a>Linux环境变量配置方法六：<code>vim /etc/environment</code></h3><p>该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果/etc/bashrc文件不可编辑，需要修改为可编辑</span><br><span class="line">chmod -v u+w /etc/environment</span><br><span class="line"></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"># 在最后一行加上</span><br><span class="line">export PATH=$PATH:/home/uusama/mysql/bin</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>生效时间：新开终端生效，或者手动<code>source /etc/environment</code>生效</li>
<li>生效期限：永久有效</li>
<li>生效范围：对所有用户有效</li>
</ul>
<h2 id="Linux环境变量加载原理解析"><a href="#Linux环境变量加载原理解析" class="headerlink" title="Linux环境变量加载原理解析"></a>Linux环境变量加载原理解析</h2><p>上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？</p>
<p>特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。</p>
<h3 id="环境变量的分类"><a href="#环境变量的分类" class="headerlink" title="环境变量的分类"></a>环境变量的分类</h3><p>环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。</p>
<ul>
<li>用户级别环境变量定义文件：<code>~/.bashrc</code>、<code>~/.profile</code>（部分系统为：<code>~/.bash_profile</code>）</li>
<li>系统级别环境变量定义文件：<code>/etc/bashrc</code>、<code>/etc/profile</code>(部分系统为：<code>/etc/bash_profile</code>）、<code>/etc/environment</code></li>
</ul>
<p>另外在用户环境变量中，系统会首先读取<code>~/.bash_profile</code>文件，如果没有该文件则读取<code>~/.bash_login</code>，如果也没有该文件，则读取<code>~/.profile</code>，根据这些文件中内容再去读取<code>~/.bashrc</code>。</p>
<h3 id="测试Linux环境变量加载顺序的方法"><a href="#测试Linux环境变量加载顺序的方法" class="headerlink" title="测试Linux环境变量加载顺序的方法"></a>测试Linux环境变量加载顺序的方法</h3><p>为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量<code>UU_ORDER</code>，该变量的值为本身的值连接上当前文件名称。</p>
<p>需要修改的文件如下：</p>
<ul>
<li>/etc/environment</li>
<li>/etc/profile</li>
<li>/etc/profile.d/test.sh，新建文件，没有文件夹可略过</li>
<li>/etc/bashrc，或者/etc/bash.bashrc</li>
<li><del>/.bash_profile，或者</del>/.profile</li>
<li>~/.bashrc</li>
</ul>
<p>在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export UU_ORDER=&quot;$UU_ORDER:~/.bash_profile&quot;</span><br></pre></td></tr></table></figure>

<p>修改完之后保存，新开一个窗口，然后<code>echo $UU_ORDER</code>观察变量的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uusama@ubuntu:~$ echo $UU_ORDER</span><br><span class="line">$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc</span><br></pre></td></tr></table></figure>

<p>可以推测出Linux加载环境变量的顺序如下：</p>
<ol>
<li>/etc/environment</li>
<li>/etc/profile</li>
<li>/etc/bash.bashrc</li>
<li>/etc/profile.d/test.sh</li>
<li>~/.profile</li>
<li>~/.bashrc</li>
</ol>
<h3 id="Linux环境变量文件加载详解"><a href="#Linux环境变量文件加载详解" class="headerlink" title="Linux环境变量文件加载详解"></a>Linux环境变量文件加载详解</h3><p>由上面的测试可容易得出Linux加载环境变量的顺序如下，：</p>
<p>系统环境变量 -&gt; 用户自定义环境变量<br>/etc/environment -&gt; /etc/profile -&gt; ~/.profile</p>
<p>打开<code>/etc/profile</code>文件你会发现，该文件的代码中会加载<code>/etc/bash.bashrc</code>文件，然后检查<code>/etc/profile.d/</code>目录下的<code>.sh</code>文件并加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/profile: system-wide .profile file for the Bourne shell (sh(1))</span><br><span class="line"># and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span><br><span class="line"></span><br><span class="line">if [ &quot;$PS1&quot; ]; then</span><br><span class="line">  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then</span><br><span class="line">    # The file bash.bashrc already sets the default PS1.</span><br><span class="line">    # PS1=&apos;\h:\w\$ &apos;</span><br><span class="line">    if [ -f /etc/bash.bashrc ]; then</span><br><span class="line">      . /etc/bash.bashrc</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    if [ &quot;`id -u`&quot; -eq 0 ]; then</span><br><span class="line">      PS1=&apos;# &apos;</span><br><span class="line">    else</span><br><span class="line">      PS1=&apos;$ &apos;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d /etc/profile.d ]; then</span><br><span class="line">  for i in /etc/profile.d/*.sh; do</span><br><span class="line">    if [ -r $i ]; then</span><br><span class="line">      . $i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  unset i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>其次再打开<code>~/.profile</code>文件，会发现该文件中加载了<code>~/.bashrc</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># if running bash</span><br><span class="line">if [ -n &quot;$BASH_VERSION&quot; ]; then</span><br><span class="line">    # include .bashrc if it exists</span><br><span class="line">    if [ -f &quot;$HOME/.bashrc&quot; ]; then</span><br><span class="line">    . &quot;$HOME/.bashrc&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># set PATH so it includes user&apos;s private bin directories</span><br><span class="line">PATH=&quot;$HOME/bin:$HOME/.local/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>从<code>~/.profile</code>文件中代码不难发现，<code>/.profile</code>文件<strong>只在用户登录的时候读取一次</strong>，而<code>/.bashrc</code>会在每次运行<code>Shell</code>脚本的时候读取一次。</p>
<h3 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h3><p>可以自定义一个环境变量文件，比如在某个项目下定义<code>uusama.profile</code>，在这个文件中使用<code>export</code>定义一系列变量，然后在<code>~/.profile</code>文件后面加上：<code>sourc uusama.profile</code>，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。</p>
<p>也可以使用<code>alias</code>命令定义一些命令的别名，比如<code>alias rm=&quot;rm -i&quot;</code>（双引号必须），并把这个代码加入到<code>~/.profile</code>中，这样你每次使用<code>rm</code>命令的时候，都相当于使用<code>rm -i</code>命令，非常方便。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>环境变量</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>linux crontab 入门</title>
    <url>/2020/02/19/linux-crontab-basic/</url>
    <content><![CDATA[<p>crontab 的作用是，执行 linux 上的定时任务。当我们需要运行一些诸如 <code>日志采集</code> 、<code>心跳检查</code> 这种任务的时候，需要用到。</p>
<p>最近在做 linux 脚本检查 <code>python 爬虫脚本</code> 是否健康运行，故采用这个方法。</p>
<blockquote>
<p>只要是常驻的程序，对于程序的要求比较高，必须有很好的稳健性，可以面对各种情况。</p>
</blockquote>
<p>一个程序很难考虑到各种极端情况(死机，内存爆，网络问题等)，这时候我们必须要实时监控这些进程的方法。</p>
<p>这里我准备采用的方法一：日记采集+监控， 方法二：定期检查并唤起。日志采集的东西准备放在下一篇讲。</p>
<blockquote>
<p>当安装完成操作系统之后，默认便会启动此任务调度命令。crond 命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作</p>
</blockquote>
<a id="more"></a>

<p>而 linux 任务调度的工作主要分为以下两类：</p>
<ul>
<li>1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存</li>
<li>2、个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure>

<p>对于 <code>crontabs</code> 服务的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status crond // systemctl 和 service 也是一样</span><br><span class="line">service crond start //启动服务</span><br><span class="line">service crond stop //关闭服务</span><br><span class="line">service crond restart //重启服务</span><br><span class="line">service crond reload //重新载入配置</span><br><span class="line">service crond status //查看服务是否启动</span><br></pre></td></tr></table></figure>

<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab [ -u user ] file</span><br><span class="line">crontab [ -u user ] &#123; -l | -r | -e &#125; </span><br><span class="line">-l 列出目前用户的时程表</span><br><span class="line">-r 删除目前用户的时程表</span><br><span class="line">-e 编辑目前用户的时程表(默认采用VI)  等价于运行 vi /var/spool/cron/root [注:假如你是root用户(文件名与用户名一样)]</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br></pre></td></tr></table></figure>

<ul>
<li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li>
<li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li>
<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li>
<li>当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推</li>
<li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 7) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 */2 * * * /sbin/service httpd restart  意思是每两个小时重启一次apache </span><br><span class="line">50 7 * * * /sbin/service sshd start  意思是每天7：50开启ssh服务 </span><br><span class="line">50 22 * * * /sbin/service sshd stop  意思是每天22：50关闭ssh服务 </span><br><span class="line">0 0 1,15 * * fsck /home  每月1号和15号检查/home 磁盘 </span><br><span class="line">1 * * * * /home/bruce/backup  每小时的第一分执行 /home/bruce/backup这个文件 </span><br><span class="line">00 03 * * 1-5 find /home &quot;*.xxx&quot; -mtime +4 -exec rm &#123;&#125; \;  每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span><br><span class="line">30 6 */10 * * ls  意思是每月的1、11、21、31日是的6：30执行一次ls命令</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>crontab 是系统任务调度的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/crontab</span><br><span class="line">SHELL=/bin/bash # 记录使用的 shell </span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin # 记录 crontab 的环境变量</span><br><span class="line">MAILTO=root # 发送邮件的用户</span><br></pre></td></tr></table></figure>



<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="如何查看日志"><a href="#如何查看日志" class="headerlink" title="如何查看日志"></a>如何查看日志</h3><p><strong>执行日志</strong> 存储地址  <code>/var/log/cron*</code></p>
<p>执行日志按天排列：<code>cron</code> 、<code>cron-20171119</code> … </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/cron</span><br></pre></td></tr></table></figure>

<p><strong>运行日志</strong> 存储地址 <code>/var/spool/mail/root</code></p>
<blockquote>
<p>mail/root 中的root 是文件名，与用户保持一致</p>
</blockquote>
<p>发邮件的功能，我没有尝试成功 // TODO</p>
<h3 id="如何查看-备份任务"><a href="#如何查看-备份任务" class="headerlink" title="如何查看/备份任务"></a>如何查看/备份任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑任务</span></span><br><span class="line">crontab -e </span><br><span class="line"><span class="comment"># 实际上所有的配置都存放在 /var/spool/cron/*下，文件名与用户名一致</span></span><br><span class="line">/var/spool/conf/root :root 用户任务</span><br><span class="line">/var/spool/conf/mysql :mysql 用户任务</span><br><span class="line"><span class="comment"># 备份任务</span></span><br><span class="line">crontab -l &gt; <span class="variable">$HOME</span>/mycrontab</span><br><span class="line">cp /var/spool/conf/root <span class="variable">$HOME</span>/YOURPLACE/root</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>crontab 有很多的注意实现，新手很容易翻车</p>
<h3 id="建议不输出日志"><a href="#建议不输出日志" class="headerlink" title="建议不输出日志"></a>建议不输出日志</h3><p>原因是任务运行太频繁，日志会累积的非常大，不留意会撑爆你的硬盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3 id="环境变量问题"><a href="#环境变量问题" class="headerlink" title="环境变量问题"></a>环境变量问题</h3><p>crontab 的环境变量是一个大问题，crontab运行的时候不是以交互式的方式运行我们的程序，这样的话，我们常规的用来配置 <code>linux 环境变量</code> 的方法。如 <code>.bashrc</code> ，<code>.bash_profile</code> 等都不会起作用。</p>
<blockquote>
<p>官方给的建议是，不要假定 cron 知道所需要的特殊环境，所以要保证 shell 脚本中提供所有必要的路径和环境变量。</p>
</blockquote>
<ol>
<li><p>脚本中涉及文件路径时写全局路径；</p>
</li>
<li><p>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat start_cbp.sh</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># shell 脚本中写入所需引入的环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="built_in">export</span> RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/jboss-4.0.5/bin/run.sh -c mev &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/linux/linux-comm-crontab.html" target="_blank" rel="noopener">菜鸟教程：Linux crontab 命令</a></p>
<p><a href="https://www.cnblogs.com/ftl1012/p/crontab.html" target="_blank" rel="noopener">小a玖拾柒：Linux crontab命令详解</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>crontab</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql error:Waiting for table metadata lock</title>
    <url>/2020/02/11/mysql-bug-solution/</url>
    <content><![CDATA[<p>背景是，Navicat 在针对一张表格做删除操作的时候，会一直等待，无法进行任何操作。</p>
<p>经过 <code>show PROCESSLIST</code> 发现是 <code>Waiting for table metadata lock</code> 错误。</p>
<a id="more"></a>

<h2 id="删除-mysql-中表格遇到锁"><a href="#删除-mysql-中表格遇到锁" class="headerlink" title="删除 mysql 中表格遇到锁"></a>删除 mysql 中表格遇到锁</h2><p>出现了<code>Waiting for table metadata lock</code> 的原因是，程序中对于数据库的一次操作并没有成功关闭，导致数据库上锁后，没有解锁。按照如下操作即可解决问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show PROCESSLIST; # 显示所有的操作</span><br><span class="line">select * from information_schema.innodb_trx  # 查看未提交事务</span><br><span class="line">kill sid # 删除锁住的操作</span><br><span class="line">set session lock_wait_timeout = 1800; set global lock_wait_timeout = 1800;</span><br><span class="line"># 调整锁超时阈值 lock_wait_timeout 表示获取metadata lock的超时（单位为秒），允许的值范围为1到31536000（1年）。 默认值为31536000。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：<a href="https://www.cnblogs.com/digdeep/p/4892953.html" target="_blank" rel="noopener">MySQL出现Waiting for table metadata lock的原因以及解决方法</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql error</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器：将装饰器定义为类</title>
    <url>/2020/02/09/define-decorators-as-class/</url>
    <content><![CDATA[<p>最近在强化补齐 Python 的基础知识，向高阶玩家进发。主攻《Python CookBook 3rd》，上面的知识点比较多，我挑重点看这几个方面。</p>
<ul>
<li>yield + 协程</li>
<li>装饰器</li>
<li>多线程</li>
<li>面向对象</li>
</ul>
<p>本篇博客讨论的主题是 <code>装饰器</code> ，装饰器其实也不是什么新鲜的用法，就是传入的参数是 <code>函数</code> ，这一点上，它更像是一个语法糖。装饰器的作用是可以给我们原本编写好的函数再一次的加上额外的功能（比如统计时间，打日志）。</p>
<p>装饰器可以给我们的函数加上武器，使它们更加强大。如果是利用 <code>Python</code> 进行 <code>Web</code> 开发的小伙伴对装饰器并不陌生，在 <code>Flask</code> 和 <code>Django</code> 中 <code>@</code> 符号应该不少见了 </p>
<a id="more"></a>

<h2 id="用类来实现装饰器"><a href="#用类来实现装饰器" class="headerlink" title="用类来实现装饰器"></a>用类来实现装饰器</h2><p>Python 对某个对象是否能通过装饰器（<code>@decorator</code>）形式使用只有一个要求：<strong>decorator 必须是一个“可被调用（callable）的对象</strong>。类也可以通过实现 <code>__call__</code> 方法，变得和函数一样可调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'__call__ has been called'</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line"><span class="comment"># OUTPUT: __call__ has been called</span></span><br><span class="line">foo()</span><br><span class="line"><span class="comment"># OUTPUT: True</span></span><br><span class="line">print(callable(foo))</span><br></pre></td></tr></table></figure>

<p>这样的话，我们就可以直接开始用类来实现装饰器了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiled</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.ncalls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.ncalls += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profiled</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># 3 </span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># OUTPUT:2 总共调用了2次装饰器</span></span><br><span class="line">print(add.ncalls)</span><br></pre></td></tr></table></figure>

<h3 id="问题一：装饰器无法装饰类内的方法"><a href="#问题一：装饰器无法装饰类内的方法" class="headerlink" title="问题一：装饰器无法装饰类内的方法"></a>问题一：装饰器无法装饰类内的方法</h3><p>这时候出现了第一个问题，当装饰器尝试装饰类内的方法的时候，我们常常会出现 <code>参数输入不正确的提示</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">    @Profiled</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(self, x)</span><br><span class="line"></span><br><span class="line">s = Spam()</span><br><span class="line"><span class="comment"># TypeError: bar() missing 1 required positional argument: 'x'</span></span><br><span class="line">s.bar(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这个问题会让很多人感到困惑，明明我已经输入了参数x，赋值为1，但是却提示没有收到函数。我当时困惑了很久。终于发现了一个我们不容易注意到的细节：<code>函数和方法的功能相似，当时实现方式不同</code>。</p>
<p>我的理解是：<strong>与实例绑定的函数，叫做过程。不与实例绑定的叫做函数。</strong>这里的实例，在代码里面就是 <code>self</code><br>类内的方法，需要多传一个 <code>self</code> ，它本质上可以看做是一个指向实例的指针。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># 我们在 __call__ 里面多加一行，看看输出会是什么</span><br><span class="line">def __call__(self, *args, **kwargs):</span><br><span class="line">      self.ncalls += 1</span><br><span class="line"><span class="addition">+     print(self, *args, **kwargs)</span></span><br><span class="line">      return self.func(*args, **kwargs)</span><br><span class="line"># &lt;__main__.Profiled object at 0x10faf1128&gt; 1</span><br></pre></td></tr></table></figure>

<p><code>self</code> 就是 <code>&lt;__main__.Profiled object at 0x10faf1128&gt;</code> ，而输入的参数是 <code>1</code> 。</p>
<blockquote><p>Self  到低是一个什么玩意？</p>
</blockquote>

<p>为了探寻 <code>self</code> 的本质，我又多做了一个实验。<br>发现 <code>self</code> ，<code>Spam.bar</code> ，<code>s.bar</code> 都是一个东西，相互替换的话，也是OK的，它就是类的一个实例。需要注意的是<code>@Profiled</code> 等价于 <code>bar = Profiled(bar)</code> ，所以这个实例也就是 <code>Spam.bar</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self</span><br><span class="line">&lt;__main__.Profiled object at <span class="number">0x10aaf5470</span>&gt;</span><br><span class="line">Spam.bar</span><br><span class="line">&lt;__main__.Profiled object at <span class="number">0x10aaf5470</span>&gt;</span><br><span class="line">s.bar</span><br><span class="line">&lt;__main__.Profiled object at <span class="number">0x10aaf5470</span>&gt;</span><br></pre></td></tr></table></figure>

<p>下面的例子，可以帮助我们更好的理解 <strong>对象的方法</strong> 和 <strong>类的方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带 self 的意思是对象的方法，所以我们必须传入一个对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(self, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常用法，实例化对象，然后调用对象的方法</span></span><br><span class="line"><span class="comment"># OUTPUT: &lt;__main__.Spam object at 0x10b3470b8&gt; 111</span></span><br><span class="line">s = Spam()</span><br><span class="line">s.bar(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用 Spam.bar 方法</span></span><br><span class="line">Spam.bar(<span class="number">123</span>)  <span class="comment"># 错误用法，因为这里当做类的方法去使用了</span></span><br><span class="line"><span class="comment"># OUTPUT: &lt;__main__.Spam object at 0x10b3470b8&gt; 123</span></span><br><span class="line">Spam.bar(Spam(),<span class="number">123</span>) <span class="comment"># 正确用法</span></span><br></pre></td></tr></table></figure>

<p>更进一步，我们发现，定义类的方法的时候，类并不关心你传入的实例到底是什么，可以是 <code>self</code> ，也可以是任何类型的实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;__main__.Spam object at 0x107bcc128&gt; 123</span></span><br><span class="line">Spam.bar(Spam(),<span class="number">123</span>)</span><br><span class="line"><span class="comment"># &lt;__main__.Spam object at 0x107bc2e80&gt; 123</span></span><br><span class="line">Spam.bar(s,<span class="number">123</span>)</span><br><span class="line"><span class="comment"># &lt;function Spam.bar at 0x107badea0&gt; 123</span></span><br><span class="line">Spam.bar(Spam.bar,<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 任何类型的对象都可以 123</span></span><br><span class="line">Spam.bar(<span class="string">"任何类型的对象都可以"</span>,<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>回到正题，我们终于找到了原先错误的原因，就是漏掉了 <code>self</code> 。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">class Profiled:</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.ncalls = 0</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        self.ncalls += 1</span><br><span class="line"><span class="deletion">-       return self.func(*args, **kwargs)</span></span><br><span class="line"><span class="addition">+       return self.func(self, *args, **kwargs)</span></span><br><span class="line"></span><br><span class="line">class Spam:</span><br><span class="line">    @Profiled</span><br><span class="line">    def bar(self, x):</span><br><span class="line">        print(self, x)</span><br><span class="line"></span><br><span class="line">s = Spam()</span><br><span class="line">s.bar(1)</span><br><span class="line">s.bar(2)</span><br><span class="line">print(Spam.bar.ncalls)</span><br><span class="line"># OUTPUT</span><br><span class="line">&lt;__main__.Profiled object at 0x104168eb8&gt; 1</span><br><span class="line">&lt;__main__.Profiled object at 0x104168eb8&gt; 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>解决完这个问题，附带的我们对 <code>self</code> 的理解就加深了一层。</p>
<h3 id="类方法-和-实例方法"><a href="#类方法-和-实例方法" class="headerlink" title="类方法 和 实例方法"></a>类方法 和 实例方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="string">"""实例方法"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(self, x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swam</span>:</span></span><br><span class="line">    <span class="string">"""类方法"""</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">        print(cls, x)</span><br><span class="line"><span class="comment"># OUTPUT: &lt;__main__.Spam object at 0x1102080f0&gt; 1</span></span><br><span class="line">Spam().bar(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># OUTPUT: &lt;class '__main__.Swam'&gt; 1</span></span><br><span class="line">Swam.bar(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="问题二：如何兼顾类内类外的函数"><a href="#问题二：如何兼顾类内类外的函数" class="headerlink" title="问题二：如何兼顾类内类外的函数"></a>问题二：如何兼顾类内类外的函数</h3><p>刚刚的问题一解决后，我们发现，对原来类外的函数又失效了，原因是它并没有 <code>self</code> 这个参数。为了解决这个问题，我们需要花一番功夫，其实简单来说，有实例的情况下，我们需要填充实例到 self 参数的位置。</p>
<p>这里我们借助 <code>types.MethodTpye</code> 和 <code>__get__</code></p>
<h3 id="解决方法（完美版）"><a href="#解决方法（完美版）" class="headerlink" title="解决方法（完美版）"></a>解决方法（完美版）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiled</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.ncalls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.ncalls += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> types.MethodType(self, instance)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profiled</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">    @Profiled</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(self, x)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(add.ncalls)</span><br><span class="line"></span><br><span class="line">s = Spam()</span><br><span class="line">s.bar(<span class="number">1</span>)</span><br><span class="line">s.bar(<span class="number">2</span>)</span><br><span class="line">print(Spam.bar.ncalls)</span><br></pre></td></tr></table></figure>



<h4 id="get-是怎么使用"><a href="#get-是怎么使用" class="headerlink" title="__get__ 是怎么使用"></a><code>__get__</code> 是怎么使用</h4><p>当一个类中实现了任意的 <code>__get__()</code>、<code>__set__()</code> 和<code>__delete__()</code> 三个特殊的方法后， 这个类就是一个描述器类。当这个描述器在另一个类中被调用的时候，就会调用以上的三个方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个描述器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected an int'</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure>

<p>为了使用一个描述器，这个类必须作为另外一个类的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x, y 都是 Point 的描述器属性</span></span><br><span class="line"><span class="comment"># 需要注意的是: x, y 是类的属性，需要在方法前定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Integer(<span class="string">'x'</span>)</span><br><span class="line">    y = Integer(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的定义是错误的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = Integer(<span class="string">'x'</span>) <span class="comment"># No! Must be a class variable</span></span><br><span class="line">        self.y = Integer(<span class="string">'y'</span>)</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure>

<p>使用方法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x <span class="comment"># Calls Point.x.__get__(p,Point)</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y = <span class="number">5</span> <span class="comment"># Calls Point.y.__set__(p, 5)</span></span><br></pre></td></tr></table></figure>

<p>我们会发现 <code>__get__</code> 方法实现起来比较复杂</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure>

<h4 id="self-instance-cls-分别代表什么意思？"><a href="#self-instance-cls-分别代表什么意思？" class="headerlink" title="self, instance, cls 分别代表什么意思？"></a>self, instance, cls 分别代表什么意思？</h4><p>self 是 Integer 类的实例，这里 x、y 都可以看做是self。<br>instance 是 Point 类的实例，也就是 p。<br>cls（也可以写成 owner）是类本身，这里就是 Point 类。</p>
<p>如果一个描述器被当做一个类变量来访问，那么 <code>instance</code> 参数被设置成 <code>None</code> 。 这种情况下，标准做法就是简单的返回这个描述器本身即可(尽管你还可以添加其他的自定义操作)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x <span class="comment"># Calls Point.x.__get__(p, Point)</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point.x <span class="comment"># Calls Point.x.__get__(None, Point)</span></span><br><span class="line">&lt;__main__.Integer object at <span class="number">0x100671890</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="types-MethodType-详解"><a href="#types-MethodType-详解" class="headerlink" title="types.MethodType 详解"></a>types.MethodType 详解</h3><p>Python 是动态的编程语言，可以在执行的过程中，给类动态的添加方法。</p>
<p>下面举一个经典用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn_get_name</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure>

<p>添加函数到 Person 类的方法上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.get_name = types.MethodType(fn_get_name, p1)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> p1.get_name()  </span><br><span class="line">Bob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = Person(<span class="string">'Alice'</span>, <span class="number">65</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> p2.get_name()  </span><br><span class="line"><span class="comment"># ERROR: AttributeError: 'Person' object has no attribute 'get_name'  </span></span><br><span class="line"><span class="comment"># 因p2实例没有绑定get_name方法，所以出现错误。</span></span><br></pre></td></tr></table></figure>

<p>下面我们深入理解一下 <code>p1.get_name = types.MethodType(fn_get_name, p1)</code><br><code>types.MethodType</code> 接受两个参数（好像Python2 是3 个参数？）</p>
<ul>
<li>第一个参数：绑定的函数</li>
<li>第二个参数：需要绑定的实例</li>
</ul>
<p>孤立的看两个参数和实现的结果并不能很好的理解其中的原理，实际上，所谓的绑定的实质上是：<strong>第二个实例是作为参数，传入到绑定函数(现在是类的过程)的 <code>self</code> 中去</strong>。</p>
<p>如果理解了这一句话，那么应该不难理解下面的程序。明明是 p1 调用自己的方法，最后输出的是 p2 的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)  </span><br><span class="line">p2 = Person(<span class="string">'Tom'</span>, <span class="number">0</span>)</span><br><span class="line">p1.get_name = types.MethodType(fn_get_name, p2)  </span><br><span class="line"><span class="keyword">print</span> (p1.get_name())</span><br><span class="line"><span class="comment"># OUTPUT: Tom</span></span><br></pre></td></tr></table></figure>

<p>原因是我们的类最终是变成了下面的样子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn_get_name</span><span class="params">(self)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        self = p2</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)  </span><br><span class="line">p2 = Person(<span class="string">'Tom'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> (p1.get_name())</span><br><span class="line"><span class="comment"># OUTPUT: TOM</span></span><br></pre></td></tr></table></figure>

<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>有了上面的各种铺垫后，我们再一次的回顾 <code>__get__</code>, <code>__call__</code> 两个方法，就瞬间了然。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> types.MethodType(self, instance) <span class="comment"># 该实例会作为参数传入 self 中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">       <span class="comment"># 当实例发生调用的时候，__call__(self, self, 1)</span></span><br><span class="line">       <span class="comment"># args = (self, 1)</span></span><br><span class="line">       self.ncalls += <span class="number">1</span></span><br><span class="line">       <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">            <span class="comment"># self.func(self, 1)</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-wrapper-再次包装一下"><a href="#利用-wrapper-再次包装一下" class="headerlink" title="利用 wrapper 再次包装一下"></a>利用 wrapper 再次包装一下</h3><p>wrapper 的作用非常简单，就是让复制被包装函数的元信息。下面的代码就是 Python Cookbook 给出的答案。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import types</span><br><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">class Profiled:</span><br><span class="line">    def __init__(self, func):</span><br><span class="line"><span class="deletion">-        self.func = func</span></span><br><span class="line"><span class="addition">+        wraps(func)(self)</span></span><br><span class="line">        self.ncalls = 0</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        self.ncalls += 1</span><br><span class="line"><span class="deletion">-	      return self.func(*args, **kwargs)</span></span><br><span class="line"><span class="addition">+       return self.__wrapped__(*args, **kwargs)</span></span><br><span class="line"></span><br><span class="line">    def __get__(self, instance, cls):</span><br><span class="line">        if instance is None:</span><br><span class="line">            return self</span><br><span class="line">        else:</span><br><span class="line">            return types.MethodType(self, instance)</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>花了相当长的一个篇幅去讨论 Python Cookbook 的一个章节，虽然有点小题大做。不过也是把很多不懂的地方理清楚了。特别是对于 <strong>函数和方法</strong> 的认识更深一步了。</p>
<p>后续会利用装饰器去做一个应用，计划是做一个 requests 包的一个封装，使得 request 请求的时候自动加上代理，把它封装成一个 Util 工具。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zlovezl.cn/articles/tips-on-decorators/" target="_blank" rel="noopener">Python 工匠：使用装饰器的技巧</a></p>
<p><a href="https://www.cnblogs.com/moonpool/p/11333541.html" target="_blank" rel="noopener">python中函数和方法区别，以及如何给python类动态绑定方法和属性（涉及types.MethodType()和<strong>slots</strong>）</a></p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p09_create_new_kind_of_class_or_instance_attribute.html" target="_blank" rel="noopener">Python Cookbook 8.9 创建新的类或实例属性</a></p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p09_define_decorators_as_classes.html" target="_blank" rel="noopener">Python Cookbook 9.9 将装饰器定义为类</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python高级</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在python项目中使用import导入自编模块</title>
    <url>/2020/01/26/how-to-import-module-in-python-project/</url>
    <content><![CDATA[<p>背景是在python项目中导入模块时碰到的问题，当需要导入的模块是位于项目的不同层级的时候，导入文件就变成了一个非常麻烦的事情。</p>
<p>下面举一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. # 当前工作目录</span><br><span class="line">├── DB </span><br><span class="line">│   ├── MySQLClient.py</span><br><span class="line">│   └── RedisClient.py</span><br><span class="line">└── Util</span><br><span class="line">│    └── LogHandler.py</span><br><span class="line">├── Email</span><br><span class="line">│      └── SendEmail.py  # 本文件</span><br><span class="line">│      └── Email_setting.py  # 待导入文件</span><br></pre></td></tr></table></figure>

<p>DB 和 Util 是我们经常使用到的模块，若是我们的工作目录位于项目文件的第一层的话，当我们导入 <code>Email_setting.py</code> 的时候，我们应该是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> DB.MySQLClient <span class="keyword">import</span> MySQLClass</span><br><span class="line"><span class="keyword">from</span> Util.LogHandler <span class="keyword">import</span> LogHandler</span><br><span class="line"><span class="keyword">from</span> Email_setting <span class="keyword">import</span> *  <span class="comment"># 这是错误的例子</span></span><br><span class="line"><span class="keyword">from</span> Email.Email_setting <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>下面我们讨论一下如何在python中导入模块</p>
<blockquote><p>参考自: <a href="http://www.blog.pythonlibrary.org/2016/03/01/python-101-all-about-imports/" target="_blank" rel="noopener">Python 101: All about imports</a></p>
</blockquote>

<a id="more"></a> 

<h2 id="导入-Python-模块的各种姿势"><a href="#导入-Python-模块的各种姿势" class="headerlink" title="导入 Python 模块的各种姿势"></a>导入 Python 模块的各种姿势</h2><ul>
<li>Regular imports</li>
<li>Using from</li>
<li>Relative imports</li>
<li>Optional imports</li>
<li>Local imports</li>
<li>import Pitfalls</li>
</ul>
<h2 id="常规导入"><a href="#常规导入" class="headerlink" title="常规导入"></a>常规导入</h2><p>我们最常见的导入方式是  <code>import module</code> ，我们一般用来导入 <code>官方库</code> 和 <code>第三方库</code> 。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="comment"># 官方库</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> Beautfiul <span class="comment"># 第三方库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>

<p>以上两个来源的库用起来比较省心，因为它们的目录已经加入了环境变量中了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看环境变量的方式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/Users/ppsteven/anaconda3/lib/python37.zip'</span>, <span class="string">'/Users/ppsteven/anaconda3/lib/python3.7'</span>, <span class="string">'/Users/ppsteven/anaconda3/lib/python3.7/lib-dynload'</span>, <span class="string">'/Users/ppsteven/anaconda3/lib/python3.7/site-packages'</span>, <span class="string">'/Users/ppsteven/anaconda3/lib/python3.7/site-packages/aeosa'</span>, <span class="string">'/Users/ppsteven/anaconda3/lib/python3.7/site-packages/xgboost-1.0.0_SNAPSHOT-py3.7.egg'</span>]</span><br></pre></td></tr></table></figure>



<h2 id="从模块导入"><a href="#从模块导入" class="headerlink" title="从模块导入"></a>从模块导入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line">lru_cache(*args)</span><br></pre></td></tr></table></figure>

<p>同样，你也可以导入该模块中的所有函数和变量，<strong><em>只是这种导入方式是不被推荐的</em></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>官方建议我们，需要对 <code>import</code> 的函数，要显式的写出，但是当函数过多的时候，我们可能写成多行的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path, walk, unlink</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> uname, remove</span><br></pre></td></tr></table></figure>

<p>为了能用一个 import 实现，我们可以利用 <code>括号</code> 帮助，或者 <code>\</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> (path, walk, unlink, uname, </span><br><span class="line">                remove, rename)</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path, walk, unlink, uname, \</span><br><span class="line">                remove, rename</span><br></pre></td></tr></table></figure>



<h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p>当使用的是绝对路径时，容易出现的问题是，在大型的项目中，当你改变包结构的时候，你需要对你的代码进行大幅度的修改。</p>
<p>另外，如果没有相对路径，那么包内的模块无法轻松导入自身。</p>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .foo <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> ...foo <span class="keyword">import</span> bar</span><br></pre></td></tr></table></figure>

<p>这两种形式有两种不同的建议语义。一种语义是使每个点代表一个级别。但是数需要多少个点也是一件麻烦事。</p>
<p>另一种选择是只允许一个相对导入级别，这样的话又会制约模块的功能。</p>
<p>最后的选择是定义一种算法，用于查找相关的模块和软件包。 这里的反对意见是“明确胜于隐含”。 （建议的算法是“从当前程序包目录中搜索，直到最终的父程序包被命中为止。”）</p>
<h3 id="只导入兄弟模块"><a href="#只导入兄弟模块" class="headerlink" title="只导入兄弟模块"></a>只导入兄弟模块</h3><p>一种建议是，只导入 <code>兄弟</code> 模块。换言之，对于更高层级的模块，使用绝对路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .spam <span class="keyword">import</span> eggs</span><br><span class="line"><span class="keyword">import</span> .spam.eggs</span><br></pre></td></tr></table></figure>

<h3 id="使用索引父节点"><a href="#使用索引父节点" class="headerlink" title="使用索引父节点"></a>使用索引父节点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="number">-2.</span>spam <span class="keyword">import</span> eggs <span class="comment"># 高层级</span></span><br><span class="line"><span class="keyword">from</span> .spam <span class="keyword">import</span> eggs <span class="comment"># 本地</span></span><br></pre></td></tr></table></figure>



<h3 id="把代码组织成很多分层模块的包"><a href="#把代码组织成很多分层模块的包" class="headerlink" title="把代码组织成很多分层模块的包"></a>把代码组织成很多分层模块的包</h3><p>使用一个 leading dot 作为相对路径，两个或以上代表父目录。</p>
<blockquote>
<p>这里我们把整个项目作为一个包来看待，需要对每一层写一个 <code>__init__.py</code> 文件<br>这里，我们整个项目可以看成 <code>package</code> 包，和 <code>subpackage1</code> 和 <code>subpackage2</code> 两个子包。</p>
</blockquote>
<p>实现的方法很简单，就是确保在每一层目录上添加一个 <code>__init__.py</code> 文件</p>
<p>下面是我们的目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package/</span><br><span class="line">    __init__.py</span><br><span class="line">    subpackage1/</span><br><span class="line">        __init__.py</span><br><span class="line">        moduleX.py  # 当前文件</span><br><span class="line">        moduleY.py</span><br><span class="line">    subpackage2/</span><br><span class="line">        __init__.py # 当前文件</span><br><span class="line">        moduleZ.py </span><br><span class="line">    moduleA.py</span><br></pre></td></tr></table></figure>

<p>假设 <code>moduleX.py</code> 和 <code>__init__.py</code> 是我们的当前文件，那么正确的导入的做法是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .moduleY <span class="keyword">import</span> spam</span><br><span class="line"><span class="keyword">from</span> .moduleY <span class="keyword">import</span> spam <span class="keyword">as</span> ham</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> moduleY</span><br><span class="line"><span class="keyword">from</span> ..subpackage1 <span class="keyword">import</span> moduleY</span><br><span class="line"><span class="keyword">from</span> ..subpackage2.moduleZ <span class="keyword">import</span> eggs</span><br><span class="line"><span class="keyword">from</span> ..moduleA <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> ...package <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> ...sys <span class="keyword">import</span> path</span><br></pre></td></tr></table></figure>

<blockquote><p>相对路径必须使用  <code>from &lt;&gt; import</code></p>
<p>绝对路径使用 <code>import &lt;&gt;</code>  </p>
</blockquote>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> subpackage1</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> subpackage2</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_package/subpackage1/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> module_x</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> module_y</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_package/subpackage1/module_x.py</span></span><br><span class="line"><span class="keyword">from</span> .module_y <span class="keyword">import</span> spam <span class="keyword">as</span> ham</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ham()</span><br><span class="line"><span class="comment"># my_package/subpackage1/module_y.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'spam '</span> * <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>我们切换到 <code>my_package</code> 上一层的目录，运行下面代码是正常的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> my_package</span><br><span class="line"> </span><br><span class="line">In [<span class="number">2</span>]: my_package.subpackage1.module_x</span><br><span class="line">Out[<span class="number">2</span>]: &lt;module <span class="string">'my_package.subpackage1.module_x'</span> <span class="keyword">from</span> <span class="string">'my_package/subpackage1/module_x.py'</span>&gt;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">3</span>]: my_package.subpackage1.module_x.main()</span><br><span class="line">spam spam spam</span><br></pre></td></tr></table></figure>



<h2 id="可选导入"><a href="#可选导入" class="headerlink" title="可选导入"></a>可选导入</h2><p>可选导入用的情况比较少，一般是用在需要导入一个模块，但是这个模块并不一定存在的情况。比如我们使用的python 版本不一致的时候，需要导入的模块也会有所不同，这样的写法能加强模块的健壮性=</p>
<h3 id="github2"><a href="#github2" class="headerlink" title="github2"></a>github2</h3><p>下面是一段来自 <a href="http://pythonhosted.org/github2/_modules/github2/request.html" target="_blank" rel="noopener">github2</a> 的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># For Python 3</span></span><br><span class="line">    <span class="keyword">from</span> http.client <span class="keyword">import</span> responses</span><br><span class="line"><span class="keyword">except</span> ImportError:  <span class="comment"># For Python 2.5-2.7</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> httplib <span class="keyword">import</span> responses  <span class="comment"># NOQA</span></span><br><span class="line">    <span class="keyword">except</span> ImportError:  <span class="comment"># For Python 2.4</span></span><br><span class="line">        <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> BaseHTTPRequestHandler <span class="keyword">as</span> _BHRH</span><br><span class="line">        responses = dict([(k, v[<span class="number">0</span>]) <span class="keyword">for</span> k, v <span class="keyword">in</span> _BHRH.responses.items()])</span><br></pre></td></tr></table></figure>

<h3 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a>lxml</h3><p>下面是一段来自  <a href="https://github.com/lxml/lxml/blob/master/src/lxml/ElementInclude.py" target="_blank" rel="noopener">lxml package</a> 的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> urlparse <span class="keyword">import</span> urljoin</span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="comment"># Python 3</span></span><br><span class="line">    <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br></pre></td></tr></table></figure>



<h2 id="本地导入"><a href="#本地导入" class="headerlink" title="本地导入"></a>本地导入</h2><p>导入的模块分为 <code>local scope</code> 和 <code>global scope</code> 空间。当你在 <code>python script</code> 的头部导入的时候，作用在全局域。当在函数中导入的时候是本地域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys  <span class="comment"># global scope</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="comment"># This import is into the square_root functions local scope</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(a)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_pow</span><span class="params">(base_num, power)</span>:</span></span><br><span class="line">    <span class="comment"># 这里直接使用 math 会报错的</span></span><br><span class="line">    <span class="keyword">return</span> math.pow(base_num, power)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(square_root(<span class="number">49</span>))</span><br><span class="line">    print(my_pow(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<h2 id="导入的注意事项"><a href="#导入的注意事项" class="headerlink" title="导入的注意事项"></a>导入的注意事项</h2><p>容易犯错误的主要有两点</p>
<ul>
<li>循环导入</li>
<li>Shadowed imports</li>
</ul>
<h3 id="循环导入"><a href="#循环导入" class="headerlink" title="循环导入"></a>循环导入</h3><p>简言之，就是模块相互导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in a_test"</span>)</span><br><span class="line">    b.b_test()</span><br><span class="line"> </span><br><span class="line">a_test()</span><br></pre></td></tr></table></figure>

<p>我们在相同的文件夹下，创建一个文件 <code>b.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'In test_b"'</span>)</span><br><span class="line">    a.a_test()</span><br><span class="line"> </span><br><span class="line">b_test()</span><br></pre></td></tr></table></figure>

<p>如果是你运行这些模块的话，你将会获得 <strong>AttributeError</strong> 报错。虽然有一些旁门左道的变通方法可以解决，但是还是建议重构代码。</p>
<h2 id="覆盖导入-Shadowed-imports"><a href="#覆盖导入-Shadowed-imports" class="headerlink" title="覆盖导入(Shadowed imports)"></a>覆盖导入(Shadowed imports)</h2><p>覆盖导入是指导入一个和官方库起名一样的模块，会报错。</p>
<p>主要的原因是，python 会首先搜索本地文件夹下的模块，其次是搜索其他路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(number)</span><br><span class="line"> </span><br><span class="line">square_root(<span class="number">72</span>)</span><br></pre></td></tr></table></figure>











<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.blog.pythonlibrary.org/2016/03/01/python-101-all-about-imports/" target="_blank" rel="noopener">Python 101: All about imports</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>import</tag>
      </tags>
  </entry>
  <entry>
    <title>Python编码规范</title>
    <url>/2020/01/12/python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>Python编码规范</p>
<p><a href="http://jb51.net/article/139495.htm" target="_blank" rel="noopener">Python 编码规范(Google Python Style Guide</a></p>
<p>目前写了:</p>
<ul>
<li>函数、模块、变量等命名</li>
<li>函数注释</li>
<li>字符串编码规范</li>
<li>TODO 模块的导入规范，项目的结构</li>
</ul>
<a id="more"></a>

<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p><strong>应该避免的名称</strong></p>
<ol>
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ol>
<p><strong>命名约定</strong></p>
<ol>
<li><p>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</p>
</li>
<li><p>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).</p>
</li>
<li><p>用双下划线(__)开头的实例变量或方法表示类内私有.</p>
</li>
<li><p>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</p>
</li>
<li><p>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</p>
<p><strong>Python之父Guido推荐的规范</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Public</th>
<th align="left">Internal</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Modules</td>
<td align="left">lower_with_under</td>
<td align="left">_lower_with_under</td>
</tr>
<tr>
<td align="left">Packages</td>
<td align="left">lower_with_under</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Classes</td>
<td align="left">CapWords</td>
<td align="left">_CapWords</td>
</tr>
<tr>
<td align="left">Exceptions</td>
<td align="left">CapWords</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Functions</td>
<td align="left">lower_with_under()</td>
<td align="left">_lower_with_under()</td>
</tr>
<tr>
<td align="left">Global/Class Constants</td>
<td align="left">CAPS_WITH_UNDER</td>
<td align="left">_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td align="left">Global/Class Variables</td>
<td align="left">lower_with_under</td>
<td align="left">_lower_with_under</td>
</tr>
<tr>
<td align="left">Instance Variables</td>
<td align="left">lower_with_under</td>
<td align="left">_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td align="left">Method Names</td>
<td align="left">lower_with_under()</td>
<td align="left">_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td align="left">Function/Method Parameters</td>
<td align="left">lower_with_under</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Local Variables</td>
<td align="left">lower_with_under</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li>模块尽量使用小写命名，首字母保持小写，尽量不要用下划线</li>
<li>类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头</li>
<li>函数名一律小写，如有多个单词，用下划线隔开</li>
<li>私有函数可用一个下划线开头</li>
<li>变量名尽量小写, 如有多个单词，用下划线隔开</li>
<li>常量采用全大写，如有多个单词，使用下划线隔开</li>
</ul>
<h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><p><strong>reST</strong></p>
<p>参考：<a href="https://www.cnblogs.com/19921019yy/p/8024731.html" target="_blank" rel="noopener">python代码规范以及函数注释规范</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is a reST style.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">:param param1: this is a first param</span></span><br><span class="line"><span class="string">:param param2: this is a second param</span></span><br><span class="line"><span class="string">:returns: this is a description of what is returned</span></span><br><span class="line"><span class="string">:raises keyError: raises an exception</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>下面的一个例子，来自：<a href="https://blog.csdn.net/teacher20133/article/details/79894828" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pinyin</span><span class="params">(hans, style=Style.TONE, heteronym=False,</span></span></span><br><span class="line"><span class="function"><span class="params">           errors=<span class="string">'default'</span>, strict=True)</span>:</span></span><br><span class="line">    <span class="string">"""将汉字转换为拼音.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :param hans: 汉字字符串( ``'你好吗'`` )或列表( ``['你好', '吗']`` ).</span></span><br><span class="line"><span class="string">                 可以使用自己喜爱的分词模块对字符串进行分词处理,</span></span><br><span class="line"><span class="string">                 只需将经过分词处理的字符串列表传进来就可以了。</span></span><br><span class="line"><span class="string">    :type hans: unicode 字符串或字符串列表</span></span><br><span class="line"><span class="string">    :param style: 指定拼音风格，默认是 :py:attr:`~pypinyin.Style.TONE` 风格。</span></span><br><span class="line"><span class="string">                  更多拼音风格详见 :class:`~pypinyin.Style`</span></span><br><span class="line"><span class="string">    :param errors: 指定如何处理没有拼音的字符</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">                   * ``'default'``: 保留原始字符</span></span><br><span class="line"><span class="string">                   * ``'ignore'``: 忽略该字符</span></span><br><span class="line"><span class="string">                   * ``'replace'``: 替换为去掉 ``\\u`` 的 unicode 编码字符串</span></span><br><span class="line"><span class="string">                     (``'\\u90aa'`` =&gt; ``'90aa'``)</span></span><br><span class="line"><span class="string">                   * callable 对象: 回调函数之类的可调用对象。如果 ``errors``</span></span><br><span class="line"><span class="string">                     参数 的值是个可调用对象，那么程序会回调这个函数:</span></span><br><span class="line"><span class="string">                     ``func(char)``::</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">                         def foobar(char):</span></span><br><span class="line"><span class="string">                             return 'a'</span></span><br><span class="line"><span class="string">                         pinyin('あ', errors=foobar)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :param heteronym: 是否启用多音字</span></span><br><span class="line"><span class="string">    :param strict: 是否严格遵照《汉语拼音方案》来处理声母和韵母，详见 :ref:`strict`</span></span><br><span class="line"><span class="string">    :return: 拼音列表</span></span><br><span class="line"><span class="string">    :rtype: list</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    Usage::</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; from pypinyin import pinyin, Style</span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; import pypinyin</span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; pinyin('中心')</span></span><br><span class="line"><span class="string">      [['zhōng'], ['xīn']]</span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; pinyin('中心', heteronym=True)  # 启用多音字模式</span></span><br><span class="line"><span class="string">      [['zhōng', 'zhòng'], ['xīn']]</span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; pinyin('中心', style=Style.FIRST_LETTER)  # 设置拼音风格</span></span><br><span class="line"><span class="string">      [['z'], ['x']]</span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; pinyin('中心', style=Style.TONE2)</span></span><br><span class="line"><span class="string">      [['zho1ng'], ['xi1n']]</span></span><br><span class="line"><span class="string">      &gt;&gt;&gt; pinyin('中心', style=Style.CYRILLIC)</span></span><br><span class="line"><span class="string">      [['чжун1'], ['синь1']]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 对字符串进行分词处理</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(hans, text_type):</span><br></pre></td></tr></table></figure>



<h2 id="py文件头文件"><a href="#py文件头文件" class="headerlink" title=".py文件头文件"></a>.py文件头文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- encoding:utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">   File Name：     $&#123;NAME&#125;</span></span><br><span class="line"><span class="string">   Description :  </span></span><br><span class="line"><span class="string">   Author :       $&#123;USER&#125;</span></span><br><span class="line"><span class="string">   date：         $&#123;DATE&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">   Change Activity:</span></span><br><span class="line"><span class="string">                   $&#123;DATE&#125;: </span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 上面的代码加入 PyCharm 中</span></span><br></pre></td></tr></table></figure>



<h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><p>这里我们参考 <code>崔庆才</code> 书中 <code>Scrapy 微博爬虫</code> 的编码风格</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Weibo</span><br><span class="line">├── README.md</span><br><span class="line">├── scrapy.cfg</span><br><span class="line">└── weibo</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── items.py</span><br><span class="line">    ├── middlewares.py</span><br><span class="line">    ├── pipelines.py</span><br><span class="line">    ├── settings.py</span><br><span class="line">    └── spiders</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── weibocn.py</span><br></pre></td></tr></table></figure>

<h2 id="weibocn-py-文件"><a href="#weibocn-py-文件" class="headerlink" title="weibocn.py 文件"></a>weibocn.py 文件</h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line"><span class="addition">+ from scrapy import Request, Spider # 可以看到导入的模块名也是 双驼峰 </span></span><br><span class="line">from weibo.items import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="addition">+ class WeiboSpider(Spider): # 类名双驼峰  WebioSpider</span></span><br><span class="line">    name = 'weibocn'</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   allowed_domains = ['m.weibo.cn'] # 变量全部小写，用下划线_ 连接</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="addition">+   start_users = ['3217179555', '1742566624', '2282991915', '1288739185', '3952070245', '5878659096']</span></span><br><span class="line">    </span><br><span class="line"><span class="addition">+   def start_requests(self): # 函数名全部小写，用下划线_ 连接</span></span><br><span class="line">        for uid in self.start_users:</span><br><span class="line">            yield Request(self.user_url.format(uid=uid), callback=self.parse_user)</span><br><span class="line">    </span><br><span class="line">    def parse_user(self, response): </span><br><span class="line"><span class="addition">+       """</span></span><br><span class="line"><span class="addition">+       解析用户信息                          代码注释风格</span></span><br><span class="line"><span class="addition">+       :param response: Response对象</span></span><br><span class="line"><span class="addition">+        """</span></span><br><span class="line">        self.logger.debug(response)</span><br><span class="line">        result = json.loads(response.text)</span><br><span class="line">        if result.get('data').get('userInfo'):</span><br><span class="line">            user_info = result.get('data').get('userInfo')</span><br><span class="line">            user_item = UserItem()</span><br><span class="line">            field_map = &#123;</span><br><span class="line">                'id': 'id', 'name': 'screen_name', 'avatar': 'profile_image_url', 'cover': 'cover_image_phone',</span><br><span class="line">                'gender': 'gender', 'description': 'description', 'fans_count': 'followers_count',</span><br><span class="line">                'follows_count': 'follow_count', 'weibos_count': 'statuses_count', 'verified': 'verified',</span><br><span class="line">                'verified_reason': 'verified_reason', 'verified_type': 'verified_type'</span><br><span class="line">            &#125;</span><br><span class="line">            for field, attr in field_map.items():</span><br><span class="line">                user_item[field] = user_info.get(attr)</span><br><span class="line">            yield user_item</span><br><span class="line"><span class="addition">+           # 关注</span></span><br><span class="line">            uid = user_info.get('id')</span><br><span class="line">            yield Request(self.follow_url.format(uid=uid, page=1), callback=self.parse_follows,</span><br><span class="line">                          meta=&#123;'page': 1, 'uid': uid&#125;)</span><br><span class="line"><span class="addition">+           # 粉丝</span></span><br><span class="line">            yield Request(self.fan_url.format(uid=uid, page=1), callback=self.parse_fans,</span><br><span class="line">                          meta=&#123;'page': 1, 'uid': uid&#125;)</span><br><span class="line"><span class="addition">+           # 微博</span></span><br><span class="line">            yield Request(self.weibo_url.format(uid=uid, page=1), callback=self.parse_weibos,</span><br><span class="line">                          meta=&#123;'page': 1, 'uid': uid&#125;)</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 环境配置（持续总结）</title>
    <url>/2020/01/12/centos-install-introduction/</url>
    <content><![CDATA[<p>本章节收集一下配置一个centos 环境所需要的操作</p>
<ul>
<li><p>git</p>
</li>
<li><p>wget</p>
</li>
<li><p>MiniConda(python)</p>
</li>
<li><p>mysql</p>
</li>
<li><p>…</p>
</li>
<li><p>web-vscode</p>
</li>
<li><p>phpredisAdmin(redis web 管理工具)</p>
</li>
</ul>
<a id="more"></a>

<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="显示完整文件路径"><a href="#显示完整文件路径" class="headerlink" title="显示完整文件路径"></a>显示完整文件路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令行提示符完全显示完整的工作目录名称:（推荐用法）</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">'[\u@\h $PWD]$ '</span></span><br><span class="line">命令行提示符只列出最后一个目录：</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">'[\u@\h \W]$'</span></span><br><span class="line">命令行提示符显示完整工作目录，当前用户目录会以 ~代替：</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">'[\u@\h \w]$'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>命令释义</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\u 显示当前用户账号</span><br><span class="line">\h 显示当前主机名</span><br><span class="line">\W 只显示当前路径最后一个目录</span><br><span class="line">\w 显示当前绝对路径（当前用户目录会以 ~代替）</span><br><span class="line">$PWD 显示当前全路径</span><br><span class="line">\$ 显示命令行’$&apos;或者’#&apos;符号</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：<a href="https://www.cnblogs.com/gered/p/11364053.html" target="_blank" rel="noopener">linux下显示完整路径，linux下显示绝对路径</a></p>
</blockquote>
<h2 id="必要软件安装"><a href="#必要软件安装" class="headerlink" title="必要软件安装"></a>必要软件安装</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum search ifconfig</span><br><span class="line">============================== 匹配：ifconfig ============================================</span><br><span class="line">net-tools.x86_64 : Basic networking tools</span><br><span class="line">$ yum install net-tools.x86_64</span><br></pre></td></tr></table></figure>

<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y git</span><br></pre></td></tr></table></figure>

<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y wget</span><br></pre></td></tr></table></figure>

<h3 id="7z压缩"><a href="#7z压缩" class="headerlink" title="7z压缩"></a>7z压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install p7zip</span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">7za <span class="built_in">test</span> -t7z -r test.7z <span class="built_in">test</span></span><br><span class="line"><span class="comment">#a  代表添加文件／文件夹到压缩包</span></span><br><span class="line">-t 是指定压缩类型，这里定为7z，可不指定，因为7za默认压缩类型就是7z。</span><br><span class="line">-r 表示递归所有的子文件夹</span><br><span class="line">7za x test.7z -r -o./</span><br><span class="line"><span class="comment"># x  代表解压缩文件，并且是按原始目录树解压（还有个参数 e 也是解压缩文件，但其会将所有文件都解压到根下，而不是自己原有的文件夹下）</span></span><br><span class="line"><span class="comment"># -r 表示递归解压缩所有的子文件夹</span></span><br><span class="line"><span class="comment"># -o 是指定解压到的目录，-o后是没有空格的，直接接目录。这一点需要注意。</span></span><br><span class="line"><span class="comment"># FRE COMMAND</span></span><br><span class="line">7za <span class="built_in">test</span> test.7z</span><br><span class="line">7za x test.7z</span><br></pre></td></tr></table></figure>

<h3 id="sz-rz"><a href="#sz-rz" class="headerlink" title="sz, rz"></a>sz, rz</h3><p>服务器上传，下载文件，除了使用FTP软件外，lrzsz是一个unix通信套件提供的X，Y，和ZModem文件传输协议,是一个非常强大的文件传输工具，安装方便，使用简单。</p>
<p>rzsz 官网入口：<a href="https://link.jianshu.com/?t=http://freecode.com/projects/lrzsz/" target="_blank" rel="noopener">http://freecode.com/projects/lrzsz/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum -y install lrzsz</span><br><span class="line">sz filename <span class="comment"># 下载文件 filename</span></span><br><span class="line">rz <span class="comment"># 上传文件</span></span><br></pre></td></tr></table></figure>

<h3 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install psmisc</span><br><span class="line">pstree</span><br></pre></td></tr></table></figure>



<h3 id="MiniConda"><a href="#MiniConda" class="headerlink" title="MiniConda"></a>MiniConda</h3><h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/</a></p>
<p>下载最新的版本，一般来说是 <code>Miniconda-latest-Linux</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda-latest-Linux-x86_64.sh</span><br><span class="line">$ yum -y install bzip2 <span class="comment"># 下载解压软件</span></span><br><span class="line">$ bash Miniconda-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export PATH=/root/miniconda2/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; .bashrc</span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 检查是否成功安装</span></span><br><span class="line">$ /root/miniconda2/bin/conda -V</span><br><span class="line">conda 4.0.5</span><br></pre></td></tr></table></figure>

<h4 id="配置-Anaconda-仓库镜像源"><a href="#配置-Anaconda-仓库镜像源" class="headerlink" title="配置 Anaconda 仓库镜像源"></a>配置 Anaconda 仓库镜像源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>

<h4 id="设置快捷命令"><a href="#设置快捷命令" class="headerlink" title="设置快捷命令"></a>设置快捷命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> conl=<span class="string">"conda env list"</span></span><br><span class="line"><span class="built_in">alias</span> conc=<span class="string">"conda create -n"</span></span><br><span class="line"><span class="built_in">alias</span> cona=<span class="string">"source activate"</span></span><br><span class="line"><span class="built_in">alias</span> cond=<span class="string">"source deactivate"</span></span><br><span class="line"><span class="built_in">alias</span> conr=<span class="string">"conda remove --all -n"</span></span><br></pre></td></tr></table></figure>

<h4 id="新建-python-环境"><a href="#新建-python-环境" class="headerlink" title="新建 python 环境"></a>新建 python 环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新环境 base 并安装python3.6</span></span><br><span class="line">$ conda create -n base python=3.6</span><br><span class="line"><span class="comment"># 查看当前环境</span></span><br><span class="line">$ conl</span><br><span class="line"><span class="comment"># conda environments:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">base                     /root/miniconda2/envs/base</span><br><span class="line">root                  *  /root/miniconda2</span><br><span class="line"><span class="comment"># 切换为 base 环境</span></span><br><span class="line">$ cona base</span><br><span class="line">$ <span class="built_in">which</span> python </span><br><span class="line">/root/miniconda2/envs/base/bin/python <span class="comment"># 当前python的地址</span></span><br></pre></td></tr></table></figure>

<p>安装必要的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install --upgrade pip</span><br><span class="line">$ pip install numpy pandas jsonpath pymysql requests datetime dateutil</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考来源：<a href="https://blog.51cto.com/loufeng/2342003" target="_blank" rel="noopener">Centos7安装Miniconda及配置jupyter</a></p>
</blockquote>
<h3 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h3><p>shadowsocks 需要利用 <code>pip</code> 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建配置文件ss.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># vim ss.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"*.*.*.*"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:***,</span><br><span class="line">    "local_server":"0.0.0.0", # 默认127.0.0.1</span><br><span class="line">    "local_port":1081,</span><br><span class="line">    "password":"*****",</span><br><span class="line">    "timeout":600,</span><br><span class="line">    "method":"aes-256-cfb"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动ss隧道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前台方式运行</span></span><br><span class="line">/root/miniconda2/envs/base/bin/sslocal -c ss.json</span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">nohup /root/miniconda2/envs/base/bin/sslocal -c ss.json &gt;&gt; ss.log 1&gt;2&amp;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>MariaDB 是由 MySQL 开发的 MySQL的替代版本。如果我们直接在 Centos 上 <code>yum install mysql</code> </p>
<h4 id="第零步：查看系统版本号"><a href="#第零步：查看系统版本号" class="headerlink" title="第零步：查看系统版本号"></a>第零步：查看系统版本号</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure>

<h4 id="第一步：安装MySQL"><a href="#第一步：安装MySQL" class="headerlink" title="第一步：安装MySQL"></a>第一步：安装MySQL</h4><p>需要到如下网站上去定位需要安装的版本号</p>
<p><a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></p>
<blockquote>
<p>注意：我们使用的CentOs Linux 7 选择下面的第二个</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200121224825.png" alt=""></p>
<p>不用试图去点击右手边的 <code>Download</code>  按钮，因为这个会导向一个登陆界面。获取版本号后，直接用 wget 下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载完了以后，还是可以检查一下是否正常下载</span></span><br><span class="line">$ md5sum mysql80-community-release-fc30-1.noarch.rpm</span><br><span class="line"></span><br><span class="line">$ rpm -ivh mysql80-community-release-fc30-1.noarch.rpm</span><br><span class="line">警告：mysql80-community-release-fc30-1.noarch.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY</span><br><span class="line">准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:mysql80-community-release-fc30-1 <span class="comment">################################# [100%]</span></span><br></pre></td></tr></table></figure>

<p>若是安装错误 repo 源了怎么办？我很不幸就干过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有 mysql 源</span></span><br><span class="line">$ rpm -qa|grep mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删掉安装错误的 mysql 源</span></span><br><span class="line">$ rpm -e mysql80-community-release-fc30-1.noarch --nodeps</span><br></pre></td></tr></table></figure>

<p>安装 MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install mysql-server</span><br></pre></td></tr></table></figure>

<h4 id="第二步：启动-mysql-服务"><a href="#第二步：启动-mysql-服务" class="headerlink" title="第二步：启动 mysql 服务"></a>第二步：启动 mysql 服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p>该命令不会返回报错，为了进一步确认 mysql 服务确实启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl status mysqld</span><br><span class="line">Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 二 2020-01-28 20:07:00 CST; 6s ago</span><br><span class="line">     Docs: man:mysqld(8)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">  Process: 12281 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 12402 (mysqld)</span><br><span class="line">   Status: <span class="string">"Server is operational"</span></span><br><span class="line">    Tasks: 39</span><br><span class="line">   Memory: 616.5M</span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─12402 /usr/sbin/mysqld</span><br></pre></td></tr></table></figure>

<h4 id="第三步：修改默认配置"><a href="#第三步：修改默认配置" class="headerlink" title="第三步：修改默认配置"></a>第三步：修改默认配置</h4><p>首先，我们需要修改 MySQL 给我们的默认密码，这个直接从日志中获取即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/mysqld.log | grep <span class="string">"temporary password"</span></span><br><span class="line">2020-01-28T12:06:55.699956Z 5 [Note] [MY-010454] [Server] A temporary password is generated <span class="keyword">for</span> root@localhost: 5H(?khVdysDW</span><br></pre></td></tr></table></figure>

<p>初始密码只能用于登录，但是此时你不能进行任何操作，必须修改新的密码</p>
<p>在修改密码之前，你需要做的是修改密码的规格（默认的规格···太严格了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># validate_password_policy代表密码策略，默认是1：符合长度，且必须含有数字，小写或大写字母，特殊字符。设置为0判断密码的标准就基于密码的长度了。一定要先修改两个参数再修改密码</span><br><span class="line">set global validate_password.policy=0;</span><br><span class="line"></span><br><span class="line"># validate_password_length代表密码长度，最小值为4</span><br><span class="line">set global validate_password.length=4;</span><br></pre></td></tr></table></figure>

<p>最后，修改为合适的密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'new password'</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们安装的是 MySQL8.0 以上的版本，加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password。为了解决兼容性问题，一般来说，我选择把加密等级调低一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200128214315.png" alt=""></p>
<p>最后需要修改一下，加密规则 和 远程登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">UPDATE user SET host = &apos;%&apos; where user = &apos;root&apos;;</span><br><span class="line"></span><br><span class="line">ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考资料:<br><a href="https://www.cnblogs.com/zipxzf/p/10718544.html" target="_blank" rel="noopener">CentOS7 安装并配置MySQL8.0</a><br><a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-centos-7" target="_blank" rel="noopener">How To Install MySQL on CentOS 7</a><br><a href="https://www.cnblogs.com/leelice/p/10728129.html" target="_blank" rel="noopener">centos彻底卸载mysql（不保留数据）</a></p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用yum 安装</span></span><br><span class="line">$ yum install -y redis</span><br></pre></td></tr></table></figure>

<p>默认是不设置密码的，我们需要在上面进行更进一步的<strong>安全策略配置</strong>。之前腾讯云上的一台服务器，由于暴露了无密码的redis接口，就中了 <strong>挖矿木马</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/redis.conf</span></span><br><span class="line"><span class="comment"># bind：绑定主机IP，默认值为127.0.0.1</span></span><br><span class="line"><span class="string">bind</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 将这一行指注释掉，可以运行远程访问。不注释，只运行本地访问，安全性很高</span></span><br><span class="line"><span class="comment"># daemonize：是否以后台进程运行，默认为no。Windows下不支持修改 。Linux平台下可以改为yes，这样就不用为了启动Redis而单独保留一个shell窗口。</span></span><br><span class="line"><span class="comment"># pidfile：如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pid。Windows下不支持修改。</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span> <span class="comment"># 监听端口，默认为6379</span></span><br><span class="line"><span class="string">timeout</span> <span class="number">300</span> <span class="comment"># 超时时间，设置为300（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span> <span class="comment"># 本地数据库文件名，默认值为dump.rdb</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/var/lib/redis</span> <span class="comment"># 本地数据库存放路径，默认值为 /var/lib/redis</span></span><br><span class="line"><span class="string">requirepass</span> <span class="string">ABCD123</span> <span class="comment"># 强烈建议设置 连接密码</span></span><br><span class="line"></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span> <span class="comment"># 是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个配置选项前都有详细的英文注释，如有需要可自行查阅配置。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上只是选择了我认为的一些常用的设置，参考来源：<a href="https://www.jianshu.com/p/e90317668ae2" target="_blank" rel="noopener">邻居小黑</a> 和 <a href="https://www.runoob.com/redis/redis-conf.html" target="_blank" rel="noopener">redis 菜鸟教程</a><br>更多的安全策略，可以借鉴 <a href="https://help.aliyun.com/knowledge_detail/37447.html?spm=a2c4g.11186631.2.2.828c1848kuRv6p" target="_blank" rel="noopener">Redis服务安全加固</a></p>
</blockquote>
<p>yum 安装下来的服务，已经帮我们创建好了服务。我们直接使用重启就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart redis </span><br><span class="line">● redis.service - Redis persistent key-value database</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/redis.service; disabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/redis.service.d</span><br><span class="line">           └─limit.conf</span><br><span class="line">   Active: active (running) since 六 2020-03-07 13:39:44 CST; 35s ago</span><br><span class="line"> Main PID: 12655 (redis-server)</span><br><span class="line">    Tasks: 3</span><br><span class="line">   Memory: 1.0M</span><br><span class="line">   CGroup: /system.slice/redis.service</span><br><span class="line">           └─12655 /usr/bin/redis-server 127.0.0.1:6379</span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; get abc</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"><span class="comment"># 再一次的运行 redis-cli 发现已经需要了密码</span></span><br><span class="line">127.0.0.1:6379&gt; auth YOURPASSWORD</span><br></pre></td></tr></table></figure>



<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>docker 安装其实比较麻烦的，感谢 <code>图灵:Docker开发指南</code> 给的安装建议，我们可以直接用别人写好的脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://get.docker.com &gt; install.sh</span><br><span class="line">chmod +x install.sh</span><br><span class="line">cat install.sh <span class="comment"># 感兴趣的话，可以研究一下 shell 究竟写了啥</span></span><br><span class="line">./install.sh </span><br><span class="line"><span class="comment"># 安装完了，记得启动 docker 服务</span></span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h4 id="linux下-docker-加速"><a href="#linux下-docker-加速" class="headerlink" title="linux下 docker 加速"></a>linux下 docker 加速</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo touch /etc/docker/daemon.json </span><br><span class="line"><span class="comment"># 添加国内站点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>,<span class="string">"http://hub-mirror.c.163.com"</span>,<span class="string">"https://mirror.ccs.tencentyun.com"</span>,<span class="string">"https://dockerhub.azk8s.cn"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker daemon</span></span><br><span class="line">$ sudo systemctl restart docker </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否有修改成功</span></span><br><span class="line">$ docker info </span><br><span class="line"><span class="comment"># 查看Register Mirrors的信息</span></span><br><span class="line">Registry Mirrors:</span><br><span class="line">  https://registry.docker-cn.com/</span><br><span class="line">  http://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose-github-安装"><a href="#docker-compose-github-安装" class="headerlink" title="docker-compose(github 安装)"></a>docker-compose(github 安装)</h4><blockquote>
<p>有条件的话，参考 <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker官方教程</a><br>这一种方法是官方推荐，但是鉴于中国墙，速度有可能非常感人</p>
</blockquote>
<h5 id="1-从-github-上下载-docker-compose-命令"><a href="#1-从-github-上下载-docker-compose-命令" class="headerlink" title="1. 从 github 上下载 docker-compose 命令"></a>1. 从 github 上下载 docker-compose 命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.3/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h5 id="2-赋予可执行权限"><a href="#2-赋予可执行权限" class="headerlink" title="2. 赋予可执行权限"></a>2. 赋予可执行权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h5 id="3-验证是否安装成功"><a href="#3-验证是否安装成功" class="headerlink" title="3. 验证是否安装成功"></a>3. 验证是否安装成功</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose-pip-安装"><a href="#docker-compose-pip-安装" class="headerlink" title="docker-compose(pip 安装)"></a>docker-compose(pip 安装)</h4><blockquote>
<p>一般容易出问题的是 pip 的版本，如果是使用了conda作为包管理的话，可能主要注意pip的版本。我一开始是使用base环境的pip作下载，然后将安装的docker-compose 软连接至 <code>/usr/local/bin</code> 中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>



<h3 id="Selenium-Chrome-环境配置"><a href="#Selenium-Chrome-环境配置" class="headerlink" title="Selenium + Chrome 环境配置"></a>Selenium + Chrome 环境配置</h3><p>linux 是无图形化界面，selenium 需要借助图形化的工具，下面我们直接看如何配置。</p>
<blockquote>
<p>参考教程：<a href="https://segmentfault.com/a/1190000019459125" target="_blank" rel="noopener">centos7安装selenium</a></p>
</blockquote>
<h4 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<h4 id="安装chrome-browser"><a href="#安装chrome-browser" class="headerlink" title="安装chrome-browser"></a>安装chrome-browser</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm --no-check-certificate</span><br><span class="line">yum install ./google-chrome-stable_current_x86_64.rpm</span><br><span class="line"><span class="comment"># 或者直接使用yum 安装</span></span><br><span class="line">yum install google-chrome</span><br><span class="line"><span class="comment"># 安装后，注意要查看一下 chrome 的版本号</span></span><br><span class="line">$ google-chrome --version</span><br><span class="line">Google Chrome 80.0.3987.87</span><br></pre></td></tr></table></figure>

<h4 id="下载chromedriver"><a href="#下载chromedriver" class="headerlink" title="下载chromedriver"></a>下载chromedriver</h4><blockquote>
<p>建议到 <a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">淘宝镜像</a>下载</p>
<p>更全一点的话，有 <a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">官方镜像</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200206175541.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://npm.taobao.org/mirrors/chromedriver/80.0.3987.16/chromedriver_linux64.zip</span><br><span class="line"><span class="comment"># 解压此文件，并将文件移动到/usr/bin目录下</span></span><br><span class="line">unzip chromedriver_linx64.zip</span><br><span class="line"><span class="comment"># 移到 /usr/bin 下后，之后运行的时候就不必特意制定 chromedriver 路径了</span></span><br><span class="line">mv chromedriver /usr/bin/</span><br></pre></td></tr></table></figure>

<h4 id="使用selenium"><a href="#使用selenium" class="headerlink" title="使用selenium"></a>使用selenium</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">url=<span class="string">'http://bing.com'</span></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'--no-sandbox'</span>)</span><br><span class="line">option.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">driver = webdriver.Chrome(chrome_options=option)</span><br><span class="line">driver.get(url)</span><br><span class="line">print(driver.page_source)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>git 实战（持续更新）</title>
    <url>/2020/01/12/git-skill-in-learning/</url>
    <content><![CDATA[<p>主要记录 git 在实际使用中碰到的问题，会逐步慢慢积累</p>
<h3 id="问题一：新项目如何与远端同步？"><a href="#问题一：新项目如何与远端同步？" class="headerlink" title="问题一：新项目如何与远端同步？"></a>问题一：新项目如何与远端同步？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@e.coding.net:datamate/pujiangjiaoye.git <span class="comment"># 添加远端仓库</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/master <span class="comment"># 设置分支对应关系</span></span><br><span class="line">$ git push --<span class="built_in">set</span>-upstream origin master <span class="comment"># 设置push 对应的远程仓库，建立本地分支的上游</span></span><br><span class="line">$ git remote -v <span class="comment"># 查看分支</span></span><br></pre></td></tr></table></figure>

<p>当我们尝试push的时候又会出现一个问题</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: 推送一些引用到 <span class="string">'git@e.coding.net:datamate/pujiangjiaoye.git'</span> 失败</span><br><span class="line">提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。</span><br><span class="line">提示：再次推送前，先与远程变更合并（如 <span class="string">'git pull ...'</span>）。详见</span><br><span class="line">提示：<span class="string">'git push --help'</span> 中的 <span class="string">'Note about fast-forwards'</span> 小节。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照提示，尝试用git pull 合并,又失败</span></span><br><span class="line">$ git pull</span><br><span class="line">fatal: 拒绝合并无关的历史</span><br></pre></td></tr></table></figure>

<p>原因是我们本地与远程的版本不一致，但是我们是新提交，怎么会出现这样的问题呢？<br>因为很多平台在我们创建项目的时候，自动帮我们创建了README.md文件，所以会有不一致的情况存在。git pull 失败的原因是，两个不一致的文件没有<strong><em>共同祖先的历史</em></strong>。</p>
<p>解决方法也很简单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200124225406.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200124225457.png" alt=""></p>
<h3 id="问题二：如何修改上一次的提交？"><a href="#问题二：如何修改上一次的提交？" class="headerlink" title="问题二：如何修改上一次的提交？"></a>问题二：如何修改上一次的提交？</h3><p>git 是分支管理的工具，我们的工作最好在一个 commit 中提交相应的代码，完成一个功能（如 bugfix 或者 feature_add ）。但是有的时候，我们的提交经过 Code Review 之后，可能会被打回来。这样面对新的修改，不应该重复提交。</p>
<p>首先，我们可以先建立一个提交。面对第二个文件（这里我们给 a 新增了 Hello world again ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200124225533.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200124225610.png" alt=""></p>
<p>第一种选择，我们提交两个 commit </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"second commit"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200124225659.png" alt=""></p>
<blockquote><p>第二种选择，我们直接修改上一次的修改（推荐）</p>
</blockquote>

<p>工作流如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend <span class="comment"># 代表直接在上一次的提交修改，这里会弹出上一次 commit 的信息。</span></span><br><span class="line">git push -f <span class="comment"># 由于我们只是改了本地，提交的时候使用 -f 强制推送一下</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里强烈建议，使用 –amend 的方法的时候，一定要检查 commit 的信息，确定不是把别人的给冲掉了。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200124225740.png" alt=""></p>
<h3 id="问题三：服务器端强制同步远端-git-仓库？"><a href="#问题三：服务器端强制同步远端-git-仓库？" class="headerlink" title="问题三：服务器端强制同步远端 git 仓库？"></a>问题三：服务器端强制同步远端 git 仓库？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch </span><br><span class="line">git reset  --hard origin/master <span class="comment"># 要强制同步的分支！--hard 是丢弃分支的修改</span></span><br><span class="line">git pull</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>



<h3 id="问题四：为什么修改了-gitignore-文件，忽略项还是不起作用"><a href="#问题四：为什么修改了-gitignore-文件，忽略项还是不起作用" class="headerlink" title="问题四：为什么修改了 .gitignore 文件，忽略项还是不起作用"></a>问题四：为什么修改了 <code>.gitignore</code> 文件，忽略项还是不起作用</h3><p>新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push</p>
<p>git清除本地缓存命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>下面附上我的 <code>.gitignore</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># MAC:</span><br><span class="line">*.DS_Store</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">*.log</span><br><span class="line">*.log.*</span><br></pre></td></tr></table></figure>

<p>如何使用 git merge</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开发分支（dev）上的代码达到上线的标准后，要合并到 master 分支</span></span><br><span class="line">git checkout dev</span><br><span class="line">git pull</span><br><span class="line">git checkout master</span><br><span class="line">git pull </span><br><span class="line">git merge dev</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当master代码改动了，需要更新开发分支（dev）上的代码</span></span><br><span class="line"></span><br><span class="line">git checkout master </span><br><span class="line">git pull </span><br><span class="line">git checkout dev <span class="comment"># 这里默认dev 远端没有动</span></span><br><span class="line">git merge master </span><br><span class="line">git push -u origin dev</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考: <a href="https://blog.csdn.net/zl1zl2zl3/article/details/94019526" target="_blank" rel="noopener">git merge最简洁用法</a></p>
</blockquote>
<p>推荐一个 <code>git merge</code> 比较好的教程： <a href="https://www.jianshu.com/p/1a7e38cdbf76" target="_blank" rel="noopener">merge：合并 commits</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置多个git账号</title>
    <url>/2020/01/12/how-to-manage-multipul-git/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200121014942.png" alt=""></p>
<p>随着学习和工作的深入，不可避免的会在电脑上有多个 git 账号，那么我们碰到的一个棘手的问题是如何管理我们的 git 账号。</p>
<p>本篇教程就是讲述如何处理这一类问题。</p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Git共有三个级别的 <code>config</code> 文件，分别是 <code>system</code> 、<code>global</code> 和 <code>local</code>。<code>global</code> 的在<code>$home\.gitconfig</code>，local的在仓库目录下的<code>.git\config</code>。这三个级别都分别配置了用户信息，当<code>git commit</code>时，会依次从local、global、system里读取用户信息。因此，我们利用local的配置来设置不同的用户信息</p>
<h2 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看git账号，会按顺序读取local,global的用户信息</span></span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是在空仓库中使用如下命令会出错，我们在仓库中使用--local，提前运行git init</span></span><br><span class="line">git config --<span class="built_in">local</span> -l</span><br><span class="line">fatal: --<span class="built_in">local</span> 只能在一个仓库内使用</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改本地账号</span></span><br><span class="line">git config --<span class="built_in">local</span>/--global user.name <span class="string">"Your name"</span></span><br><span class="line">git config --<span class="built_in">local</span>/--global user.email <span class="string">"Your email"</span></span><br><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span> -f ./</span><br><span class="line">-t rsa 约定加密类型</span><br><span class="line">-C 添加评论</span><br><span class="line">-f 保存秘钥的地址（默认是 ~/.ssh/id_rsa）</span><br></pre></td></tr></table></figure>

<p>生成公钥的地方需要注意的是，生成的公钥会自动生成在<code>~/.ssh/id_rsa</code>中，若是你有多个账号的话，无疑会把原先的秘钥覆盖。可以在后续弹出的提示中约定key保存的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]  // 推荐使用默认地址</span><br><span class="line">Enter passphrase (empty for no passphrase):   //此处点击 Enter 键即可，也可以填写密码，填写密码后每次使用 SSH 方式推送代码时都会要求输入密码，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</span><br></pre></td></tr></table></figure>

<p>也可以在ssh-keygen中约定好</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span> -f ~/.ssh/coding </span><br><span class="line">-f 保存在yon下的.ssh/coding文件中</span><br><span class="line"></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/ppsteven/.ssh/coding.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/ppsteven/.ssh/coding.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:P6R/Fo70VkCyKsQsFXXX... XXX@outlook.com</span><br></pre></td></tr></table></figure>

<p>.ssh 文件夹下也多了<code>coding</code>和<code>coding.pub</code>两个文件</p>
<p>coding是你的私钥，需要好好保管，在下面的配置文件中还需要使用，用以证明你自己的身份，coding.pub是公钥，我们需要上传到github，coding，码云等平台上去。</p>
<h2 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h2><p>这里只要找到对应上传的地方上传即可，一般平台都有对应的教程，下面我们copy一下coding的操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200119133041.png" alt=""></p>
<blockquote>
<p>mac 复制文件小技巧</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat coding.pub | pbcopy <span class="comment"># 输出到剪切板</span></span><br></pre></td></tr></table></figure>

<p>pbcopy  : 表示复制剪切版<br>pbpaste ：表示粘贴剪切版</p>
<h2 id="配置config文件和添加私钥"><a href="#配置config文件和添加私钥" class="headerlink" title="配置config文件和添加私钥"></a>配置config文件和添加私钥</h2><p>若是拥有多个账号，需要在 .ssh 下配置多个账号的配置文件 config ，这个配置文件是用来作为路由使用。<br>我们需要检查是否存在 <code>~/.ssh/config</code> 文件，不存在的话就创建如下文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ~/.ssh/config</span><br><span class="line"></span><br><span class="line"># github 账号</span><br><span class="line">Host github  # HostName的别名,这个可以随便起</span><br><span class="line">HostName github.com # HostName: 远程仓库的域名</span><br><span class="line">AddKeysToAgent yes </span><br><span class="line">UseKeychain yes # Mac 上秘钥被持久化到&quot;钥匙串&quot;中，代表从钥匙串中使用保存的秘钥</span><br><span class="line">IdentityFile ~/.ssh/id_rsa # 私钥存储的地址</span><br><span class="line">User git # git 只是ssh的一个应用，会把 User 和 HostName 拼接 </span><br><span class="line"></span><br><span class="line"># coding 账号</span><br><span class="line">Host coding</span><br><span class="line">HostName git@e.coding.net # 如果不填写User，可以直接拼接</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">UseKeychain yes</span><br><span class="line">IdentityFile ~/.ssh/coding </span><br><span class="line"></span><br><span class="line"># github_work github工作账号</span><br><span class="line">Host github-worker</span><br><span class="line">HostName github.com </span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">UseKeychain yes</span><br><span class="line">IdentityFile ~/.ssh/github_work </span><br><span class="line">User git</span><br></pre></td></tr></table></figure>

<p>为了让SSH识别新的私钥，需将其添加到SSH agent中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add -D <span class="comment"># 删除之前存储的key</span></span><br><span class="line">ssh-add -l <span class="comment"># 查看存储的key，这里应该是空的</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line">ssh-add ~/.ssh/coding</span><br></pre></td></tr></table></figure>

<h2 id="测试ssh是否设置成功"><a href="#测试ssh是否设置成功" class="headerlink" title="测试ssh是否设置成功"></a>测试ssh是否设置成功</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh -T 后面的名字可以是上面的别名</span></span><br><span class="line">$ ssh -T github</span><br><span class="line">Hi PPsteven! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">(base)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ ssh -T coding</span></span><br><span class="line"><span class="string">Coding 提示: Hello ppsteven, You'</span>ve connected to Coding.net via SSH. This is a personal key.</span><br><span class="line">ppsteven，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>



<h2 id="自动添加-秘钥-的几种方法"><a href="#自动添加-秘钥-的几种方法" class="headerlink" title="自动添加 秘钥 的几种方法"></a>自动添加 秘钥 的几种方法</h2><p><code>ssh-add</code> 这个命令是手动把私钥添加到 <code>ssh-agent</code> 所管理的 <code>session</code> 中，<strong>ssh-agent 是一个用于存储私钥的临时性的 session 服务</strong>。所以当我们重启机器的时候，<code>ssh-agent</code>  的服务也会重置。</p>
<h3 id="方案一：使用-keychain（Mac推荐）"><a href="#方案一：使用-keychain（Mac推荐）" class="headerlink" title="方案一：使用 keychain（Mac推荐）"></a>方案一：使用 keychain（Mac推荐）</h3><p>keychain 是 Mac 电脑上的钥匙串服务，作用是存储密码、秘钥，证书等信息。Win 和 Linux 也有对应的机制，没有研究。</p>
<p>首先，我们要保证 <code>config</code> 里面有这样两段代码，Mac OS 10.12.2 以上系统需要，不然的话，无法持久化的添加到钥匙串中。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># ~/.ssh/config</span><br><span class="line"></span><br><span class="line"># github 账号</span><br><span class="line">Host github  # HostName的别名,这个可以随便起</span><br><span class="line">HostName github.com # HostName: 远程仓库的域名</span><br><span class="line"><span class="addition">+ AddKeysToAgent yes # 是否把</span></span><br><span class="line"><span class="addition">+ UseKeychain yes # Mac 上秘钥被持久化到"钥匙串"中，代表从钥匙串中使用保存的秘钥</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa # 私钥存储的地址</span><br><span class="line">User git # git 只是ssh的一个应用，会把 User 和 HostName 拼接</span><br></pre></td></tr></table></figure>

<p>然后，利用 <code>ssh-add -K ~/.ssh/[your file]</code> 存储到 keychain 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -K          Store passphrases in your keychain.</span><br></pre></td></tr></table></figure>

<p>这时候，你可能在你的 <strong>钥匙串</strong> 中并没有发现成功添加，你可以利用 <code>ssh -T github/coding/..</code> 也就是上面提到的测试的方法去测一下，如何成功的话，你会发现钥匙串中多了如下信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200222181451.png" alt=""> </p>
<h3 id="方案二：添加到启动配置中去（Linux推荐）"><a href="#方案二：添加到启动配置中去（Linux推荐）" class="headerlink" title="方案二：添加到启动配置中去（Linux推荐）"></a>方案二：添加到启动配置中去（Linux推荐）</h3><p>我的 linux 上是直接把 私钥添加到 ssh-agent 中去的，尽管会失效，但是只要每次登陆的时候，都会添加一下就好，这个比较简单，适合懒人。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">&gt; Agent pid 59566</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>下一个问题，应该把这一段代码添加到哪里。这里的建议是加到 <code>.bashrc</code> 或者 <code>.bashrc_profile</code> 这两个区别是前者是每次打开新 shell 的时候运行。后者是仅在登录的时候执行一次。 </p>
<p>更多的地方参考我的另一篇教程：<code>linux 环境变量执行顺序</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="如何添加多账号"><a href="#如何添加多账号" class="headerlink" title="如何添加多账号"></a>如何添加多账号</h3><p><a href="https://segmentfault.com/a/1190000016302881" target="_blank" rel="noopener">如何设置多个Git帐号</a></p>
<p><a href="https://help.coding.net/docs/project/features/ssh.html?_ga=2.7248818.1438703294.1578809110-58920171.1578071988" target="_blank" rel="noopener">coding帮助中心</a></p>
<p>下面两个是 google 出来的解答，质量很高，建议参考</p>
<p><a href="https://www.freecodecamp.org/news/manage-multiple-github-accounts-the-ssh-way-2dadc30ccaca/" target="_blank" rel="noopener">How to manage multiple GitHub accounts on a single machine with SSH keys</a></p>
<h3 id="自动添加ssh账号"><a href="#自动添加ssh账号" class="headerlink" title="自动添加ssh账号"></a>自动添加ssh账号</h3><p><a href="https://segmentfault.com/q/1010000000835302" target="_blank" rel="noopener">是否必须每次添加ssh-add (推荐看)</a></p>
<p><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">Generating a new SSH key and adding it to the ssh-agent (github 官方推荐流程)</a></p>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令大全</title>
    <url>/2019/12/31/docker-cheetsheet/</url>
    <content><![CDATA[<p>最近在实习的过程中，需要将现有的服务上云，使用到了容器化的操作。需要自己制作Dockerfile文件，完成部署。鉴于对于docker技术的不熟练，用了几天时间好好把这个知识梳理了一下。</p>
<p>安装和基础命令详见上一篇文章  <a href="https://ppsteven.github.io/2019/11/21/Docker%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">Docker安装及基础命令</a></p>
<p>P.S. 这篇博客又切换回了next 主题，主要的原因是这篇文章中一些代码与Butterfly主题有所冲突，所以又改用兼容性比较好的hexo。今天发现原来WordPress是用php写的，作为一个php程序员肯定要搞一把，之后有时间再研究一下。</p>
<a id="more"></a>

<h2 id="docker-镜像"><a href="#docker-镜像" class="headerlink" title="docker 镜像"></a>docker 镜像</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull alpine</span><br><span class="line">$ docker pull registry.hub.docker.com/alpine:latest</span><br></pre></td></tr></table></figure>

<p>指定默认的仓库和版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_118_62_centos ~]<span class="comment"># docker pull alpine</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/alpine</span><br><span class="line">e6b0cf9c0882: Pull complete </span><br><span class="line">Digest: sha256:2171658620155679240babee0a7714f6509fae66898db422ad803b951257db78</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> alpine:latest</span><br></pre></td></tr></table></figure>

<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>

<h3 id="给镜像加tag"><a href="#给镜像加tag" class="headerlink" title="给镜像加tag"></a>给镜像加tag</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker tag alpine <span class="built_in">test</span> 起到了链接的作用</span><br></pre></td></tr></table></figure>

<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect  IMAGE <span class="comment"># 返回json 格式</span></span><br><span class="line">$ docker inspect  -f &#123;&#123; .<span class="string">"DockerVersion"</span>&#125;&#125;  IMAGE <span class="comment"># 以GO 模范返回格式化的信息</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search IMAGE # 搜索镜像</span><br><span class="line">docker search --filter=starts=4 IMAGE # 返回收藏超过4的镜像</span><br><span class="line">docker search --filter=is-official=true IMAGE # 返回官方镜像</span><br></pre></td></tr></table></figure>

<h3 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi IMAGE <span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm IMAGE <span class="comment"># 删除镜像</span></span><br><span class="line">docker image rm ubuntu:latest <span class="comment"># 删除指定tag 的镜像</span></span><br><span class="line">-f --force <span class="comment"># 强制删除</span></span><br><span class="line"></span><br><span class="line">docker image prune</span><br><span class="line">  -a, --all             Remove all unused images, not just dangling ones （临时镜像）</span><br><span class="line">      --filter filter   Provide filter values (e.g. <span class="string">'until=&lt;timestamp&gt;'</span>)</span><br><span class="line">  -f, --force           Do not prompt <span class="keyword">for</span> confirmation</span><br></pre></td></tr></table></figure>

<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><blockquote>
<p>commit import build 三个子命令</p>
</blockquote>
<h4 id="commit-基于现有容器创建"><a href="#commit-基于现有容器创建" class="headerlink" title="commit 基于现有容器创建"></a>commit 基于现有容器创建</h4><p>docker run -it alpine /bash/sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add a new file to this container </span></span><br><span class="line">[root@VM_118_62_centos ~]<span class="comment"># docker run -it alpine /bin/sh  </span></span><br><span class="line">/ <span class="comment"># touch text</span></span><br><span class="line">/ <span class="comment"># exit</span></span><br></pre></td></tr></table></figure>

<p>docker [container] commit -m “add a new file” -a “johnjhwang”  CONTAINER</p>
<blockquote>
<p>注：方括号中的 container 是可以省略不写的。这里指出是说明commit 这个命令是 容器相关的命令<br>比较建议写全，比如rm 在image 和 container 中都有，避免歧义</p>
</blockquote>
<p>-m: 表示 Comment  -a: 表示 Author<br>由于是添加了一个文件，所以镜像的 IAMGE ID 发生了变化</p>
<p>当我们查看新的镜像的时候，能看到我们后续追加的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_118_62_centos ~]# docker inspect 764a657de081</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:764a657de08117c11b3af9720efe2310386fa99074802ad13f68973081972819&quot;,</span><br><span class="line">        &quot;Parent&quot;: &quot;sha256:cc0abc535e36a7ede71978ba2bbd8159b8a5420b91f2fbc520cdf5f673640a34&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;add a  new file &quot;,</span><br><span class="line">       ......</span><br><span class="line">        &quot;Author&quot;: &quot;johnjhwang&quot;,</span><br><span class="line">       ......</span><br><span class="line">      &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="基于Dockerfile创建"><a href="#基于Dockerfile创建" class="headerlink" title="基于Dockerfile创建"></a>基于Dockerfile创建</h4><p>首先，创建一个文件Dockerfile</p>
<blockquote>
<p>文件名必须是Dockerfile</p>
</blockquote>
<p>编辑Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ununtu:latest</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">'1.0'</span> maintainer=<span class="string">'johnjhwang@tencent.com'</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp;\</span></span><br><span class="line"><span class="bash">    apt-get install -y python3 \</span></span><br><span class="line"><span class="bash">    apt-get clean</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker [image] build -t python:3 .(小数点:这是上下文环境为当前目录)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>python 是镜像名，3是版本号<br>注意，最后有一个点，代表的是上下文环境(当前目录) </p>
</blockquote>
<h4 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h4><p>// TO DO </p>
<h3 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker [image] save -o ubuntu_18.04.tar ubuntu:18.04 # 本地会出现ubuntu_18.04.tar 文件</span><br><span class="line">docker [image] load -i ubuntu_18.04.tar # 导入本地的文件，之后查看镜像库，发现出现了该镜像</span><br></pre></td></tr></table></figure>

<p>这里我们可以用更加简便的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save alpine &gt; alpine.tar</span><br><span class="line">docker load alpine &lt; alpine.tar</span><br></pre></td></tr></table></figure>

<h3 id="上传镜像-push"><a href="#上传镜像-push" class="headerlink" title="上传镜像 push"></a>上传镜像 push</h3><p>// TO DO</p>
<h2 id="docker-容器"><a href="#docker-容器" class="headerlink" title="docker 容器"></a>docker 容器</h2><h3 id="新建容器-amp-amp-启动容器"><a href="#新建容器-amp-amp-启动容器" class="headerlink" title="新建容器&amp;&amp;启动容器"></a>新建容器&amp;&amp;启动容器</h3><blockquote>
<p>create、start、run</p>
</blockquote>
<h4 id="docker-create-start"><a href="#docker-create-start" class="headerlink" title="docker create/start"></a>docker create/start</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker [container] create -it alpine <span class="comment"># 用create创建的容器处于停止状态 Created ，加-it 使用的是默认的sh</span></span><br><span class="line"></span><br><span class="line">docker [container] start CONTAINER <span class="comment"># 运行后的容器状态转为 Up</span></span><br></pre></td></tr></table></figure>

<p>查看状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_118_62_centos ~/desktop]<span class="comment"># docker start 77a32260848</span></span><br><span class="line">[root@VM_118_62_centos ~/desktop]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE  COMMAND  CREATED   STATUS   PORTS   NAMES</span><br><span class="line">77a32260848e     alpine  <span class="string">"/bin/sh"</span> 2 minutes ago  Up 5 seconds       naughty_lamport</span><br></pre></td></tr></table></figure>

<p>还有一个更加方便的启动方式，等价于 先执行create 后执行 start</p>
<h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker [container] run -it alpine /bin/sh</span><br><span class="line">-t, --tty                            Allocate a pseudo-TTY 分配一个伪终端</span><br><span class="line"> -i, --interactive                    Keep STDIN open even <span class="keyword">if</span> not attached  标准输入保持打开</span><br><span class="line"> -d, --detach                         Run container <span class="keyword">in</span> background and <span class="built_in">print</span> container ID</span><br></pre></td></tr></table></figure>

<h3 id="暂停终止容器"><a href="#暂停终止容器" class="headerlink" title="暂停终止容器"></a>暂停终止容器</h3><h4 id="暂停-恢复容器"><a href="#暂停-恢复容器" class="headerlink" title="暂停/恢复容器"></a>暂停/恢复容器</h4><blockquote>
<p>状态变为：  Up  (Paused)   </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker [container] pause/unpause CONTAINER</span><br></pre></td></tr></table></figure>

<h4 id="终止-启动容器"><a href="#终止-启动容器" class="headerlink" title="终止/启动容器"></a>终止/启动容器</h4><blockquote>
<p>stop、kill、运行结束会使容器状态变为： Exited</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker [container] stop/start CONTAINER</span><br><span class="line">   -t, --time int   Seconds to wait for stop before killing it (default 10)</span><br><span class="line"></span><br><span class="line">docker [container] kill  CONTAINER</span><br></pre></td></tr></table></figure>

<p>stop 是主动向容器发送 SIGTERM 信号，等待一段时候后，再发送SIGKILL信号来终止容器。默认10<br>kill 是直接发送SIGKILL信号去终止容器。</p>
<p>有一种情况，当容器运行结束后，状态也会变为Exited</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_118_62_centos ~]<span class="comment"># docker attach test</span></span><br><span class="line">/ <span class="comment"># ps</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /bin/sh</span><br><span class="line">    6 root      0:00 ps</span><br><span class="line">/ <span class="comment"># exit  // 退出后容器会终止</span></span><br></pre></td></tr></table></figure>

<p>可以看到容器中只有 /bin/sh 命令运行，此时使用 exit 或者 ctrl+d 退出容器，该容器会终止</p>
<h3 id="清除容器"><a href="#清除容器" class="headerlink" title="清除容器"></a>清除容器</h3><h4 id="prune"><a href="#prune" class="headerlink" title="prune"></a>prune</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container prune  <span class="comment"># Remove all stopped containers</span></span><br><span class="line">  -f, --force           Do not prompt <span class="keyword">for</span> confirmation</span><br></pre></td></tr></table></figure>

<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container rm \&lt;CONTAINER ID&gt; <span class="comment"># Remove one or more containers</span></span><br><span class="line">  -f, --force     Force the removal of a running container (uses SIGKILL)</span><br><span class="line">  -l, --link      Remove the specified link</span><br><span class="line">  -v, --volumes   Remove the volumes associated with the container</span><br></pre></td></tr></table></figure>

<h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><blockquote>
<p>先停止容器后重启容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart CONTAINER</span><br></pre></td></tr></table></figure>

<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker attach CONTAINER</span><br></pre></td></tr></table></figure>

<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><blockquote>
<p>exec 相较于 attach 的优势是可以在运行的容器内执行任意命令<br>Run a command in a running container</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it  CONTAINER /bin/sh</span><br><span class="line">  --detach-keys string   Override the key sequence <span class="keyword">for</span> detaching a container</span><br><span class="line">                        // 重载退出容器的方法,默认是ctrl+q</span><br><span class="line">  -e, --env list             Set environment variables</span><br><span class="line">  -u, --user string          Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">  -w, --workdir string       Working directory inside the container</span><br></pre></td></tr></table></figure>

<h3 id="导入-导出容器"><a href="#导入-导出容器" class="headerlink" title="导入/导出容器"></a>导入/导出容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker [container] export -o test.tar test </span><br><span class="line">docker [image] import  test.tar test01/test02:v1.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: docker export 是 container 下的方法<br>            docker import 是 image 下的方法，不要以为import 后导入到的容器库。</p>
</blockquote>
<p>可以看到 docker [image] save  和 dokcer [image] load 是一对。docker [container] export 和 docker [image] import 是一对。但是 load 和 import 同样都是导入到 镜像库，区别在什么地方?</p>
<ul>
<li><code>docker save images_name</code>：将一个镜像导出为文件，再使用<code>docker load</code>命令将文件导入为一个镜像，会保存该镜像的的所有历史记录。比<code>docker export</code>命令导出的文件大，很好理解，因为会保存镜像的所有历史记录。</li>
<li><code>docker export container_id</code>：将一个容器导出为文件，再使用<code>docker import</code>命令将容器导入成为一个新的镜像，但是相比<code>docker save</code>命令，容器文件会丢失所有元数据和历史记录，仅保存容器当时的状态，相当于虚拟机快照。</li>
</ul>
<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker [container] inspect CONTAINRER</span><br><span class="line">docker [container] top CONTAINER  # 显示docker 内运行的进程	</span><br><span class="line">docker [container] stats CONTAINER # 显示docker的状态，CPU，内存，存储，网络等实时监控</span><br></pre></td></tr></table></figure>

<h3 id="其他容器命令"><a href="#其他容器命令" class="headerlink" title="* 其他容器命令"></a>* 其他容器命令</h3><blockquote>
<p>制作Dockerfile所需掌握的命令</p>
</blockquote>
<h4 id="docker-cp-复制文件"><a href="#docker-cp-复制文件" class="headerlink" title="docker cp 复制文件"></a>docker cp 复制文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">        docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"><span class="comment"># FROM 左 TO 右</span></span><br></pre></td></tr></table></figure>

<p><code>docker [container] cp data test:/temp</code></p>
<p>这是将本地路径下的 data 复制到 test 容器的/temp 路径下，注意只是复制文件内容，不没有包含文件夹。</p>
<p><code>docker [container] cp data test:/temp/data</code></p>
<p>这样才是把data文件夹移到了目标容器的文件夹下</p>
<h3 id="docker-container-命令大全"><a href="#docker-container-命令大全" class="headerlink" title="docker container 命令大全"></a>docker container 命令大全</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">commit      Create a new image from a container&apos;s changes</span><br><span class="line">cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">create      Create a new container</span><br><span class="line">diff        Inspect changes to files or directories on a container&apos;s filesystem</span><br><span class="line">exec        Run a command in a running container</span><br><span class="line">export      Export a container&apos;s filesystem as a tar archive</span><br><span class="line">inspect     Display detailed information on one or more containers</span><br><span class="line">kill        Kill one or more running containers</span><br><span class="line">logs        Fetch the logs of a container</span><br><span class="line">ls          List containers</span><br><span class="line">pause       Pause all processes within one or more containers</span><br><span class="line">port        List port mappings or a specific mapping for the container</span><br><span class="line">prune       Remove all stopped containers</span><br><span class="line">rename      Rename a container</span><br><span class="line">restart     Restart one or more containers</span><br><span class="line">rm          Remove one or more containers</span><br><span class="line">run         Run a command in a new container</span><br><span class="line">start       Start one or more stopped containers</span><br><span class="line">stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">stop        Stop one or more running containers</span><br><span class="line">top         Display the running processes of a container</span><br><span class="line">unpause     Unpause all processes within one or more containers</span><br><span class="line">update      Update configuration of one or more containers</span><br><span class="line">wait        Block until one or more containers stop, then print their exit codes</span><br></pre></td></tr></table></figure>



<h2 id="docker-容器卷"><a href="#docker-容器卷" class="headerlink" title="docker 容器卷"></a>docker 容器卷</h2><p>本章不再详述命令细节，只关注于常用命令</p>
<p>容器中对数据进行持久化的操作，需要借助数据管理操作。</p>
<p>一般有两种管理方式:</p>
<ul>
<li>Data Volumes</li>
<li>Data Volume Containers</li>
</ul>
<h3 id="数据卷-Data-Volumes"><a href="#数据卷-Data-Volumes" class="headerlink" title="数据卷(Data Volumes)"></a>数据卷(Data Volumes)</h3><p>创建一个本地数据卷</p>
<p>docker volume create -d local –name haha</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-d, --driver string   Specify volume driver name (default <span class="string">"local"</span>) </span><br><span class="line">--name 重命名</span><br></pre></td></tr></table></figure>

<p>docker volumn create 创建完成的数据卷是在 /var/lib/docker/volumes 下的，可以通过 ls （查看） inspect(详细信息) prune 和 rm 去做进一步的操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               haha</span><br></pre></td></tr></table></figure>

<p>这里mac需要注意，因为在mac上用docker会在mac上启动一个虚拟机运行docker，因此volume创建的directory并不在你的machine上，而是在虚拟机中。</p>
<h4 id="mac用户如何查看数据卷地址"><a href="#mac用户如何查看数据卷地址" class="headerlink" title="mac用户如何查看数据卷地址"></a>mac用户如何查看数据卷地址</h4><p>如何进入mac上的虚拟机的办法请参考:<a href="https://www.jianshu.com/p/1baeabdd0e27" target="_blank" rel="noopener">这篇教程</a></p>
<p>具体的做法是执行：<code>screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty</code></p>
<p>然后查看<code>/var/lib/docker/volumes</code>里面的容器</p>
<h4 id="数据卷的类型"><a href="#数据卷的类型" class="headerlink" title="数据卷的类型"></a>数据卷的类型</h4><ul>
<li>volume : 普通数据卷，映射到 /var/lib/docker/volumes下</li>
<li>bind: 绑定数据卷，是自己制定的目录</li>
<li>tmpfs: 临时数据卷，只存在于内存中，目前没有使用过</li>
</ul>
<p>docker run -d –name test –mount type=bind,source=/mydata,destination=/opt/mydata CONTAINER COMMAND</p>
<p>这句话是绑定当前目录下的mydata文件夹至docker容器下的/opt/mydata文件夹</p>
<p>还有一个简洁的方式 -v</p>
<p>docker run -d –name test -v /mydata:/opt/mydata CONTAINER COMMAND</p>
<h3 id="数据容器-Data-Volume-Containers"><a href="#数据容器-Data-Volume-Containers" class="headerlink" title="数据容器(Data Volume Containers)"></a>数据容器(Data Volume Containers)</h3><p>创建一个数据卷容器，起别名 dbtest，并挂载 <code>~/Desktop/dbfile</code> 到当前容器</p>
<p>docker run -it –name dbtest -v ~/Desktop/dbfile:/dbfile alpine:latest</p>
<p>然后，可以在其他容器中使用 –volumes-from 挂载dbtest 中的数据卷</p>
<p>docker run -it –name db1 –volumes-from dbtest alpine<br>docker run -it –name db2 –volumes-from dbtest alpine</p>
<h3 id="数据卷高级用法：迁移数据"><a href="#数据卷高级用法：迁移数据" class="headerlink" title="数据卷高级用法：迁移数据"></a>数据卷高级用法：迁移数据</h3><p>数据的迁移有两步构成：备份+迁移</p>
<p>首先我们使用了上面建立好的 dbtest 数据卷容器，该容器和 ~/Desktop/dbfile 绑定，其中包含了我们需要保存的重要的数据。</p>
<p><strong>备份</strong></p>
<p>docker run –volumes-from dbtest -v $(pwd):/backup –name worker alpine tar cvf /backup/backup.tar /dbfile</p>
<p>这里我们把绑定的本地和容器内的/backup绑定，所以我们用压缩方法，把dbfile 内的数据打包放入了/backup文件夹中，直观的来说，在当前目录下会看到backup.tar 文件。</p>
<p><strong>迁移</strong></p>
<p>先创建一个新的数据卷容器dbtest2 </p>
<p>docker run -v  ~/Desktop/dbfile2:/dbfile –name dbtest2  alpine</p>
<p>创建新容器，挂载dbtest2的容器，并使用untar解压放在/backup/backup.tar 文件</p>
<p>docker run –volumes-from dbtest2 -v $(pwd):/backup –name worker2 ubuntu tar xvf  /backup/backup.tar </p>
<p>docker </p>
<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>启动一个web服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -P straining/webapp python app.py  // 随机映射端口，49000~49900到容器内部端口</span><br><span class="line">docker run -d -p 5000:5000 training/webapp python app.py// HostPort:ContainerPort</span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py// IP:HostPort:ContainerPort</span><br><span class="line">docker run -d -p 127.0.0.1::5000 training/webapp python app.py // 自动分配一个端口</span><br><span class="line">docker run -d -p 127.0.0.1::5000/udp training/webapp python app.py // 制定UDP</span><br></pre></td></tr></table></figure>

<p>稍后我们可以看到映射结果（下面是举例）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:32768-&gt;5000/tcp </span><br><span class="line">0.0.0.0:3306-&gt;3306/tcp</span><br><span class="line">127.0.0.1:32768-&gt;5000/udp</span><br></pre></td></tr></table></figure>

<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>–link name:alias<br>name:连接的容器 alias 容器的别名</p>
<p>容器间的互联是一个比较重要的知识点，后续会写一篇博客完善</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/Cherry-Linux/p/8025777.html" target="_blank" rel="noopener">docker load与docker import</a></p>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>日常学习笔记</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo进阶:博客转载文章设置</title>
    <url>/2019/12/22/Hexo%E8%BF%9B%E9%98%B6:%E5%8D%9A%E5%AE%A2%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>遇见好的博客文章怎么办：1. 打上书签，让它永远的留在你的书签夹中。2. 在博客中转载<br>在博客中转载的目的是把一些 工具类的网站，快捷键的整理记录下来。但是Hexo是用Markdown编写的，没有博客转载的功能，这时候我们就需要借助 HTML 的 iframe 去实现我们的功能了。<br>这一部分知识属于前端的范畴了，也算是对于知识面的一个补充。</p>
<a id="more"></a>

<h2 id="Same-Domain-amp-amp-Cross-Domain"><a href="#Same-Domain-amp-amp-Cross-Domain" class="headerlink" title="Same-Domain &amp;&amp; Cross-Domain"></a>Same-Domain &amp;&amp; Cross-Domain</h2><p>我们的需求是在用 iframe 引用别人的网站的时候，需要根据这个网站的大小自动调节我们网站的大小。但是因为chrome 的安全限制，我们是无法直接获取别的网站的大小的。</p>
<blockquote>
<p>&lt;iframe&gt;’s which display content from different domains have security measures in place to prevent all sorts of stuff. For example, you can’t have JavaScript access anything inside it. It can be very frustrating, for example, if you just want to do something normal and white-hat like adjust the height of the iframe to fit the content inside it. These security measures are in place to prevent all the black-hat kind of things you could do if you did have JavaScript access to the innards of an iframe.</p>
</blockquote>
<p>简言之，就是游览器会阻止JavaScript 去做一些高危操作，如果是不一样的domian 的话，获取网站内部信息的行为就会被认为是危险的。</p>
<h2 id="Same-Domian"><a href="#Same-Domian" class="headerlink" title="Same-Domian"></a>Same-Domian</h2><p>Same-Domain 的解决方法非常多，可以说，百度上搜到的大部分方法都是针对这一情况的。</p>
<p>我们直接附上代码 &amp;&amp; 实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  iframe &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    min-width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">resizeIframe</span><span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    obj.style.height = obj.contentWindow.document.documentElement.scrollHeight + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="actionscript">    obj.style.width = obj.contentWindow.document.documentElement.scrollWidth + <span class="string">'px'</span>;</span></span><br><span class="line">    alert(obj.style.height);</span><br><span class="line">    alert(obj.style.width);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://ppsteven.github.io/about/"</span></span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">onload</span>=<span class="string">"resizeIframe(this)"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">id</span> = <span class="string">"myiframe"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是实例，这里未了方便展示，我们直接限制了Height最大为400</p>
<style>
  iframe {
    width: 100px;
    min-width: 100%;
  }
</style>
<script type="text/javascript">
  function resizeIframe(obj) {
    obj.style.width = obj.contentWindow.document.documentElement.scrollWidth + 'px';
    var height = obj.contentWindow.document.documentElement.scrollHeight;
    if (height > 400) height = 400;
    obj.style.height = height + 'px';
    //alert(obj.style.height); //提示大小
    //alert(obj.style.width);
  }
</script>
<iframe src="https://ppsteven.github.io/about/"
frameborder="0" scrolling="no" onload="resizeIframe(this)" 
id = "myiframe"
></iframe>

<h2 id="Cross-domain"><a href="#Cross-domain" class="headerlink" title="Cross domain"></a>Cross domain</h2><h3 id="手动定义Size"><a href="#手动定义Size" class="headerlink" title="手动定义Size"></a>手动定义Size</h3><p>我们尝试使用上面Same-domain 的代码去获取百度的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://www.baidu.com&quot;</span><br><span class="line">frameborder=&quot;0&quot; scrolling=&quot;no&quot; onload=&quot;resizeIframe(this)&quot; </span><br><span class="line">id = &quot;abc&quot;</span><br><span class="line">&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p>最终我们会得到 游览器 Block 的 警告</p>
<blockquote>
<p>这个警告的页面是 在 Chrome 开发者工具的Console 中获得的，以后我们需要多次借助这个工具</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught DOMException: Blocked a frame with origin &quot;http://localhost:4000&quot; from accessing a cross-origin frame.</span><br><span class="line">    at resizeIframe (http://localhost:4000/2019/12/21/test/:32:42)</span><br><span class="line">    at HTMLIFrameElement.onload (http://localhost:4000/2019/12/21/test/:39:2)</span><br></pre></td></tr></table></figure>

<p>其实最重要的问题就是获取 页面的大小，这个过程如果不让游览器自己去完成的话，我们人手工也可以完成，只是费劲一点（当然和写一篇博客比，这个过程可能只花费不到一分钟）</p>
<p>只要在Console 中输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.scrollHeight</span><br><span class="line"><span class="built_in">document</span>.body.scrollWidth</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191222155701.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://www.laruence.com/2015/05/28/3038.html"</span></span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">"855px"</span></span></span><br><span class="line"><span class="tag"><span class="attr">highth</span>=<span class="string">"26012px"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Autozise"><a href="#Autozise" class="headerlink" title="Autozise"></a>Autozise</h3><p>第二种方法就是利用postMessage 的方式，这一种方法我也亲自用过了，但是繁琐程度比较高。</p>
<p>需要在 Host.html 和 Frame.html 中都需要插入Js 代码</p>
<p>Host.html 就是 <code>&lt;iframe&gt;</code> 所在html，负责接受 Frame.html 传递过来的参数</p>
<p>Frame.html 也可以看做 source web 的网站，负责 传送数据。</p>
<p>这要求我们主动的去修改目标的html 代码，从中插入Js，这样的话，感觉不是很便捷，而且Js 代码也过于负责，目前不想整理这一块的内容。</p>
<blockquote>
<p>具体操作请移步 参考资料 2</p>
</blockquote>
<h2 id="静态文本"><a href="#静态文本" class="headerlink" title="静态文本"></a>静态文本</h2><p>这一段是后加的, 我们可以直接存储html 格式的文件，然后在头部加上yaml 格式即可完成和markdown一样的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://css-tricks.com/cross-domain-iframe-resizing/" target="_blank" rel="noopener">Cross Domain iframe Resizing</a><br>这篇文章算是国外教程中整理的相当不错的文章了，介绍了在 same-domain 和 cross-domian 两种情况下的应对方式。</p>
</li>
<li><p><a href="http://geekswithblogs.net/rashid/archive/2007/01/13/103518.aspx" target="_blank" rel="noopener">http://geekswithblogs.net/rashid/archive/2007/01/13/103518.aspx</a><br>第一篇的教程就是参考这一篇文章的代码，原创级别</p>
</li>
</ol>
]]></content>
      <categories>
        <category>电脑基本配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP+phpstorm+xdebug 环境配置</title>
    <url>/2019/12/14/PHP+phpstorm+xdebug%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>php 环境搭建是一件相当麻烦的事情，本篇博客记录了在Mac 系统下的环境配置。</p>
<p>Win上的php 环境搭建，建议使用XAMPP，一键搭建，而且自带xdebug.dll，用过就知道。Mac 上的php 环境，我一开始也使用了 XAMPP 作为环境，但是发现Mac 上的是阉割版的，也没有xdebug。</p>
<p>目前介绍的环境搭建方法是: <strong>brew</strong> 和 <strong>pecl</strong> </p>
<a id="more"></a>

<h2 id="PHP-安装"><a href="#PHP-安装" class="headerlink" title="PHP 安装"></a>PHP 安装</h2><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>Mac 上是自带php和Apache的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whereis php</span><br><span class="line">/usr/bin/php</span><br></pre></td></tr></table></figure>

<p>我这里准备用brew 装一个最新的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew search php</span><br><span class="line">==&gt; Formulae</span><br><span class="line">brew-php-switcher      php@7.2                phpmyadmin</span><br><span class="line">php                    php@7.3 ✔              phpstan</span><br><span class="line">php-code-sniffer       phplint                phpunit</span><br><span class="line">php-cs-fixer           phpmd</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">eclipse-php            netbeans-php           phpstorm</span><br><span class="line">(base)</span><br></pre></td></tr></table></figure>

<p>安装最新的 php 7.3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install php@7.3</span><br><span class="line"><span class="comment"># 安装后，我们需要添加环境变量</span></span><br><span class="line">php@7.3 is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have php@7.3 first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/php@7.3/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/php@7.3/sbin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find php@7.3 you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-L/usr/local/opt/php@7.3/lib"</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">"-I/usr/local/opt/php@7.3/include"</span></span><br><span class="line"></span><br><span class="line">To have launchd start php@7.3 now and restart at login:</span><br><span class="line">  brew services start php@7.3</span><br><span class="line">Or, <span class="keyword">if</span> you don<span class="string">'t want/need a background service you can just run:</span></span><br><span class="line"><span class="string">  php-fpm</span></span><br></pre></td></tr></table></figure>

<h3 id="brew-安装遇到的问题"><a href="#brew-安装遇到的问题" class="headerlink" title="brew 安装遇到的问题"></a>brew 安装遇到的问题</h3><p>brew 安装<a href="mailto:php@7.3" target="_blank" rel="noopener">php@7.3</a> 的过程中，中间一条命令是 brew clean 产生了问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cleanup</span><br><span class="line">Warning: Skipping opam: most recent version 2.0.3 not installed</span><br><span class="line">Warning: Skipping python: most recent version 3.7.2_2 not installed</span><br><span class="line">Warning: Skipping sqlite: most recent version 3.27.1 not installed</span><br><span class="line">Error: Permission denied @ unlink_internal - /usr/<span class="built_in">local</span>/lib/node_modules/@angular/cli/node_modules/.bin/<span class="keyword">in</span>-install</span><br></pre></td></tr></table></figure>

<p>既然说我们权限不够，第一反应是使用 <code>sudo</code> 命令，但是brew 不允许用户这么做。</p>
<p>经过查询后，可以使用如下命令，可以给没有权限的文件夹，更改权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R <span class="string">"<span class="variable">$(whoami)</span>"</span>:admin /usr/<span class="built_in">local</span> <span class="comment"># 这里文件夹填写需要的</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-xdebug"><a href="#安装-xdebug" class="headerlink" title="安装 xdebug"></a>安装 xdebug</h2><p>xdebug 的安装是比较麻烦的，若是没有xdebug 需要的步骤复制很多。涉及到自己编译（自己编译的话，由于计算机环境不同又会产生很多问题）</p>
<h3 id="XAMPP-环境的安装"><a href="#XAMPP-环境的安装" class="headerlink" title="XAMPP 环境的安装"></a>XAMPP 环境的安装</h3><p>这里XAMPP环境的话我建议参考下面的教程</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/d60ad942aa88" target="_blank" rel="noopener">Mac下XAMPP+PhpStorm中集成xdebug</a></p>
</blockquote>
<p>简单的描述一下过程就是：</p>
<ol>
<li>生成 phpinfo ，复制到 xdebug 官网<a href="https://link.jianshu.com/?t=https://xdebug.org/wizard.php" target="_blank" rel="noopener">官网下载xdebug.so</a> 下载xdebug.tgz</li>
<li>解压文件: <code>tar -xvzf xdebug.tgz</code></li>
<li>编译过程官方教程(有坑)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215000634.png" alt=""></p>
<ol start="4">
<li><blockquote>
<p>坑一：使用对phpize 命令。如果你电脑中安装的是XAMPP环境，你需要使用XAMPP环境的phpize</p>
</blockquote>
<p><code>/Applications/XAMPP/xamppfiles/bin/phpize</code></p>
<blockquote>
<p>坑二：出现<code>Cannot find autoconf</code> 错误 </p>
</blockquote>
<p><code>brew install autoconf</code></p>
<blockquote>
<p>坑三：./configure 编译问题</p>
</blockquote>
<p><code>./configure --with-php-config=/Applications/XAMPP/xamppfiles/bin/php-config</code></p>
</li>
<li><p>make 获得 xdebug.so 文件</p>
</li>
</ol>
<h3 id="Pecl-方法安装（采用的方法）"><a href="#Pecl-方法安装（采用的方法）" class="headerlink" title="Pecl 方法安装（采用的方法）"></a>Pecl 方法安装（采用的方法）</h3><p>我们使用的较为简单的方法，就是使用pecl命令，如果我们成功的安装了 php 的话，pecl 是自带的。pecl 相当于为我们省去了编译的过程，也帮我们避免了很多的坑</p>
<p>pecl 之于 php 相当于 pip 之于 python 和 npm 之于 node.js，管理的是 php 的扩展(或者叫插件？)</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215001759.png" alt=""></p>
<h3 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h3><p>找到php.ini 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php --ini</span><br><span class="line">Configuration File (php.ini) Path: /usr/<span class="built_in">local</span>/etc/php/7.3</span><br><span class="line">Loaded Configuration File:         /usr/<span class="built_in">local</span>/etc/php/7.3/php.ini</span><br><span class="line">Scan <span class="keyword">for</span> additional .ini files <span class="keyword">in</span>: /usr/<span class="built_in">local</span>/etc/php/7.3/conf.d</span><br><span class="line">Additional .ini files parsed:      /usr/<span class="built_in">local</span>/etc/php/7.3/conf.d/ext-opcache.ini</span><br></pre></td></tr></table></figure>

<p>添加如下代码</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[xdebug]</span></span><br><span class="line"><span class="attr">zend_extension</span>=/Applications/XAMPP/xamppfiles/lib/php/extensions/<span class="literal">no</span>-debug-non-zts-<span class="number">20160303</span>/xdebug.so <span class="comment"># xdebug 存放路径</span></span><br><span class="line"><span class="attr">xdebug.remote_autostart</span>=<span class="literal">on</span></span><br><span class="line"><span class="attr">xdebug.remote_enable</span>=<span class="literal">on</span></span><br><span class="line"><span class="attr">xdebug.remote_mode</span>=<span class="string">"req"</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=localhost</span><br><span class="line"><span class="attr">xdebug.remote_port</span>=<span class="number">9000</span> <span class="comment"># 端口号，记住</span></span><br><span class="line"><span class="attr">xdebug.remote_handler</span>=<span class="string">"dbgp"</span></span><br><span class="line"><span class="attr">xdebug.idekey</span>=<span class="string">"PhpStorm"</span></span><br><span class="line"><span class="attr">xdebug.profiler_enable</span> = <span class="literal">Off</span></span><br></pre></td></tr></table></figure>

<p>查看xdebug 是否成功安装，使用 <code>php -m</code>  查看所有已安装的扩展，存在xdebug 则表明安装成功。当然也可以使用 <code>phpinfo()</code> 查看xdebug。</p>
<blockquote>
<p>注意: 重启Apache 服务才能看到 phpinfo 输出的情况</p>
</blockquote>
<h2 id="配置phpstorm-环境"><a href="#配置phpstorm-环境" class="headerlink" title="配置phpstorm 环境"></a>配置phpstorm 环境</h2><p>xdebug 在phpstorm 中的设置，有大量图，不想重复造轮子。看下面两个教程足够了。</p>
<p><a href="https://blog.csdn.net/u012338816/article/details/52243785" target="_blank" rel="noopener">史上最佳 Mac+PhpStorm+XAMPP+Xdebug 集成开发和断点调试环境的配置</a></p>
<p><a href="https://www.jianshu.com/p/d60ad942aa88" target="_blank" rel="noopener">Mac下XAMPP+PhpStorm中集成xdebug</a></p>
<p>实践下来，由于我只是作为php 后端开发，不需要与前端交互的话，我这里只需要保证下面的端口设置正确即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215013247.png" alt=""></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>真实工作环境中，其实由于项目是很大的，实际上没有用到xdebug的机会（主要通过日志排查问题）。我这里安装xdebug 主要是想要通过逐步调试的过程，更好的理解php 语言，协程的使用方法等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xdebug.org/docs/install#1" target="_blank" rel="noopener">xdebug 官方安装教程</a></p>
<p><a href="https://stackoverflow.com/questions/54682876/brew-cleanup-error-permission-denied-unlink-internal" target="_blank" rel="noopener">brew cleanup 问题解决方法–stackoverflow</a> </p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php环境配置</tag>
        <tag>phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>php协程笔记</title>
    <url>/2019/12/07/php%E5%8D%8F%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实习的过程中使用到了腾讯微服务平台（Tencent Service Framework，TSF）框架，tsf中经常看到 </p>
<p><code>$ret = (yield func(a,b));</code></p>
<p>这样的用法。<br>yield 外面包括号的用法并不常见，实际上这是yield的一种特殊的用法——<strong><em>协程</em></strong>。<br>这里我准备通读一下这一领域的经典教程，好好理解yield 和 协程 是如何在PHP 项目开发中起到作用的。</p>
<blockquote>
<p><a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="noopener">在PHP中使用协程实现多任务调度| 风雪之隅</a></p>
<p>作者背景：风雪之隅，PHP开发组核心成员，鸟叔，PHP7的主要开发者。本篇文章其实他对一篇英文教程的翻译之作。</p>
</blockquote>
<p>之所以标题起笔记，原因是原文理解起来稍有难度，所以我这里加上自己的理解。本篇可以在大家读原文的过程中做一个参考。</p>
<a id="more"></a>


<h2 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进程是程序执行的一个实例</p>
</li>
<li><p>进程是资源分配的最小单位，资源包括：CPU，内存，I/O等</p>
</li>
<li><p>进程间的通讯方式（IPC） &lt;—- 抄，参考<a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/82951084</a></p>
<ul>
<li>管道 Pipe</li>
<li>命名管道 FIFO</li>
<li>* 消息队列（Message Queue)<ul>
<li>腾讯的hippo</li>
<li>Kafka</li>
</ul>
</li>
<li>信号量（Semaphore）</li>
<li>共享内存（Shared Memory）</li>
<li>* 套接字（Socket）</li>
</ul>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><strong>轻量级进程(Lightweight Process，LWP）</strong></li>
<li>CPU调度的最小单位</li>
<li>进程由于是拥有系统资源，所以切换时需要保存上下文环境，开销大。线程开销小</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>协程是一种比线程更加轻量级的存在</li>
<li>与进程线程不同的是，协程是完全由程序控制在（用户态执行）</li>
<li>举例： 当我们读文件的时候，我们可以主动让出控制权，而不是等待I/O操作完成。</li>
<li>特点<ul>
<li>极高的执行效率，没有线程那么大的切换开销。<br>我们知道涉及到内核参与管理的程序，需要从用户态通过中断的方式切换到内核态。这样的开销是极大的。</li>
<li>不需要多线程的锁机制，<strong>在协程中控制共享资源不加锁</strong></li>
<li>对用户可见</li>
<li>协同，因为是由程序员自己写的调度策略，其通过协作而不是抢占来进行切换</li>
<li><strong>协程的思想本质上就是控制流的主动让出（yield）和恢复（resume）机制</strong>（来源：<a href="https://segmentfault.com/a/1190000012457145" target="_blank" rel="noopener">PHP7下的协程实现</a>）</li>
</ul>
</li>
</ul>
<h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><p>迭代生成器是我们对于 yield 最常用的一个功能。<br>用 yield 替代 return 作为函数的返回最大的作用是，它返回的不仅是一个值，而是一个迭代器。这一优点在面对无法载入到内存的大型数据集有很大的作用。</p>
<p>如以下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start,$end,$step = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ($i = $start ; $i &lt;= $end ; $i += $step)&#123;</span><br><span class="line">		<span class="keyword">yield</span> $i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (xrange(<span class="number">1</span>,<span class="number">10000000000</span>) <span class="keyword">as</span> $num) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $num .<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这里使用return的话，返回的是一个非常大的数组，当你数据量特别大的时候会造成数据溢出的问题。<br>yield 的神奇之处在于，它会保持生成器的状态。函数会一直运行，直到下一个yield。程序执行的控制流可以在主代码和生成器函数之间切换，也不用用户担心上下文环境的问题。<br>优点</p>
<ul>
<li>运行大型数据集</li>
<li>不用编写就能生成复杂的生成器</li>
</ul>
<p>写一个生成器的流程，需要</p>
<ul>
<li>被迭代的类实现 IteratorAggregate <strong>接口</strong></li>
<li>定义一个返回迭代类的方法，这个类必须实现Iterator <strong>接口</strong></li>
<li>提供一系列必须实现的方法<ul>
<li>rewind : 函数内部指针设置回到数据开始处</li>
<li>valid : 判读是否还有数据</li>
<li>key : 返回数据指针值</li>
<li>current : 返回当前指针指向的值</li>
<li>next : 移动到下一位<br>yield 关键字简化了实现迭代器的过程。</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> TODO 实现一个PHP Iterator 对象</li>
</ul>
<h2 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h2><p>yield 的一个特性是函数每次执行到yield 的时候，就会主动让出控制权。这一点可以很好的帮助我们控制程序的执行顺序。</p>
<h3 id="send-函数"><a href="#send-函数" class="headerlink" title="send 函数"></a>send 函数</h3><p>public Generator::send ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>$value</code> ) : <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a></p>
<p>向生成器中传入一个值，并且当做 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 表达式的结果。</p>
<p><strong><em>然后继续执行生成器</em></strong>。</p>
<p>如果当这个方法被调用时，生成器不在 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 表达式，那么在传入值之前，它会先运行到第一个 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 表达式。传入生成器的值。这个值将会被作为生成器当前所在的 <a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a> 的返回值。</p>
<blockquote>
<p>利用send 函数，我们可以很方便的与协程进行交互，具体如下。</p>
</blockquote>
<h3 id="yield-作为参数接受者"><a href="#yield-作为参数接受者" class="headerlink" title="yield 作为参数接受者"></a>yield 作为参数接受者</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">($fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"这个语句只会执行一次"</span>,<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">yield</span> . <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">//函数每次都会执行要yield 暂停，然后让出控制权。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$logger = logger(<span class="keyword">__DIR__</span> . <span class="string">'/log'</span>);</span><br><span class="line">$logger-&gt;send(<span class="string">'Foo'</span>);  <span class="comment">// 输出 "这个语句只会执行一次", 输出 Foo \n;</span></span><br><span class="line">$logger-&gt;send(<span class="string">'Bar'</span>);  <span class="comment">// 输出 Bar \n;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>yield 作用：</p>
<ul>
<li><ol>
<li>类似于debug 时候的断点，每一次都是运行到 yield 停止</li>
</ol>
</li>
<li><ol start="2">
<li>可以利用send方法给 yield 传递数据</li>
</ol>
</li>
</ul>
<blockquote>
<p>那自然会有一个疑问，此处的 yield 有没有接受数据回来？<br>经过试验，发现此处的yield 是没有返回数据的。</p>
</blockquote>
<p>这个例子可以看到yield 并没有返回数据，是NULL</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">($fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"这个语句只会执行一次"</span>,<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">yield</span> . <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">//函数每次都会执行要yield 暂停，然后让出控制权。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$logger = logger(<span class="keyword">__DIR__</span> . <span class="string">'/log'</span>);</span><br><span class="line">$a = $logger-&gt;send(<span class="string">'Foo'</span>);  <span class="comment">// 输出 "这个语句只会执行一次", 输出 Foo;</span></span><br><span class="line">var_dump($a); <span class="comment">// 返回 NULL , 这里的yield 并没有返回任何值</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="yield-同时接受和发送数据"><a href="#yield-同时接受和发送数据" class="headerlink" title="yield 同时接受和发送数据"></a>yield 同时接受和发送数据</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$gen = gen();</span><br><span class="line">var_dump($gen-&gt;current());    <span class="comment">// string(6) "yield1"</span></span><br><span class="line">var_dump($gen-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1"   (the first var_dump in gen)</span></span><br><span class="line">                              <span class="comment">// string(6) "yield2" (the var_dump of the -&gt;send() return value)</span></span><br><span class="line">var_dump($gen-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2"   (again from within gen)</span></span><br><span class="line">                              <span class="comment">// NULL               (the return value of -&gt;send())</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>逐句分析</p>
<p>$ gen = gen() 指针指向这个迭代器</p>
<p>$ gen-&gt; current() 运行到第一个yield ，返回 yield 语句的值 yield，并 输出 类型和值</p>
<p>$ gen -&gt;send(“ret1”)  当前生成器在 yield 语句，于是把 “ret1” 当做 （yield “yield1”）的结果，并赋值给 $ret1。而且还会执行一个 gen-&gt;next() 移到下一个yield 处，返回第二个yield 语句的返回值</p>
<p>$ gen -&gt;send(“ret2”)  当前生成器在第二个yield 语句，把”ret2” 当做   (yield “yield2”) 的结果，并赋值给 $ret2 。继续向下执行，此时指针会移至迭代器末尾，此时已经没有yield ，所以返回NULL</p>
<h3 id="多任务合作"><a href="#多任务合作" class="headerlink" title="多任务合作"></a>多任务合作</h3><p>为了帮助理解 协程和任务调度的关机，yield 在 任务运行的过程中可以主动中断自身，并把控制权交还给调度器。</p>
<p>这里我们先需要实现: 任务、调度器</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123; <span class="comment">//实现一个任务</span></span><br><span class="line">    <span class="keyword">protected</span> $taskId; <span class="comment">//任务ID</span></span><br><span class="line">    <span class="keyword">protected</span> $coroutine;<span class="comment">//协程</span></span><br><span class="line">    <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;<span class="comment">//send 传送的value</span></span><br><span class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;<span class="comment">//是不是第一次传送</span></span><br><span class="line">    <span class="comment">// 因为每次send 返回的值，都是当前yield 的下一个yield 的返回值，这导致了第一个yield 的返回值被丢弃了。对于第一个 yield，我们需要用current()获取返回值，从第二个往后用send()获取返回值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;<span class="comment">//协程类型是 迭代器</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;<span class="comment">// 如果是第一次yield，那么就用current()返回</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是第一个yield，就用send设置一个value，并返回下一个yield的值</span></span><br><span class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;<span class="comment">//设置完毕清空value</span></span><br><span class="line">            <span class="keyword">return</span> $retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();<span class="comment">// 判断迭代器是否迭代完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;<span class="comment">//实现一个调度器</span></span><br><span class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>; <span class="comment">// 最大任务</span></span><br><span class="line">    <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></span><br><span class="line">    <span class="keyword">protected</span> $taskQueue;<span class="comment">// 任务队列</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue(); <span class="comment">// 实例化一个队列</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</span><br><span class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;<span class="comment">// 生成任务id</span></span><br><span class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine); <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;<span class="comment">// 标识 taskId =&gt; task</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">        <span class="keyword">return</span> $tid;</span><br><span class="line">    &#125;</span><br><span class="line"> 		</span><br><span class="line">    <span class="comment">//任务入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</span><br><span class="line">            $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();<span class="comment">// 出队</span></span><br><span class="line">            $task-&gt;run(); <span class="comment">//任务运行</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123; <span class="comment">//当前任务结束，删除</span></span><br><span class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;schedule($task);<span class="comment">//未完成的话，放入队尾继续执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>用一个例子看看程序是否按照我们的期望在运行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>); <span class="comment">// 载入定义好的模块</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"Scheduler.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;<span class="comment">// 程序运行10次</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;<span class="comment">// 程序运行5次</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">5</span>; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task 2 iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;newTask(task1());</span><br><span class="line">$scheduler-&gt;newTask(task2());</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"></span><br><span class="line">结果如下:</span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">1.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">1.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">2.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">2.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">3.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">3.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">4.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">4.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">5.</span></span><br><span class="line">This is task <span class="number">2</span> iteration <span class="number">5.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">6.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">7.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">8.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">9.</span></span><br><span class="line">This is task <span class="number">1</span> iteration <span class="number">10.</span></span><br></pre></td></tr></table></figure>

<p>发现程序是交替运行的，和我们的预期是相同的。因为我们使用了队列的结构，若是一个任务从队列中取出后并没有运行结束，我们会放入队尾继续运行。</p>
<h4 id="与调度器之间的通信"><a href="#与调度器之间的通信" class="headerlink" title="与调度器之间的通信"></a>与调度器之间的通信</h4><p>我们再看一眼，上面例子中需要运行的程序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;<span class="comment">// 程序运行10次</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>; <span class="comment">// &lt;-- 若是要在用调度器中的taskid 替代此句需要怎么做。</span></span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实现：任务与调度器之间的通信。</p>
<p>我们使用的是 进程用来和操作系统会话的同样的方式来通信：系统调用。</p>
<p>要注意的是，不能简单的把调度器作为一个参数，传递给任务，不然很危险。这里作者通过yield表达式，配合send 来传递信息。</p>
<p>首先是对可调用的系统调用做一个封装</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $callback;</span><br><span class="line">    <span class="comment">// 传入的值是 一个可调用的类/函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(callable $callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;callback = $callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __invoke:当类发生调用的使用使用</span></span><br><span class="line">    <span class="comment">// 这样，类在使用的时候看上去和一个函数一样</span></span><br><span class="line">    <span class="comment">// 传入的参数是 任务 和 调度器</span></span><br><span class="line">    <span class="comment">// 作用是运行 初始化的函数/类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $callback = <span class="keyword">$this</span>-&gt;callback;</span><br><span class="line">        <span class="keyword">return</span> $callback($task, $scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面我们需要进行消息通讯</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">($max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们需要传入 $tid 的值 从调度器中</span></span><br><span class="line">    $tid = (<span class="keyword">yield</span> getTaskId()); <span class="comment">// &lt;-- here's the syscall!</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task $tid iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line"> </span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">10</span>));</span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，我们需要对传入的getTaskId 进行修改</p>
<p>传入的值是来自与调度器和任务的，结合之前的封装的系统调用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(<span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $task-&gt;setSendValue($task-&gt;getTaskId());</span><br><span class="line">        $scheduler-&gt;schedule($task);</span><br><span class="line">        <span class="comment">// 这里返回的是一个系统调用</span></span><br><span class="line">        <span class="comment">// 作用是给任务设置 send 的值，send值的内容是 taskid</span></span><br><span class="line">        <span class="comment">// 把此任务加入调度器的队列中去</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里return 的不是如函数名写的 taskid，而是一个系统调用。</p>
<p>最后程序中的 $tid = (yield getTaskId()); 又会把这个系统调用传入调度器的队列中</p>
</blockquote>
<p>进过这样的操作，我们调度器的队列中有两种类型的任务</p>
<ul>
<li>SystemCall类型，但是它也可以和函数一样调用</li>
<li>Task 类型，也就是我们的任务类型</li>
</ul>
<p>所以我们必须还要修改一下调度器的run方法（其实就是加入一段对SystemCall 的处理）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</span><br><span class="line">        $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</span><br><span class="line">        $retval = $task-&gt;run();</span><br><span class="line"> 				</span><br><span class="line">       <span class="comment">// 这一段是新加的,如果出队的类型是系统调用，就在调度器里面调用它，传入任务 和 调度器</span></span><br><span class="line">       <span class="comment">// 调用的结果是 </span></span><br><span class="line">       <span class="comment">// $task 会设置一个 Send 值</span></span><br><span class="line">       <span class="comment">// $this(调度器) 会把这个 $task 加入到调度器的末尾</span></span><br><span class="line">        <span class="keyword">if</span> ($retval <span class="keyword">instanceof</span> SystemCall) &#123;</span><br><span class="line">            $retval($task, <span class="keyword">$this</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//--------------------------</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</span><br><span class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在xdebug 的帮助下，我们可以看到第一次 <code>$retval = $task-&gt;run()</code> 的返回值，会走到 Task(line: 24) 的<code>$this-&gt;coroutine-&gt;current();</code> 最终取得的 <code>getTaskId()</code> 的返回值(类型为 SystemCall)</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215161137.png" alt=""></p>
<p>第二次走到<code>$retval = $task-&gt;run()</code> 的时候，最终是返回task 函数中的<code>yield();</code> 所以返回值是<code>null</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191215162115.png" alt=""></p>
<p>运行的结果就是，两个任务交替运行，知道结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is task 1 iteration 1.</span><br><span class="line">This is task 2 iteration 1.</span><br><span class="line">This is task 1 iteration 2.</span><br><span class="line">This is task 2 iteration 2.</span><br><span class="line">This is task 1 iteration 3.</span><br><span class="line">This is task 2 iteration 3.</span><br><span class="line">This is task 1 iteration 4.</span><br><span class="line">This is task 2 iteration 4.</span><br><span class="line">This is task 1 iteration 5.</span><br><span class="line">This is task 2 iteration 5.</span><br><span class="line">This is task 1 iteration 6.</span><br><span class="line">This is task 1 iteration 7.</span><br><span class="line">This is task 1 iteration 8.</span><br><span class="line">This is task 1 iteration 9.</span><br><span class="line">This is task 1 iteration 10.</span><br></pre></td></tr></table></figure>



<h2 id="协程堆栈"><a href="#协程堆栈" class="headerlink" title="协程堆栈"></a>协程堆栈</h2><p>协程堆栈是一个非常重要的应用，当你的项目变得越来越大的时候，会出现协程中套用另一个协程的情况。我们看下面这个例子。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123; <span class="comment">// 子协程</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    echoTimes(<span class="string">'foo'</span>, <span class="number">10</span>); <span class="comment">// 期待打印10次foo，实际上返回的协程，并没有真实运行过</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    echoTimes(<span class="string">'bar'</span>, <span class="number">5</span>); <span class="comment">// 期待打印5次bar，实际上返回的协程，并没有真实运行过</span></span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line">$scheduler-&gt;newTask(task());</span><br><span class="line">$scheduler-&gt;run();<span class="comment">// 运行结果： ---\n</span></span><br></pre></td></tr></table></figure>

<p>最终的结果只运行了<code>echo &quot;---\n&quot;;</code>  </p>
<p>原因也很简单，当<code>echoTimes(&#39;foo&#39;, 10)</code> 运行后，实际上返回的协程，并没有参数去接受，也没有对协程进行进一步的处理（如 <code>$this-&gt;current()</code> <code>$this-&gt;send</code> ）自然也就不会运行了。</p>
<p>但是若是直接调用 echoTimes 子协程，也是无法运行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> echoTimes(<span class="string">'foo'</span>, <span class="number">10</span>); <span class="comment">// 添加了 yield 语句</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    <span class="keyword">yield</span> echoTimes(<span class="string">'bar'</span>, <span class="number">5</span>); <span class="comment">// 添加了 yield 语句</span></span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里<code>yield echoTimes(&#39;foo&#39;, 10);</code>返回的是一个Generator 类型，而在我们的Task 类的run 方法里面，并没有对这一类型进行处理。而且我们需要的是进入函数内执行 yield 语句。这样来说，我们原先的方法就不适用了。如何解决？？</p>
<blockquote>
<p> 解决的方法就是使用——<strong><em>协程栈</em></strong></p>
</blockquote>
<p>首先，我们对传入的 $coroutine 裸协程上写一个小小的封装，stackedCoroutine就是：<strong><em>“协程堆栈”</em></strong>。 因为它将管理嵌套的协程调用堆栈。这将使得通过生成协程来调用子协程成为可能。</p>
<blockquote>
<p>注意: stackedCoroutine 中包含 yield 语句，所以它也是一个协程</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span><span class="params">(Generator $gen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $stack = <span class="keyword">new</span> SplStack; <span class="comment">// 新建一个栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断遍历这个传进来的生成器，作用和 while(True)一样</span></span><br><span class="line">    <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">        <span class="comment">// $gen可以理解为指向当前运行的协程闭包函数（生成器）</span></span><br><span class="line">        $value = $gen-&gt;current(); <span class="comment">// 获取中断点，也就是yield出来的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($value <span class="keyword">instanceof</span> Generator) &#123;</span><br><span class="line">            <span class="comment">// 如果是也是一个生成器，这就是子协程了，把当前运行的协程入栈保存</span></span><br><span class="line">            $stack-&gt;push($gen);</span><br><span class="line">            $gen = $value; <span class="comment">// 把子协程函数给gen，继续执行，注意接下来就是执行子协程的流程了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们对子协程返回的结果做了封装</span></span><br><span class="line">        $isReturnValue = $value <span class="keyword">instanceof</span> CoroutineReturnValue; <span class="comment">// 子协程返回`$value`需要主协程帮忙处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!$gen-&gt;valid() || $isReturnValue) &#123;<span class="comment">// 协程栈没有执行完 或者 存在返回值</span></span><br><span class="line">            <span class="keyword">if</span> ($stack-&gt;isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是gen已经执行完毕，或者遇到子协程需要返回值给主协程去处理</span></span><br><span class="line">            $gen = $stack-&gt;pop(); <span class="comment">//出栈，得到之前入栈保存的主协程</span></span><br><span class="line">            $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="keyword">NULL</span>); <span class="comment">// 调用主协程处理子协程的输出值</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        $gen-&gt;send(<span class="keyword">yield</span> $gen-&gt;key() =&gt; $value); <span class="comment">// 继续执行子协程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这段语句中使用了到了一个我们之前没有使用到的类 <code>CoroutineReturnValue</code> 它的作用是接受 yield 的返回值，这个类比较简单，就是对返回的值，做了一层封装。子协程的返回的结果也需要主协程帮助处理。</p>
<blockquote>
<p>在 $gen-&gt;send(yield ​$gen-&gt;key()=&gt;$value)；</p>
<p>调用者和当前正在运行的子协程之间扮演着简单代理的角色。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineReturnValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;value = $value;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 获取能把子协程的输出值给主协程，作为主协程的send参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回的值被封装成了一个类，这个类的话也很简单，就是存值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retval</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CoroutineReturnValue($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义完了协程栈，如何去使用呢？这里需要将Task中的初始化方法改一下。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</span><br><span class="line">        <span class="comment">// $this-&gt;coroutine = $coroutine;</span></span><br><span class="line">        <span class="comment">// 换成这个，实际Task-&gt;run的就是stackedCoroutine这个函数，不是$coroutine保存的闭包函数了</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;coroutine = stackedCoroutine($coroutine); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主程序如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Scheduler.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"stackedCorountine.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> retval(<span class="string">"程序运行结束"</span>); <span class="comment">//我们在这里让子协程传值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = <span class="keyword">yield</span> echoTimes(<span class="string">'foo'</span>, <span class="number">5</span>); <span class="comment">// print foo ten times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    $ret = (<span class="keyword">yield</span> echoTimes(<span class="string">'bar'</span>, <span class="number">2</span>)); <span class="comment">// print bar five times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line">$scheduler-&gt;newTask(task());</span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">foo iteration <span class="number">1</span></span><br><span class="line">foo iteration <span class="number">2</span></span><br><span class="line">foo iteration <span class="number">3</span></span><br><span class="line">foo iteration <span class="number">4</span></span><br><span class="line">foo iteration <span class="number">5</span></span><br><span class="line">程序运行结束</span><br><span class="line">---</span><br><span class="line">bar iteration <span class="number">1</span></span><br><span class="line">bar iteration <span class="number">2</span></span><br><span class="line">程序运行结束</span><br></pre></td></tr></table></figure>

<p>这个程序真的是不容易看懂，我是在xdebug 的逐步调试的过程中才看懂了一点。</p>
<p>解释下<code>$gen-&gt;send(yield $gen-&gt;key()=&gt;$value)；</code> 这个语句中send 和 yield 交叉，而且用了 <code>$gen-&gt;key =&gt; $value</code>  这样的用法。</p>
<p>yield 有三种用法 </p>
<p><strong>参考：</strong><a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">php manual: yield</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span>; <span class="comment">// 相当于 (yield null);</span></span><br><span class="line">$data = (<span class="keyword">yield</span> $value); <span class="comment">// 必须使用圆括号把yield申明包围起来</span></span><br><span class="line">$data = (<span class="keyword">yield</span> $key =&gt; $value); <span class="comment">//返回的是键值对，迭代的时候用 foreach($data as $key =&gt; $value)</span></span><br></pre></td></tr></table></figure>

<p>首先我们找到 <code>(yield $gen-&gt;key()=&gt;$value)；</code> 返回的地方</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();  <span class="comment">// &lt;-- 返回的是这里</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue); <span class="comment">// &lt;-- 返回的是这里</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">return</span> $retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会让人很奇怪，因为我们返回的是键值对，这里直接调用current() 。经过实践可知 最终的值是<code>$value</code> ，也就是说，我们直接把语句改成 <code>(yield $value)</code> 也是正确的。</p>
<p>我的第二个疑问是<code>$gen-&gt;send(yield $gen-&gt;key()=&gt;$value)；</code> 中 send 方法到低发送出去了什么❓</p>
<p>send  方法中是一个yield 语句。那我们就可以找找在这个协程中有没有对应的send 方法即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191216192955.png" alt=""></p>
<p>最后，我们找到了这个协程的send 方法，但是<code>$this-&gt;sendValue</code> 我们是一直都没有设置过，始终是null。</p>
<h3 id="协程堆栈小结"><a href="#协程堆栈小结" class="headerlink" title="协程堆栈小结"></a>协程堆栈小结</h3><p>这个协程堆栈实现起来比较费脑子，特别是主协程和子协程之间的沟通方式。可能现实情况下动手写的情况很少（我感觉是框架已经实现完毕，我们只需要简单的使用 <code>$ret = (yield readfile());</code> 语句就可以）。但是如果能自己实现一遍协程堆栈，对yield 的用法肯定掌握的更好。</p>
<p>这篇教程参考了很多博客</p>
<p><a href="https://segmentfault.com/a/1190000012457145" target="_blank" rel="noopener">PHP7下的协程实现</a></p>
<p><a href="http://reatang.com/?id=23" target="_blank" rel="noopener">我是这么理解协程yield异步IO的</a></p>
<p>TO DO LIST</p>
<ul>
<li><input disabled="" type="checkbox"> yield from</li>
<li><input disabled="" type="checkbox"> 教程中的 非阻塞IO 案例 代码分析 测试 配合<a href="http://reatang.com/?id=23" target="_blank" rel="noopener">我是这么理解协程yield异步IO的</a></li>
</ul>
<h2 id="程序附录"><a href="#程序附录" class="headerlink" title="程序附录"></a>程序附录</h2><h3 id="程序一：-与调度器之间的通讯"><a href="#程序一：-与调度器之间的通讯" class="headerlink" title="程序一： 与调度器之间的通讯"></a>程序一： 与调度器之间的通讯</h3><p>Index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Scheduler.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"SystemCall.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(<span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $task-&gt;setSendValue($task-&gt;getTaskId());</span><br><span class="line">        $scheduler-&gt;schedule($task);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">($max)</span> </span>&#123;</span><br><span class="line">    $tid = (<span class="keyword">yield</span> getTaskId()); <span class="comment">// &lt;-- here's the syscall!</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is task $tid iteration $i.\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">10</span>));</span><br><span class="line">$scheduler-&gt;newTask(task(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">$scheduler-&gt;run();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>Scheduler.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></span><br><span class="line">    <span class="keyword">protected</span> $taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> \SplQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</span><br><span class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</span><br><span class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">        <span class="keyword">return</span> $tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</span><br><span class="line">            $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</span><br><span class="line">            $retval = $task-&gt;run();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($retval <span class="keyword">instanceof</span> SystemCall) &#123;</span><br><span class="line">                $retval($task, <span class="keyword">$this</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</span><br><span class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>SystemCall.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(callable $callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;callback = $callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</span><br><span class="line">        $callback = <span class="keyword">$this</span>-&gt;callback;</span><br><span class="line">        <span class="keyword">return</span> $callback($task, $scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $taskId;</span><br><span class="line">    <span class="keyword">protected</span> $coroutine;</span><br><span class="line">    <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> $retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="程序二：-协程堆栈"><a href="#程序二：-协程堆栈" class="headerlink" title="程序二： 协程堆栈"></a>程序二： 协程堆栈</h3><p>index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Task.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"Scheduler.php"</span>);</span><br><span class="line"><span class="keyword">include</span> (<span class="string">"stackedCorountine.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</span><br><span class="line">        <span class="keyword">yield</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> retval(<span class="string">"程序运行结束\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = <span class="keyword">yield</span> echoTimes(<span class="string">'foo'</span>, <span class="number">5</span>); <span class="comment">// print foo ten times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"---\n"</span>;</span><br><span class="line">    $ret = (<span class="keyword">yield</span> echoTimes(<span class="string">'bar'</span>, <span class="number">2</span>)); <span class="comment">// print bar five times</span></span><br><span class="line">    <span class="keyword">if</span> ($ret)&#123;</span><br><span class="line">        <span class="keyword">echo</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// force it to be a coroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$scheduler = <span class="keyword">new</span> Scheduler;</span><br><span class="line">$scheduler-&gt;newTask(task());</span><br><span class="line">$scheduler-&gt;run();</span><br></pre></td></tr></table></figure>



<p>stackedCoroutine.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span><span class="params">(Generator $gen)</span> </span>&#123;</span><br><span class="line">    $stack = <span class="keyword">new</span> SplStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        $value = $gen-&gt;current();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($value <span class="keyword">instanceof</span> Generator) &#123;</span><br><span class="line">            $stack-&gt;push($gen);</span><br><span class="line">            $gen = $value;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $isReturnValue = $value <span class="keyword">instanceof</span> CoroutineReturnValue;</span><br><span class="line">        <span class="keyword">if</span> (!$gen-&gt;valid() || $isReturnValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($stack-&gt;isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $gen = $stack-&gt;pop();</span><br><span class="line">            $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="keyword">NULL</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $gen-&gt;send( (<span class="keyword">yield</span> $gen-&gt;key() =&gt; $value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineReturnValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;value = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取能把子协程的输出值给主协程，作为主协程的send参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retval</span><span class="params">($value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CoroutineReturnValue($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task.php  和   Scheduler.php 不变</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用SSH连接家中的服务器:ngrok</title>
    <url>/2019/12/01/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%AE%B6%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200121011429.png" alt="来自新浪图片"></p>
<p>家中闲置了一台电脑，准备用来当做服务器。一方面也是作为linux 学习练练手，二是可以运行一些爬虫小程序或者是网页服务。</p>
<p>这里我用的manjaro，这是目前比较流行的linux 发行版，最热门的linux桌面发行版之一。</p>
<p>我选择manjaro也是想作为替代windows 来用。manjaro拥有一个非常方便的软件仓库，利用pacman和yay等命令可以十分方便的安装软件。</p>
<a id="more"></a>

<p>家中的电脑，由于没有公网ip，只能在家中用ssh 访问，一旦出门，就无法访问服务器了。这非常不方便，因为可能要从电脑上获取资料，访问数据库，修改代码等等操作，一旦离开本地环境，也太不方便了。</p>
<p>经过百度后发现，需要利用  <strong>内网穿透</strong> 技术实现。 原因是我们的ip资源是稀缺的，我们普通家庭中使用的ip都是动态分配的ip地址。没有固定的ip的服务器是无法与外网连接的，所以我们至少需要一个公网ip。</p>
<p>内网穿透技术有很多了，我这里选择的是ngrok 这个方案。<br>我试了一下两种方案，第一个是外国的ngrok，没有尝试成功，而且免费版本每次断开后，生成的url 是随机的。所以没有采用。第二个是国内的Sunny-Ngrok，有免费版的。先尝试一波。</p>
<ul>
<li><a href="https://dashboard.ngrok.com/get-started" target="_blank" rel="noopener">ngrok</a></li>
<li><a href="https://www.ngrok.cc/download.html" target="_blank" rel="noopener">ngrok.cc</a>  （Sunny-Ngrok）</li>
</ul>
<blockquote>
<p>使用Sunny-Ngrok一个很大的好处就是在当你没有服务器和公网ip的时候，它会是一个很不错的解决方案。当然若是你有服务器的话，自己搭一个ngrok未尝不是一个很好的选择。</p>
</blockquote>
<h2 id="局域网连接服务器"><a href="#局域网连接服务器" class="headerlink" title="局域网连接服务器"></a>局域网连接服务器</h2><p>这里先给出用局域网连接服务器的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux 查看ip 地址一般是下面三种方法（不同系统不一样）</span></span><br><span class="line">$ ifconfig</span><br><span class="line">$ ipconfig</span><br><span class="line">$ ip addr <span class="comment"># &lt;--manjaro</span></span><br></pre></td></tr></table></figure>
<p>运行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip addr | grep inet</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">    inet 192.168.1.102/24 brd 192.168.1.255 scope global dynamic noprefixroute wlp2s0</span><br><span class="line">    inet6 fe80::1bd5:9435:6572:ffc7/64 scope link noprefixroute</span><br><span class="line"><span class="comment"># ip地址是 192.168.1.102</span></span><br></pre></td></tr></table></figure>
<p>局域网中使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 22 ppsteven@192.168.1.l02</span><br><span class="line"><span class="comment"># -p 22 也可以省略，因为ssh 的默认端口号就是22</span></span><br></pre></td></tr></table></figure>



<h2 id="Sunny-Ngrok教程"><a href="#Sunny-Ngrok教程" class="headerlink" title="Sunny-Ngrok教程"></a>Sunny-Ngrok教程</h2><p>教程基本上都在 <a href="http://www.ngrok.cc/_book/general/tcp.html" target="_blank" rel="noopener">ngrok.cc官方文档</a> 写的很清楚了，但是有一些还是需要注意的。</p>
<h3 id="开通隧道"><a href="#开通隧道" class="headerlink" title="开通隧道"></a>开通隧道</h3><p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191201135321.png" alt=""></p>
<p>如果你是想用ssh，开通的就是TCP转发。记得要把本地端口换成22（当然不换也是可以的，只要你最后连ssh 的时候设置好端口就行了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191201135519.png" alt=""></p>
<p>最后看到的结果是这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191201153141.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -p 10568 yourname@free.aa.com 就可以连接上你的服务器了</span><br></pre></td></tr></table></figure>



<h3 id="Ngrok-启动"><a href="#Ngrok-启动" class="headerlink" title="Ngrok 启动"></a>Ngrok 启动</h3><p>上图可以看到，在状态栏显示 是否成功开启ngrok</p>
<p>启动的方法，官网教程里面也有写，本人按照流程走一遍。</p>
<h3 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h3><p>我用的是Mac 下载zip文件，然后上传到服务器的操作。有图形界面的同学，可以直接按照官网操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp ~/Downloads/linux_amd64.zip ppsteven@192.168.1.102:~/Documents</span><br><span class="line">$ ssh 192.168.1.102</span><br><span class="line">$ <span class="built_in">cd</span> ~/Documents</span><br><span class="line">$ unzip linux_amd64.zip</span><br></pre></td></tr></table></figure>
<h3 id="启动ngrok-服务"><a href="#启动ngrok-服务" class="headerlink" title="启动ngrok 服务"></a>启动ngrok 服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前目录在linux_amd64 下</span></span><br><span class="line">$ ./sunny clientid 隧道id  <span class="comment"># 启动隧道服务</span></span><br><span class="line">$ setsid ./sunny clientid 743acXXXX &amp; <span class="comment"># 在后台启动隧道服务</span></span><br></pre></td></tr></table></figure>
<p>启动服务后，我们在官网的后端就可以看到结果。<br>为了让我们的服务器能不断的在后台运行，我们需要登录服务器后，运行第二行的命令</p>
<ul>
<li>&amp; 作用是后台运行程序</li>
<li>setsid 作用是当终端关闭的时候命令一直不会关闭</li>
</ul>
<h3 id="高级教程——开机自动运行"><a href="#高级教程——开机自动运行" class="headerlink" title="高级教程——开机自动运行"></a>高级教程——开机自动运行</h3><p>官网中已经给出了 <a href="http://www.ngrok.cc/_book/start/ngrok_auto.html" target="_blank" rel="noopener">Ngrok开机自启动</a> 的教程，我们这里由于使用的是manjaro，官网的教程无法直接参考，我们这里给出自己的解决方案。</p>
<h4 id="第一步：移动命令，并使之可执行"><a href="#第一步：移动命令，并使之可执行" class="headerlink" title="第一步：移动命令，并使之可执行"></a>第一步：移动命令，并使之可执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv sunny /usr/<span class="built_in">local</span>/bin/sunny</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/sunny</span><br></pre></td></tr></table></figure>

<h4 id="第二步：编写启动脚本"><a href="#第二步：编写启动脚本" class="headerlink" title="第二步：编写启动脚本"></a>第二步：编写启动脚本</h4><p>我们这里直接上手修改官网的shell语言</p>
<p>sunny_auto.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash -e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          ngrok.cc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$network</span> <span class="variable">$remote_fs</span> <span class="variable">$local_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$network</span> <span class="variable">$remote_fs</span> <span class="variable">$local_fs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description: autostartup of ngrok <span class="keyword">for</span> Linux</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"></span><br><span class="line">NAME=sunny</span><br><span class="line">DAEMON=/usr/local/bin/$NAME</span><br><span class="line">PIDFILE=/var/run/$NAME.pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断 sunny 是否可执行</span></span><br><span class="line">[ -x "$DAEMON" ] || exit 0</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">  start)</span><br><span class="line">      # 根据/var/run/sunny.pid 文件判断sunny是否正在运行</span><br><span class="line">      if [ -f $PIDFILE ]; then </span><br><span class="line">        echo "$NAME already running..."</span><br><span class="line">        echo -e "\033[1;35mStart Fail\033[0m"</span><br><span class="line">      else</span><br><span class="line">        echo "Starting $NAME..."</span><br><span class="line">        # start-stop-daemon -S -p $PIDFILE -m -b -o -q -x $DAEMON -- clientid 隧道id || return 2</span><br><span class="line">        # 不使用start-stop-daemon，使用常规的方法后台运行</span><br><span class="line">        setsid sunny clientid 1cb52410136cfe34 &amp;</span><br><span class="line">        echo -e "\033[1;32mStart Success\033[0m"</span><br><span class="line">    fi</span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">        echo "Stoping $NAME..."</span><br><span class="line">        # start-stop-daemon -K -p $PIDFILE -s TERM -o -q || return 2</span><br><span class="line">        # pkill 是 kill 和 pgrep 的结合，删除所有中带sunny的进程</span><br><span class="line">        pkill -9 sunny </span><br><span class="line">        rm -rf $PIDFILE</span><br><span class="line">        echo -e "\033[1;32mStop Success\033[0m"</span><br><span class="line">    ;;</span><br><span class="line">  restart)</span><br><span class="line">    $0 stop &amp;&amp; sleep 2 &amp;&amp; $0 start</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    echo "Usage: $0 &#123;start|stop|restart&#125;"</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>写完之后，我们需要测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+x sunny_auto.sh</span><br><span class="line">./sunny_auto.sh # 会输出使用方法</span><br><span class="line">./sunny_auto.sh start </span><br><span class="line">./sunny_auto.sh stop</span><br><span class="line">./sunny_auto.sh restart</span><br></pre></td></tr></table></figure>

<p>测试成功后，我们需要让系统自己启动。我看了一下，目前网上大部分教程都是直接给了代码，并没有解释清楚自启动的原理。我认为这是可以通过查看官方教程一步步讲清楚的。抱着<strong>“授人以鱼不如授人以渔”</strong> 的态度，我准备写的仔细一点。</p>
<h4 id="第三步：自动跑起来"><a href="#第三步：自动跑起来" class="headerlink" title="第三步：自动跑起来"></a>第三步：自动跑起来</h4><p>我们的系统是manjaro，是arch linux 的衍生版本，所以我们第一想到的就是去 <a href="https://www.archlinux.org/" target="_blank" rel="noopener">https://wiki.archlinux.org/</a> 上找。</p>
<p>archlinux 上，在如下九个方面，我们可以完成”autostart” 操作</p>
<ul>
<li>开关机</li>
<li>登录登出</li>
<li>插入拔出设备</li>
<li>计时事件</li>
<li>文件系统事件</li>
<li>shell登录登出</li>
<li>Xorg</li>
<li>桌面环境</li>
<li>窗口管理启动</li>
</ul>
<p>这里，我们需要第一项开关机 <a href="https://wiki.archlinux.org/index.php/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Systemd</a> 作为我们自启动的方式，其实很多教程中也是采用的这个方式。</p>
<h5 id="单元文件"><a href="#单元文件" class="headerlink" title="单元文件"></a>单元文件</h5><p>一个服务可以看做是一个unit，每个unit需要编写自己的单元文件。<code>systemd</code> <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="noopener">单元文件</a>的语法来源于 XDG 桌面项配置文件<code>.desktop</code>文件，最初的源头则是Microsoft Windows的<code>.ini</code>文件。</p>
<h5 id="单元文件操作"><a href="#单元文件操作" class="headerlink" title="单元文件操作"></a>单元文件操作</h5><p>立即激活单元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl start &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>立即停止单元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl stop &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>重启单元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl restart &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>重新加载配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl reload &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>输出单元运行状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl status &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>检查单元是否配置为自动启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl is-enabled &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>开机自动激活单元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl enable &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<p>设置单元为自动启动并立即启动这个单元:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl enable --now unit</span><br></pre></td></tr></table></figure>

<p>取消开机自动激活单元：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl disable &lt;单元&gt;</span><br></pre></td></tr></table></figure>

<h5 id="编辑我们的单元文件"><a href="#编辑我们的单元文件" class="headerlink" title="编辑我们的单元文件"></a>编辑我们的单元文件</h5><p>单元文件的语法，可以参考系统已经安装的单元，也可以参考 <a href="https://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.service.5" target="_blank" rel="noopener">systemd.service(5)</a> 中的<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html#Examples" target="_blank" rel="noopener">EXAMPLES章节</a>。英文不好的同学，有一位热心的大牛，已经写好了中文教程 <a href="http://www.jinbuguo.com/systemd/systemd.index.html" target="_blank" rel="noopener">systemd.index 中文手册</a></p>
<p>单元文件的地址如下</p>
<ul>
<li><code>/usr/lib/systemd/system/</code> ：软件包安装的单元</li>
<li><code>/etc/systemd/system/</code> ：系统管理员安装的单元</li>
</ul>
<p>从网上的教程看下来，大家最喜欢的一个做法就是创建一个<code>rc.local</code> 文件，和一个<code>rc-local.service</code> 服务。然后把我们需要运行的脚本加入<code>rc.local</code>中。</p>
<p>我认为这样的做法很省事，也比较简单，不过缺点是所有的开机自启服务都放一起了，比较乱不好管理。这里我准备按照自己的想法来创建一个服务，我这里借鉴了docker.service。</p>
<p>sunny.service</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=ngrok sunny</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">User</span>=ppsteven</span><br><span class="line"><span class="comment"># 自动重启服务</span></span><br><span class="line"><span class="comment"># Restart=always</span></span><br><span class="line"><span class="comment"># RestartSec=30</span></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">ExecStart</span>=/etc/sunny.sh start</span><br><span class="line"><span class="attr">ExecStop</span>=/etc/sunny.sh stop</span><br><span class="line"><span class="comment"># ExecReload=/bin/kill -s HUP $MAINPID</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>



<h3 id="连接远程服务器"><a href="#连接远程服务器" class="headerlink" title="连接远程服务器"></a>连接远程服务器</h3><p>ngrok 的作用直观的来说，就是给我们提供了一个公网ip，使我们可以访问内网地址。<br>ngrok的作用就是，将我们传给<a href="http://www.abc.com:12345" target="_blank" rel="noopener">www.abc.com:12345</a> 的端口转发给我们本地服务器127.0.0.1:22端口上，实现了ssh功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -p 12345 yourname@www.abc.com</span><br></pre></td></tr></table></figure>

<h3 id="zshrc-配置小结"><a href="#zshrc-配置小结" class="headerlink" title=".zshrc 配置小结"></a>.zshrc 配置小结</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> localDell=<span class="string">"ssh ppsteven@192.168.1.102"</span></span><br><span class="line">$ <span class="built_in">alias</span> remoteDell=<span class="string">"ssh -p 10568 yourname@free.aa.com"</span></span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/91684175" target="_blank" rel="noopener">有了内网穿透神器 ngrok ，个人电脑也能做服务器</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>sunny-ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装及基础命令</title>
    <url>/2019/11/21/docker-installation-and-basic-command/</url>
    <content><![CDATA[<p>最近的工作</p>
<ul>
<li>php 学习，设计到LAMP的环境搭建。虽然是Mac上Apache 和 php 都是自带的，但是环境上还是不足，所以要用Docker。DAMP</li>
<li>爬虫ip 池搭建，发现别人造好的轮子上需要如redis，flask等环境。而且配置完了，最终也是要部署到服务器上去的，所以docker 是必不可少的</li>
</ul>
<p>最近的工作，让我感到Docker的学习一定要提前了。因为只是先用起来，首先记录一些常用的命令，争取一天搞定。</p>
<a id="more"></a>

<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>我的主力机子是Mac，家里用旧电脑搭了 manjaro ，所以我需要两个安装教程</p>
<h3 id="Mac-Docker安装"><a href="#Mac-Docker安装" class="headerlink" title="Mac Docker安装"></a>Mac Docker安装</h3><p>Mac 上配置docker最为方便</p>
<blockquote>
<p>这里参考 <a href="https://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">菜鸟教程:MacOS Docker 安装</a> </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install docker </span><br><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">docker info </span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<p><strong>镜像加速</strong><br>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。还有" target="_blank" rel="noopener">http://hub-mirror.c.163.com。还有</a> <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 是官方的中国站点。这些站点存储的是docker hub 的官方热门镜像，如果是私人的镜像，还是需要去美国站点下载。</p>
<p>在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。<br><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191124001923.png" alt=""></p>
<h3 id="Manjaro-docker-安装"><a href="#Manjaro-docker-安装" class="headerlink" title="Manjaro docker 安装"></a>Manjaro docker 安装</h3><p>Manjaro 也拥有非常强大的包管理软件 pacman 和 yay<br>这里我们使用pacman，这里面的软件都是来自官方库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">$ sudo pacman -S docker</span><br><span class="line"><span class="comment"># 启动docker 服务</span></span><br><span class="line">$ sudo systemctl start docker </span><br><span class="line"><span class="comment"># 查看docker服务状态</span></span><br><span class="line">$ sudo systemctl status docker</span><br><span class="line"><span class="comment"># 设置docker开启启动服务</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>这里Linux 有一个比Mac 麻烦一点的地方，就是每次使用docker 需要用sudo 超级管理员权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果还没有 docker group 就添加一个</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将自己的登录名($&#123;USER&#125; )加入该 group 内。然后退出并重新登录就生效啦</span></span><br><span class="line">sudo gpasswd -aG <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker 服务</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p><strong>Linux 镜像加速</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建配置文件</span></span><br><span class="line">$ sudo touch /etc/docker/daemon.json </span><br><span class="line"><span class="comment"># 添加国内站点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>,<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker daemon</span></span><br><span class="line">$ sudo systemctl restart docker </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否有修改成功</span></span><br><span class="line">$ docker info </span><br><span class="line"><span class="comment"># 查看Register Mirrors的信息</span></span><br><span class="line">Registry Mirrors:</span><br><span class="line">  https://registry.docker-cn.com/</span><br><span class="line">  http://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>

<h3 id="Centos-docker"><a href="#Centos-docker" class="headerlink" title="Centos docker"></a>Centos docker</h3><h4 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h4><p>docker 安装其实比较麻烦的，感谢 <code>图灵:Docker开发指南</code> 给的安装建议，我们可以直接用别人写好的脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://get.docker.com &gt; install.sh</span><br><span class="line">chmod +x install.sh</span><br><span class="line">cat install.sh <span class="comment"># 感兴趣的话，可以研究一下 shell 究竟写了啥</span></span><br><span class="line">./install.sh </span><br><span class="line"><span class="comment"># 安装完了，记得启动 docker 服务</span></span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose-github-安装"><a href="#docker-compose-github-安装" class="headerlink" title="docker-compose(github 安装)"></a>docker-compose(github 安装)</h4><blockquote>
<p>有条件的话，参考 <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker官方教程</a><br>这一种方法是官方推荐，但是鉴于中国墙，速度有可能非常感人</p>
</blockquote>
<h5 id="1-从-github-上下载-docker-compose-命令"><a href="#1-从-github-上下载-docker-compose-命令" class="headerlink" title="1. 从 github 上下载 docker-compose 命令"></a>1. 从 github 上下载 docker-compose 命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.3/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h5 id="2-赋予可执行权限"><a href="#2-赋予可执行权限" class="headerlink" title="2. 赋予可执行权限"></a>2. 赋予可执行权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h5 id="3-验证是否安装成功"><a href="#3-验证是否安装成功" class="headerlink" title="3. 验证是否安装成功"></a>3. 验证是否安装成功</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose-pip-安装"><a href="#docker-compose-pip-安装" class="headerlink" title="docker-compose(pip 安装)"></a>docker-compose(pip 安装)</h4><blockquote>
<p>一般容易出问题的是 pip 的版本，如果是使用了conda作为包管理的话，可能主要注意pip的版本。我一开始是使用base环境的pip作下载，然后将安装的docker-compose 软连接至 <code>/usr/local/bin</code> 中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的镜像 images</span></span><br><span class="line"><span class="variable">$docker</span> images</span><br><span class="line"><span class="variable">$docker</span> image ls </span><br><span class="line">REPOSITORY       TAG     IMAGE ID      CREATED             SIZE</span><br><span class="line">ubuntu          latest   775349758637  2 weeks ago         64.2MB</span><br><span class="line"><span class="comment"># 标签的含义</span></span><br><span class="line">- REPOSTITORY：表示镜像的仓库源</span><br><span class="line">- TAG：镜像的标签</span><br><span class="line">- IMAGE ID：镜像ID</span><br><span class="line">- CREATED：镜像创建时间</span><br><span class="line">- SIZE：镜像大小</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取镜像</span></span><br><span class="line"><span class="variable">$docker</span> pull ubuntu:13.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找镜像</span></span><br><span class="line"><span class="variable">$docker</span> search ubuntu</span><br><span class="line">- NAME:镜像仓库源的名称</span><br><span class="line">- DESCRIPTION:镜像的描述</span><br><span class="line">- OFFICIAL:是否docker官方发布</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line"><span class="variable">$docker</span> rmi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有镜像</span></span><br></pre></td></tr></table></figure>



<h2 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h2><p>docker run 是docker 命令中比较复杂的一个命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> run &lt;images&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="variable">$docker</span> run busybox <span class="built_in">echo</span> hello world</span><br><span class="line"><span class="variable">$docker</span> run Ubuntu:16.01 /bin/bash</span><br><span class="line"><span class="variable">$docker</span> run -t-i Ubuntu:16.01 /bin/bash</span><br><span class="line">-t-i: 交互式会话</span><br><span class="line">-d: 后台方式</span><br><span class="line">--rm: 运行完成后就会删除</span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -ti &lt;CONTAINER ID&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面所有的&lt;CONTAINER ID&gt; 都可以用容器的NAME 替代</span></span><br><span class="line"><span class="comment"># docker 很贴心的为我们的容器起了名字</span></span><br><span class="line"><span class="comment"># 列出运行容器</span></span><br><span class="line"><span class="variable">$docker</span> ps </span><br><span class="line"><span class="variable">$docker</span> ps -a <span class="comment"># 包含停止但没有消失的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止正在运行的容器</span></span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">kill</span> &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="variable">$docker</span> stop &lt;CONTAINER ID&gt; </span><br><span class="line"><span class="comment"># 两个命令都是会停止容器运行</span></span><br><span class="line"><span class="comment"># 停止没有消失的容器</span></span><br><span class="line"><span class="variable">$docker</span> restart &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="variable">$docker</span> start &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="comment"># 启动并进入交互界面</span></span><br><span class="line"><span class="variable">$docker</span> start -it &lt;CONTAINER ID&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除无用的容器</span></span><br><span class="line"><span class="variable">$docker</span> rm &lt;CONTAINER ID&gt;</span><br><span class="line"><span class="comment"># 删除所有已停止的容器</span></span><br><span class="line"><span class="variable">$docker</span> rm -v $(docker ps -aq -f status=exited)</span><br><span class="line"><span class="comment"># 删除所有容器</span></span><br><span class="line"><span class="variable">$docker</span> rm $(docker ps -a)</span><br></pre></td></tr></table></figure>

<h2 id="查看docker输出"><a href="#查看docker输出" class="headerlink" title="查看docker输出"></a>查看docker输出</h2><p>用于查看docker 的输出，对于没有交互(-ti)的容器的时候，需要用这个命令查看容器输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> logs &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>

<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$docker</span> cp &lt;CONTAINER ID&gt;:[/path/to/file]</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://github.com/eon01/DockerCheatSheet" target="_blank" rel="noopener">DockerCheatSheet</a><br><a href="https://www.cnblogs.com/imzhizi/p/10718310.html" target="_blank" rel="noopener">Linux(Manjaro) -Docker 安装及基本配置</a></p>
</blockquote>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>日常学习笔记</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 搜索技巧</title>
    <url>/2019/11/21/github-search-tips/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为最近手头上的东西很多，要最快的在很短的时间内完成一个项目，需要多多参考别人的优秀的代码。很多东西，在github 上都开源了，反复造轮子浪费时间，用好别人东西才是最高效的方法。</p>
<a id="more"></a>

<h2 id="瞎逛逛"><a href="#瞎逛逛" class="headerlink" title="瞎逛逛"></a>瞎逛逛</h2><ul>
<li><a href="https://github.com/trending" target="_blank" rel="noopener">GitHub Trend</a> 页面总结了每天/每周/每月周期的热门 Repositories 和 Developers，你可以看到在某个周期处于热门状态的开发项目和开发者。</li>
<li><a href="https://github.com/topics" target="_blank" rel="noopener">GitHub Topic</a> 展示了最新和最流行的讨论主题，在这里你不仅能够看到开发项目，还能看到更多非开发技术的讨论主题，比如 Job、Chrome 浏览器等。</li>
</ul>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in:name xx //搜索名字中带有&quot;xx&quot;的</span><br><span class="line">in:readme xx //搜索readme中带有&quot;xx&quot;的</span><br><span class="line">in:description xx //搜索描述中带有&quot;xx&quot;的</span><br><span class="line">stars:&gt;1000 //搜索stars&gt;1000的</span><br><span class="line">forks:&gt;1000 //搜索forks&gt;1000的</span><br><span class="line">pushed:&gt;2019-09-01 //搜索最近更新于2019年9月1日之后的</span><br><span class="line">language:xx //搜索xx的项目</span><br><span class="line">pushed:&gt;2019-09-01 //2019年9月1日后有更新的</span><br><span class="line">language:java //用Java编写的项目</span><br><span class="line">user:ppsteven forks:&gt;100 //ppsteven用户下forks&gt;100 的项目</span><br></pre></td></tr></table></figure>

<h2 id="有影响力的项目"><a href="#有影响力的项目" class="headerlink" title="有影响力的项目"></a>有影响力的项目</h2><ul>
<li><a href="https://github.com/vhf/free-programming-books" target="_blank" rel="noopener">free-programming-books</a>：整理了所有和编程相关的免费书籍，同时也有 <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">中文版项目</a>。</li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet/" target="_blank" rel="noopener">github-cheat-sheet</a>：集合了使用 GitHub 的各种技巧。</li>
<li>后续会逐步更新添加</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://sspai.com/post/46061" target="_blank" rel="noopener">掌握 3 个搜索技巧，在 GitHub 上快速找到实用软件资源</a></p>
</blockquote>
]]></content>
      <categories>
        <category>基础技能</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记</title>
    <url>/2019/11/19/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>php 入门教程，主要来自于菜鸟教程，入门级别，日常学习笔记。<br>找了一个 <code>php</code> 的实习，必须马上掌握啊。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;My first PHP page&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php 代码</span></span><br><span class="line">？&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  单行注释</span></span><br><span class="line"><span class="comment">/**/</span> 多行注释</span><br></pre></td></tr></table></figure>

<h2 id="echo-print"><a href="#echo-print" class="headerlink" title="echo/print"></a>echo/print</h2><p>echo // 多个<br>print // 一个</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">  <span class="comment">//两行是相同效果，&lt;br&gt; 看做回车</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Hello world! from:"</span>,<span class="string">"Elen"</span>,<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Hello world! from:"</span>.<span class="string">"Elen"</span>.<span class="string">'&lt;br&gt;'</span>; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> Echo,print,print_r,var_dump 区别</p>
</blockquote>
<p><strong>1.echo</strong></p>
<p>输出一个或者多个字符串。</p>
<p><strong>2.print</strong></p>
<p>和 echo 最主要的区别： print 仅支持一个参数，并总是返回 1。</p>
<p><strong>3.print_r</strong></p>
<p>打印关于变量的易于理解的信息,如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 记住，print_r() 将把数组的指针移到最后边。使用 reset() 可让指针回到开始处。</p>
<p><strong>4.var_dump</strong></p>
<p>此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p>
<p><strong>5.var_dump 和 print_r 的区别</strong></p>
<p>var_dump 返回表达式的类型与值而 print_r 仅返回结果，相比调试代码使用 var_dump 更便于阅读。</p>
<h2 id="EOF-定义字符串"><a href="#EOF-定义字符串" class="headerlink" title="EOF 定义字符串"></a>EOF 定义字符串</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name=<span class="string">"Sally"</span>;</span><br><span class="line">$a= <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">        "hername : " <span class="subst">$name</span></span></span><br><span class="line"><span class="string">        "123"</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line"><span class="keyword">echo</span> $a;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hername : &quot; Sally &quot;123&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>结束需要独立一行且前后不能空格</li>
<li>$name 经过了计算</li>
<li>空格和换行都被处理为一个空格 </li>
</ol>
</blockquote>
<h2 id="PHP-类型"><a href="#PHP-类型" class="headerlink" title="PHP 类型"></a>PHP 类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line">$a = <span class="string">"Hello world"</span>;</span><br><span class="line"><span class="comment">// Integer </span></span><br><span class="line">$b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// Float</span></span><br><span class="line">$c = <span class="number">3.0</span>;</span><br><span class="line">$d = (float)$a;</span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line">$e = <span class="string">'3.0'</span>==<span class="number">3</span>; <span class="comment">//$e 的值应该是为true，因为== 是弱比较，不关心等式左右的类型</span></span><br><span class="line">$f = <span class="keyword">true</span>; </span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line">$g = <span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'wang'</span>,<span class="string">'year'</span>=&gt;<span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $color;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($color=<span class="string">"green"</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;color = $color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">what_color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$h = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">// NULL</span></span><br><span class="line">$i = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_</span><span class="params">($obj)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> $obj,<span class="string">'=&gt;'</span>,var_dump($obj),<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">print_($a);</span><br><span class="line">print_($b);</span><br><span class="line">print_($c);</span><br><span class="line">print_($d);</span><br><span class="line">print_($e);</span><br><span class="line">print_($f);</span><br><span class="line">print_($g);</span><br><span class="line">var_dump($h);<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">print_($i);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello world=&gt;string(11) &quot;Hello world&quot;</span><br><span class="line">3=&gt;int(3)</span><br><span class="line">3=&gt;float(3)</span><br><span class="line">0=&gt;float(0)</span><br><span class="line">1=&gt;bool(true)</span><br><span class="line">1=&gt;bool(true)</span><br><span class="line">Array=&gt;array(2) &#123; [&quot;name&quot;]=&gt; string(4) &quot;wang&quot; [&quot;year&quot;]=&gt; int(2000) &#125;</span><br><span class="line">object(Car)#1 (1) &#123; [&quot;color&quot;]=&gt; string(5) &quot;green&quot; &#125;</span><br><span class="line">=&gt;NULL</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bool define ( string $name , mixed $value [, bool $case_insensitive = <span class="keyword">false</span> ] )</span><br><span class="line">$name:常量名</span><br><span class="line">$value:值</span><br><span class="line">$case_insensitive:是否对大小写敏感,<span class="keyword">true</span> 代表不敏感</span><br></pre></td></tr></table></figure>

<p>define(“GREETING”, “欢迎访问 Runoob.com”);<br>echo GREETING;    // 输出 “欢迎访问<br>常量默认是全局变量</p>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//字符串合并</span><br><span class="line">$txt .&quot;+&quot;.$txt2 </span><br><span class="line">//字符串长度</span><br><span class="line">strlen()</span><br><span class="line">//字符串查找，未找到返回False</span><br><span class="line">strpos(&quot;文本&quot;,&quot;查找字符&quot;) // 返回字符串位置，从0开始</span><br></pre></td></tr></table></figure>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age = <span class="number">18</span>;</span><br><span class="line">$stage = <span class="keyword">array</span>(<span class="string">'青少年'</span>,<span class="string">'成年'</span>,<span class="string">'老年'</span>);</span><br><span class="line"><span class="keyword">if</span> ($age &gt;=<span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">	$title = $stage[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ($age &gt;=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line">	$title = $stage[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	$title = $stage[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $title,<span class="string">'&lt;br&gt;&lt;br&gt;'</span>;</span><br><span class="line"></span><br><span class="line">$favcolor=<span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">switch</span> ($favcolor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色是红色!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"blue"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色是蓝色!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色是绿色!"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"你喜欢的颜色不是 红, 蓝, 或绿色!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>while/do while/for /foreach</p>
<h3 id="while-do-while"><a href="#while-do-while" class="headerlink" title="while/do while"></a>while/do while</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// while </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"while &lt;br&gt;"</span>;</span><br><span class="line">$x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> ($x) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $x--,<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do .. while </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"do..while &lt;br&gt;"</span>;</span><br><span class="line">$x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">echo</span> $x,<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">while</span> ($x--)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">do..while</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="for-foreach"><a href="#for-foreach" class="headerlink" title="for/ foreach"></a>for/ foreach</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">1</span>; $i&lt;=<span class="number">5</span>; $i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The number is "</span> . $i . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$x=<span class="keyword">array</span>(<span class="string">"one"</span>=&gt;<span class="number">1</span>,<span class="string">"two"</span>=&gt;<span class="number">2</span>,<span class="string">"three"</span>=&gt;<span class="number">3</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($x <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> $key,<span class="string">" : "</span>,$value,<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The number is 1</span><br><span class="line">The number is 2</span><br><span class="line">The number is 3</span><br><span class="line">The number is 4</span><br><span class="line">The number is 5</span><br><span class="line">one : 1</span><br><span class="line">two : 2</span><br><span class="line">three : 3</span><br></pre></td></tr></table></figure>



<h2 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__LINE__: 语句所处的行号</span><br><span class="line">__FILE__: 文件的完整路径（含文件名）</span><br><span class="line">__DIR__: 文件的目录</span><br><span class="line">__FUNCTION__: 函数名</span><br><span class="line">__CLASS__: 类名</span><br><span class="line">__TRAIT__: Trait 名</span><br><span class="line">__METHOD__:类的方法名</span><br><span class="line">__NAMESPACE__:命名空间</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace MyProject;// 必须是在首行</span><br><span class="line">// 魔术常量</span><br><span class="line">echo &apos;这是第 &quot; &apos;  . __LINE__ . &apos; &quot; 行&apos;,&apos;&lt;br&gt;&apos;;</span><br><span class="line">echo &apos;该文件位于 &quot; &apos;  . __FILE__ . &apos; &quot; &apos;,&apos;&lt;br&gt;&apos;;</span><br><span class="line">echo &apos;该文件位于 &quot; &apos;  . __DIR__ . &apos; &quot; &apos;,&apos;&lt;br&gt;&apos;;</span><br><span class="line"></span><br><span class="line">echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line">        function _print() &#123;</span><br><span class="line">                echo &apos;类名为：&apos;  . __CLASS__ . &quot;&lt;br&gt;&quot;;</span><br><span class="line">                echo  &apos;函数名为：&apos; . __FUNCTION__ .&quot;&lt;br&gt;&quot;;</span><br><span class="line">                echo  &apos;类的方法名：&apos; . __METHOD__ ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">$t = new test();</span><br><span class="line">$t-&gt;_print();</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是第 &quot; 4 &quot; 行</span><br><span class="line">该文件位于 &quot; /Library/WebServer/Documents/a.php &quot;</span><br><span class="line">该文件位于 &quot; /Library/WebServer/Documents &quot;</span><br><span class="line">命名空间为：&quot;MyProject&quot;类名为：MyProject\test</span><br><span class="line">函数名为：_print</span><br><span class="line">类的方法名：MyProject\test::_print</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：PHP中的命名空间，可以解决的问题：</p>
</blockquote>
<ol>
<li>用户编写的代码与PHP内部的类/函数/常量名字冲突</li>
<li>为很长的标识符创建一个更加可读的别名</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><ol>
<li>自动分配id</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cars = <span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="keyword">array</span>( <span class="string">'a'</span>,<span class="number">3</span> =&gt; <span class="string">'b'</span>,<span class="number">1</span> =&gt; <span class="string">'c'</span>, <span class="string">'d'</span>);</span><br><span class="line">var_dump($a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//array(4) &#123; [0]=&gt; string(1) "a" [3]=&gt; string(1) "b" [1]=&gt; string(1) "c" [4]=&gt; string(1) "d" &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关联数组</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$age = <span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>遍历数组</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age = <span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($age <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $key,<span class="string">'  =&gt; '</span>,$value,<span class="string">'  type: '</span>,var_dump($key),<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数组排序</li>
</ol>
<p>sort() &lt;–&gt; rsort()<br>asort() &lt;–&gt; arsort() //关联数组<br>ksort() &lt;–&gt; krsort() //关联数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age=<span class="keyword">array</span>(<span class="string">"a"</span>=&gt;<span class="string">"5"</span>,<span class="string">"c"</span>=&gt;<span class="string">"37"</span>,<span class="string">"b"</span>=&gt;<span class="string">"-1"</span>,<span class="string">"e"</span>=&gt;<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"原始数组:"</span>;</span><br><span class="line">print_r($age);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"按key 排序"</span>;</span><br><span class="line">ksort($age);</span><br><span class="line">print_r($age);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"按value 排序"</span>;</span><br><span class="line">asort($age);</span><br><span class="line">print_r($age);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="PHP-面向对象"><a href="#PHP-面向对象" class="headerlink" title="PHP 面向对象"></a>PHP 面向对象</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> $url;</span><br><span class="line">  <span class="keyword">var</span> $title;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($par1,$par2)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">$this</span>-&gt;url = $par1;</span><br><span class="line">  	<span class="keyword">$this</span>-&gt;title = $par2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>.<span class="string">"  已经运行"</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">     <span class="keyword">$this</span>-&gt;url = $par;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">     <span class="keyword">$this</span>-&gt;title = $par;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$siteobj = <span class="keyword">new</span> Site(<span class="string">'www.baidu.com'</span>,<span class="string">'baidu'</span>);</span><br><span class="line"><span class="keyword">print</span> $siteobj-&gt;url;</span><br><span class="line">$siteobj-&gt;setUrl(<span class="string">'ppsteven.github.io'</span>);</span><br><span class="line">$siteobj-&gt;setTitle(<span class="string">'learnPHP'</span>);</span><br><span class="line">$siteobj-&gt;getUrl();</span><br><span class="line">$siteobj-&gt;getTitle();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$y = <span class="string">"globals varibale"</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">($z=null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">global</span> $y; <span class="comment">// $y 为全局变量，有两种方式使用</span></span><br><span class="line">	<span class="keyword">echo</span> $y,<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">	<span class="keyword">echo</span> $GLOBALS[<span class="string">'y'</span>],<span class="string">'&lt;br&gt;'</span>; </span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'参数作用域'</span>,$z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> $x1=<span class="number">0</span>;</span><br><span class="line">    $x2 = <span class="number">0</span>; <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $x1.<span class="string">'('</span>.$x2.<span class="string">"）"</span>;<span class="comment">// 静态变量是不会随着函数完成而删除</span></span><br><span class="line">    $x1++;</span><br><span class="line">    $x2++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x2(x1)</span></span><br><span class="line"><span class="comment">0(0)</span></span><br><span class="line"><span class="comment">0(1)</span></span><br><span class="line"><span class="comment">0(2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>包含一些小的知识点和未系统整理的知识</p>
<ul>
<li><p>三元：expr1 ? expr2 : expr3</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> $var = <span class="keyword">true</span> ? <span class="number">1</span> : <span class="keyword">false</span> ? <span class="number">2</span> : <span class="number">3</span>;</span><br><span class="line"> $varx = (<span class="keyword">true</span> ? <span class="number">1</span> : <span class="keyword">false</span>)? <span class="number">2</span> : <span class="number">3</span>;</span><br><span class="line"> $vary = <span class="keyword">true</span> ? <span class="number">1</span> : (<span class="keyword">false</span> ? <span class="number">2</span> : <span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> $var.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> $varx.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> $vary.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="comment">// 结果是 2 2 1 , 这里的三元运算需要注意执行的顺序</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>null == false  : 返回的是false</p>
</li>
<li><p>1/2 (0.5) PHP中没有整除算法，有整除函数intdiv(1/2)</p>
</li>
<li><p>php 作用域</p>
<ul>
<li>local</li>
<li>global</li>
<li>static</li>
<li>parameter // 参数作用域</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> $x;</span><br><span class="line">    $x++;</span><br><span class="line">    <span class="keyword">echo</span> PHP_EOL;    <span class="comment">// 换行符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 static 使得$x 的值会一直累加</span></span><br><span class="line">myTest(); <span class="comment">// 0 </span></span><br><span class="line">myTest(); <span class="comment">// 1</span></span><br><span class="line">myTest(); <span class="comment">// 2</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>echo PHP_EOL; // 换行符</p>
</li>
<li><p>==   弱比较<br>=== 强比较</p>
</li>
</ul>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>日常学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git cheetsheet</title>
    <url>/2019/11/14/git-cheetsheet/</url>
    <content><![CDATA[<h2 id="cheetsheet"><a href="#cheetsheet" class="headerlink" title="cheetsheet"></a>cheetsheet</h2><p>入门级别的git 基础操作，仅仅收录理解了的，常用的命令。负责的命令，在附录的大全里面可以找到</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200216020515.png" alt=""> </p>
<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>Git 有三层的配置文件</p>
<ol>
<li>仓库级的配置文件：在仓库的 <code>.git/config</code> 目录下，只对本仓库有效</li>
<li>全局级的配置文件：Mac在 <code>~/.gitconfig</code> 目录</li>
<li>系统级的配置文件：在Git 的 安装目录下 (经过查找，我的目录为/usr/local/Cellar/git/2.23.0_1/.bottle/etc)</li>
</ol>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --local: 仓库级 , --glocal: 全局级 , --system: 系统级</span></span><br><span class="line"><span class="comment"># 添加配置</span></span><br><span class="line">$ git config --global user.name <span class="string">"Name"</span> <span class="comment"># 添加用户名 --global 代表配置的全局的参数</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span> <span class="comment"># 添加邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">$ git config --list/ -l <span class="comment"># 查看全部git配置</span></span><br><span class="line">$ git config --get user.name/user.email <span class="comment"># 查看单个配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置</span></span><br><span class="line">$ git config --<span class="built_in">unset</span> user.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置</span></span><br><span class="line">$ git config -e --global</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加别名，对于一些比较长的别名，可以简化</span></span><br><span class="line"><span class="comment"># 也可以通过git config </span></span><br><span class="line">$ git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">$ git config --global alias.graph <span class="string">"log --graph --oneline"</span></span><br></pre></td></tr></table></figure>
<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init  <span class="comment"># 创建空的git代码库</span></span><br><span class="line">$ git init Myfolder <span class="comment"># 创建文件夹Myfolder，并创建git代码库</span></span><br></pre></td></tr></table></figure>
<h3 id="文件（增删改提）"><a href="#文件（增删改提）" class="headerlink" title="文件（增删改提）"></a>文件（增删改提）</h3><h4 id="git-add-增"><a href="#git-add-增" class="headerlink" title="git add 增"></a>git add 增</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line">$ git add .  <span class="comment"># 当前目录（递归子目录）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="git-commit-提交"><a href="#git-commit-提交" class="headerlink" title="git commit 提交"></a>git commit 提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend -m <span class="string">"desc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿372a* 提交的信息（作者、提交者、注释、时间戳等）来提交当前修改</span></span><br><span class="line">$ git commit -c 372a</span><br></pre></td></tr></table></figure>

<h4 id="git-reset-还原"><a href="#git-reset-还原" class="headerlink" title="git reset 还原"></a>git reset 还原</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line"><span class="comment"># 丢弃暂存区中的所有文件的修改（工作区不受影响）</span></span><br><span class="line">$ git reset </span><br><span class="line">$ git reset --mixed </span><br><span class="line"></span><br><span class="line">$ git reset &lt;文件路径,commit ID&gt;</span><br><span class="line">$ git reset --mixed  &lt;文件路径,commit ID&gt;</span><br><span class="line"></span><br><span class="line">$ git reset --hard HEAD^ <span class="comment"># 回到上一个版本（HEAD: 当前版本，HEAD^: 上一个版本，HEAD~100: 往上100个版本）</span></span><br><span class="line">$ git reset --hard 1234567 <span class="comment"># 回到指定版本号commit id（此处：commit id 假设为1234567******，Git会根据commit id的前几位自动寻找对应的版本）</span></span><br><span class="line">$ git reset --soft HEAD~ <span class="comment"># hard 和 soft 的区别在与 soft（暂存区和工作区中的所有文件的修改都不丢弃）</span></span><br><span class="line">$ git reset --merge  &lt;commit&gt;  // 在被污染的工作区中回滚merge或者</span><br><span class="line"></span><br><span class="line">$ git reflog <span class="comment"># 查看命令历史</span></span><br></pre></td></tr></table></figure>





<h4 id="git-revert-反做"><a href="#git-revert-反做" class="headerlink" title="git revert 反做"></a>git revert 反做</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>
<p>比较一下 git revert 和 git reset 的区别：</p>
<p>git reset是把HEAD向后移动来删除提交，而git revert是用一次新的提交来回滚之前的提交（HEAD会继续前进）。下面一幅图比较形象生动。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191115001540.png" alt=""></p>
<p>关于git 的版本回退的问题，<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">廖雪峰的博客：时光穿梭机</a>已经讲的很好了，我们可以通过<code>git log</code> 查看“当前”版本库的状态，但是如何查看“未来”的版本库呢？可以通过<code>git reflog</code> 查看。</p>
<h4 id="git-remove-删除"><a href="#git-remove-删除" class="headerlink" title="git remove 删除"></a>git remove 删除</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;文件路径&gt; <span class="comment"># 删除工作区文件，若文件在工作区或缓存区中有修改，会失败。有两种解决方式：1、强制删除  2、只删除暂存区的文件</span></span><br><span class="line">$ git rm -f &lt;文件路径&gt; <span class="comment"># 1.无论有没有在工作区或暂存区修改，强制删除</span></span><br><span class="line">$ git rm --cached &lt;文件路径&gt; <span class="comment"># 2.移除暂存区的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git rm -r &lt;文件夹路径&gt; <span class="comment"># 移除文件夹</span></span><br></pre></td></tr></table></figure>

<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br><span class="line"><span class="comment"># 可以使用 Beyond Compare4 软件</span></span><br></pre></td></tr></table></figure>



<h4 id="git-checkout-恢复"><a href="#git-checkout-恢复" class="headerlink" title="* git checkout  恢复"></a>* git checkout  恢复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当在暂存区中有修改时，使用暂存区中的修改覆盖工作区中的 &lt;文件路径&gt;</span></span><br><span class="line"><span class="comment"># 当不在暂存区中时，使用本地版本库中的HEAD指针处的修改覆盖工作区中的&lt;文件路径&gt;</span></span><br><span class="line">$ git checkout -- &lt;文件路径&gt;</span><br><span class="line"><span class="comment"># 用本地版本库中 HEAD处提交的文件，覆盖 暂存区和工作区的文件</span></span><br><span class="line">$ git checkout HEAD &lt;文件路径&gt;</span><br><span class="line"><span class="comment"># 用本地版本库中 93ef处提交的文件，覆盖 暂存区和工作区的文件</span></span><br><span class="line">$ git checkout 93ef &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<p>恢复文件举例</p>
<p>a 文件被修改过，checkout  去除修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat a </span><br><span class="line">Hello world</span><br><span class="line">orphan`</span><br><span class="line">$ git checkout a</span><br><span class="line">Updated 1 path from the index</span><br><span class="line">$ cat a</span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">add a line</span><br></pre></td></tr></table></figure>



<h3 id="git-日志与文件状态"><a href="#git-日志与文件状态" class="headerlink" title="git 日志与文件状态"></a>git 日志与文件状态</h3><h4 id="git-status-状态"><a href="#git-status-状态" class="headerlink" title="git status 状态"></a>git status 状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前所处的分支暂存区和工作区的文件（会显示当前所处分支）</span></span><br><span class="line"><span class="comment"># 注1：处于暂存区的文件状态:：staged(已暂存)；处于工作区的文件状态:：untrack(未跟踪)、modified(已修改)</span></span><br><span class="line"><span class="comment"># 注2：工作区中的空目录不会被git追踪</span></span><br><span class="line">$ git status</span><br><span class="line">$ git status &lt;branch name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以简短模式查看暂存区和工作区的文件</span></span><br><span class="line"><span class="comment"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line">$ git status -s</span><br></pre></td></tr></table></figure>

<h4 id="git-log-日志"><a href="#git-log-日志" class="headerlink" title="git log 日志"></a>git log 日志</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line">$ git <span class="built_in">log</span> -- &lt;文件&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级功能</span></span><br><span class="line"><span class="comment"># 记不住可以设置别名</span></span><br><span class="line">$ git <span class="built_in">log</span> -p &lt;文件&gt; <span class="comment"># 显示出每次修改的内容</span></span><br><span class="line">$ --graph  <span class="comment"># 图形化的方式显示</span></span><br><span class="line">$ --graph --oneline <span class="comment"># 图形化简洁模式</span></span><br><span class="line">$ --graph --oneline --name-only <span class="comment"># 图像化简洁模式（只显示文件名清单）</span></span><br><span class="line">$ --author = leon <span class="comment"># 限定作者leon</span></span><br><span class="line">$ --grep = <span class="string">"test"</span> <span class="comment"># 限定注释</span></span><br><span class="line">$ --since=<span class="string">"2018-10-7"</span> --until=<span class="string">'2019-10-12'</span></span><br><span class="line"><span class="comment"># since,until 标记对和 after，before 标记对是等价的</span></span><br><span class="line">$ --after=<span class="string">"2018-10-7"</span> --before=<span class="string">'2018-10-12'</span></span><br><span class="line">$ --since=2.weeks <span class="comment"># 最近2周的提交记录</span></span><br></pre></td></tr></table></figure>

<h4 id="git-show-显示修改"><a href="#git-show-显示修改" class="headerlink" title="git show 显示修改"></a>git show 显示修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计各个提交者的次数</span></span><br><span class="line">$ git shortlog -sn </span><br><span class="line"><span class="comment"># 显示修改内容(详细)</span></span><br><span class="line">$ git show 3a6c</span><br><span class="line">$ git show HEAD</span><br><span class="line"><span class="comment"># 显示最近一次提交的修改内容（不显示具体的修改内容）</span></span><br><span class="line">$ git show --name-only HEAD</span><br></pre></td></tr></table></figure>

<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line">$ git branch -r <span class="comment"># 列出所有远程分支 cache</span></span><br><span class="line">$ git branch -a <span class="comment"># 列出所有本地分支和远程分支cache</span></span><br><span class="line">$ git branch -av <span class="comment"># 列出所有本地分支和远程分支cache（含简单说明）</span></span><br><span class="line">$ git branch -vv <span class="comment"># 查看本地分支和远程分支cache的追踪关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line"><span class="comment"># 删除的时候需要从被删除的分区切换出去</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream hexo origin:hexo ??</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在本地新建了分支，远程没有分支的情况</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream origin master <span class="comment"># 建立联系</span></span><br><span class="line">$ git branch -vv <span class="comment"># 查看本地和远程的追踪关系</span></span><br></pre></td></tr></table></figure>

<h4 id="git-checkout-分支切换"><a href="#git-checkout-分支切换" class="headerlink" title="git checkout 分支切换"></a>git checkout 分支切换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git 提交流程 工作区-&gt; 暂存区 -&gt; 版本库</span></span><br><span class="line">$ git checkout &lt;分支名称&gt; <span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout -- &lt;file&gt; <span class="comment"># 撤销修改：1. 文件在添加到缓存区前修改，则回退到原工作区状态；2. 文件在添加到缓存区后修改，则回退到原缓存区状态。也即是将&lt;file&gt;撤回到最近一次git add或git commit状态（注：--表示在当前分支，如果没有，则切换到另一个分支）</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt; <span class="comment"># 创建并切换</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;<span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout -<span class="comment"># 切换到上一次分支</span></span><br></pre></td></tr></table></figure>

<h4 id="git-merge-rebase-分支合并"><a href="#git-merge-rebase-分支合并" class="headerlink" title="git merge/rebase 分支合并"></a>git merge/rebase 分支合并</h4><p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200216020354.png" alt="">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下</span></span><br><span class="line">$ git merge &lt;分支名称&gt; <span class="comment"># 无冲突时会直接提交</span></span><br><span class="line">$ git merge --no-commit &lt;分支名称&gt; <span class="comment"># 不自动提交</span></span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> &lt;name&gt; <span class="comment"># 合并后的分支有历史记录，而Fast-Forward合并之后，分支没有历史记录</span></span><br><span class="line"><span class="comment"># Fast-Forwar 的合并的方法是指针的移动。</span></span><br><span class="line"></span><br><span class="line">$ git rebase &lt;分支名称&gt; <span class="comment"># rebase 能保持清晰的提交记录，但是合并的操作没有记录下来（merge 则是会新建一个提交）</span></span><br></pre></td></tr></table></figure>



<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><h4 id="git-clone-克隆"><a href="#git-clone-克隆" class="headerlink" title="git clone 克隆"></a>git clone 克隆</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆文件</span></span><br><span class="line"><span class="comment"># Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快，https 每次推送都必须输入口令。</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/XXX/learngit.git Yourfilepath <span class="comment"># https</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:XXX/learngit.git ./lesson01 <span class="comment"># ssh（推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b &lt;分支名称&gt; &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -o 设置远程仓库为origin</span></span><br><span class="line">$ git <span class="built_in">clone</span> -o &lt;orgin name&gt; https://github.com/kekec/Test.git</span><br></pre></td></tr></table></figure>

<h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line">origin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line">origin https://github.com/kekec/Test.git (fetch)</span><br><span class="line">origin https://github.com/kekec/Test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove/rm &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/显示远程仓库的 URL 地址</span></span><br><span class="line">$ git remote <span class="built_in">set</span>-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br><span class="line">$ git remoter get-url &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示远程仓库的信息（举例）</span></span><br><span class="line">$ git remote show origin </span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/kekec/Test.git</span><br><span class="line">  Push URL: https://github.com/kekec/Test.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master tracked</span><br><span class="line">    v3.1 tracked</span><br><span class="line">Local branch configured <span class="keyword">for</span> <span class="string">'git pull'</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">Local refs configured <span class="keyword">for</span> <span class="string">'git push'</span>:</span><br><span class="line">    master pushes to master (fast-forwardable)</span><br><span class="line">    v3.1 pushes to v3.1 (up to date)</span><br><span class="line"><span class="comment"># 可以查看 git pull 和 git push 的具体信息</span></span><br></pre></td></tr></table></figure>

<h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p> 从远程仓库获取最新的版本到本地分支上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch orgin master/dev</span><br></pre></td></tr></table></figure>

<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="* git pull"></a>* git pull</h4><blockquote>
<p>git pull  &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; </p>
</blockquote>
<p> 从远程仓库获取最新版本并合并到本地。<br>首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先执行fetch，然后将远程origin/master分支merge合并到当前分支（最后会更新origin/master, origin/HEAD指针到最新提交）</span></span><br><span class="line">$ git pull origin master</span><br><span class="line">$ git pull -r origin master <span class="comment"># 先执行fetch，然后将远程origin/master分支rebase合并到master分支</span></span><br><span class="line">$ git pull origin master:dev <span class="comment"># 先执行fetch，然后将远程origin/master 分支merge合并到本地dev分支</span></span><br></pre></td></tr></table></figure>

<h4 id="git-push"><a href="#git-push" class="headerlink" title="* git push"></a>* git push</h4><p> 把本地仓库的提交推送到远程仓库。</p>
<blockquote>
<p>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本地仓库的修改push到origin所指向的远程仓库URL的master分支上，并在.git/config文件中记录当前分支与远程分支master的对应关系</span></span><br><span class="line">$ git push -u origin master <span class="comment"># -u 在第一次push的时候使用即可</span></span><br><span class="line">$ git push origin -f <span class="comment"># 当合入对应的远端仓库有冲突的时候，使用当前分支更新</span></span><br><span class="line">$ git push origin --all <span class="comment"># 推送本地的所有的分支到各自的远端分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete/-d &lt;远程分支名&gt;</span><br><span class="line">$ git push origin:dev <span class="comment"># 删除远端分支 dev</span></span><br><span class="line">$ git push origin -d dev <span class="comment"># 效果同上</span></span><br></pre></td></tr></table></figure>



<h3 id="存储文件的区块"><a href="#存储文件的区块" class="headerlink" title="存储文件的区块"></a>存储文件的区块</h3><h4 id="贮藏区-git-stash"><a href="#贮藏区-git-stash" class="headerlink" title="贮藏区 git  stash"></a>贮藏区 git  stash</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash <span class="comment"># 将工作区中所有文件的修改备份压栈到储藏区，然后丢弃工作区与暂存区的所有文件的修改。</span></span><br><span class="line"><span class="comment"># 经过试验，git stash 会丢弃已有文件的修改的，不会删除新建的文件。</span></span><br><span class="line">$ git stash pop <span class="comment"># 恢复工作区，并将贮藏区的备份删除</span></span><br><span class="line">$ git stash list <span class="comment"># 查看贮藏区</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: 30e5191 add a</span><br><span class="line">$ git stash show -p stash@&#123;0&#125; <span class="comment"># 查看栈顶文件的修改</span></span><br><span class="line">diff --git a/a b/a</span><br><span class="line">index 11817a2..399e9b0 100644</span><br><span class="line">--- a/a</span><br><span class="line">+++ b/a</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> Hello world</span><br><span class="line"></span><br><span class="line"> add a line</span><br><span class="line">+add a line</span><br><span class="line">$ git stash drop <span class="comment"># 直接移除储藏区的栈顶处备份（不用于恢复当前分支的工作区）</span></span><br><span class="line">$ git stash clear <span class="comment"># 清除储藏区栈列表</span></span><br><span class="line">$ git stash apply stash@&#123;0&#125; <span class="comment"># 使用stash@&#123;0&#125;来恢复当前分支的工作区，但不移除储藏区中任何备份</span></span><br></pre></td></tr></table></figure>

<h4 id="工作区-git-clean"><a href="#工作区-git-clean" class="headerlink" title="工作区 git clean"></a>工作区 git clean</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git clean -nd  <span class="comment"># 探测工作区中有哪些未追踪状态的文件和目录</span></span><br><span class="line">$ git clean -fd  <span class="comment"># 删除工作区中未追踪状态的文件和目录</span></span><br></pre></td></tr></table></figure>

<h4 id="暂存区-git-ls-files"><a href="#暂存区-git-ls-files" class="headerlink" title="暂存区 git ls-files"></a>暂存区 git ls-files</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git ls-files <span class="comment"># 查询暂存区中的文件列表（递归子目录）</span></span><br><span class="line"><span class="comment"># 下面是抄的</span></span><br><span class="line">$ git ls-files -s  // 查看暂存区中所有文件的blob数据块信息</span><br><span class="line">$ git ls-files -s -- README.md  // 查看暂存区中的README.md文件的blob数据块信息</span><br></pre></td></tr></table></figure>

<h3 id="打包-git-archive"><a href="#打包-git-archive" class="headerlink" title="打包 git archive"></a>打包 git archive</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前master分支所有文件使用zip压缩方式打包到d:/file.zip</span></span><br><span class="line">$ git archive --format zip --output ./file.zip master</span><br></pre></td></tr></table></figure>

<p>团队合作分支</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200216020436.png" alt=""></p>
<h2 id="TO-DO-LIST"><a href="#TO-DO-LIST" class="headerlink" title="TO DO LIST"></a>TO DO LIST</h2><ul>
<li><input disabled="" type="checkbox"> 看完教程<a href="http://www.findme.wang/share/detail/id/327.html#sub6" target="_blank" rel="noopener">git 教程</a> 补充</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></li>
<li><a href="https://www.cnblogs.com/kekec/p/9248487.html" target="_blank" rel="noopener">Git原理与命令大全</a></li>
<li><a href="https://www.jianshu.com/p/93318220cdce" target="_blank" rel="noopener">Git命令大全</a></li>
</ul>
]]></content>
      <categories>
        <category>cheetsheet</category>
      </categories>
      <tags>
        <tag>日常学习笔记</tag>
        <tag>git</tag>
        <tag>cheetsheet</tag>
      </tags>
  </entry>
  <entry>
    <title>Pine Script 学习笔记(二)——基本特点</title>
    <url>/2019/11/04/Pine%20Script%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是Pine Script 学习笔记的第二篇，简单挑教程上重要的记录了一下。</p>
<a id="more"></a>

<h2 id="Context-switching-and-the-security-function"><a href="#Context-switching-and-the-security-function" class="headerlink" title="Context switching and the security function"></a>Context switching and the security function</h2><p>security 函数可以用于按照特定要求请求数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;Example security 1&quot;, overlay=true)</span><br><span class="line">ibm_15 = security(&quot;NYSE:IBM&quot;, &quot;15&quot;, close)</span><br><span class="line">plot(ibm_15)</span><br></pre></td></tr></table></figure>

<p><img src="https://www.tradingview.com/pine-script-docs/en/v4/_images/Chart_security_1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security(symbol, resolution, expression, gaps, lookahead)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>symbol (string)</strong> 商品代码。</p>
<p>商品代码可以包含数据提供商信息，也可以不含</p>
<p>如 “NYSE:IBM”,”BATS:IBM”,”IBM”(如不提供，默认使用BATS)</p>
<p> <a href="https://www.tradingview.com/pine-script-reference/v4/#var_syminfo{dot}ticker" target="_blank" rel="noopener">syminfo.ticker</a> and <a href="https://www.tradingview.com/pine-script-reference/v4/#var_syminfo{dot}tickerid" target="_blank" rel="noopener">syminfo.tickerid</a>是表示当前图标上的商品代码，syminfo.ticker是不含数据供应商信息，syminfo.tickerid是包含供应商信息。Pine教程建议使用后者，为了避免数据的模糊性</p>
</li>
<li><p><strong>resolution (string)</strong> 分辨率/ <strong>timeframe</strong>时间周期</p>
<ul>
<li>分钟级：1，5，10，21，60，120，等等</li>
<li>日级: D,1D,2D 等等</li>
<li>周级：W，1W，2W</li>
<li>月级：M，1M，2M</li>
<li>timeframe.period 记录当前图标时间周期</li>
</ul>
</li>
<li><p><strong>expression (series)</strong> 计数并从 <a href="https://cn.tradingview.com/pine-script-reference/v3/#fun_security" target="_blank" rel="noopener">security</a>调用返回的表达式。</p>
<p>如果仅仅是获取收盘价数据，我们可以用<code>security(&#39;EURUSD&#39;,&#39;D&#39;,close)</code></p>
<p>但是，expression能给我们提供更加丰富的操作，比如，我们需要知道，EURUSD相对于GBPUSD 上涨的幅度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(title = &quot;Advance Decline Ratio&quot;, shorttitle=&quot;ADR&quot;)</span><br><span class="line">ratio(t1, t2, source) =&gt;</span><br><span class="line">    s1 = security(t1, timeframe.period, source)</span><br><span class="line">    s2 = security(t2, timeframe.period, source)</span><br><span class="line">    s1 / s2</span><br><span class="line">plot(ratio(&quot;GBPUSD&quot;, &quot;EURUSD&quot;, close-open))</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102123145.png" alt=""></p>
<p>如上图所以，GBPUSD上涨幅度/EURUSD 的上涨幅度我们可以很轻松的通过7行代码实现。在绝大多数情况下，两者是同比例变动，但是在某些特等情况下，变化是相反的。这对于研究这两种货币对的走势关系有很大的帮助。</p>
</li>
</ul>
<p>在security数据应用到当前图表上的时候，有两个控制，一个是gaps，另一个是lookahead</p>
<ul>
<li><p><strong>gaps (const bool)</strong> 默认值为<a href="https://cn.tradingview.com/pine-script-reference/v3/#var_barmerge{dot}gaps_off" target="_blank" rel="noopener">barmerge.gaps_off</a>。可以理解为数据平滑的操作，因为数据中会存在空值（na），在gaps_off的情况下，na会被离它最近的非空值所替代，也就不会出现间隔（gap）的情况</p>
</li>
<li><p><strong>lookahead (const bool)</strong> 默认值为<a href="https://cn.tradingview.com/pine-script-reference/v3/#var_barmerge{dot}lookahead_off" target="_blank" rel="noopener">barmerge.lookahead_off</a>。</p>
<p>合并所请求数据位置的策略。 请求的条形图与当前的条形图按照k线开盘时间合并。 这种合并策略可能导致从“未来”获取数据计算历史的不良影响。 这在回溯测试策略中不被接受，但在指标中可使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&apos;My Script&apos;, overlay=true)</span><br><span class="line">a = security(syminfo.tickerid, &apos;60&apos;, low, lookahead=barmerge.lookahead_off)</span><br><span class="line">plot(a, color=color.red)</span><br><span class="line">b = security(syminfo.tickerid, &apos;60&apos;, low, lookahead=barmerge.lookahead_on)</span><br><span class="line">plot(b, color=color.lime)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102163742.png" alt=""></p>
<p>红色是lookahead_off，绿色是lookahead_on。 我们发现开启了lookahead功能后，所产生的最低价是整个时间段的最低价，而原先是开盘K点的最低价。</p>
</li>
</ul>
<h2 id="bar-state-变量"><a href="#bar-state-变量" class="headerlink" title="bar state.* 变量"></a>bar state.* 变量</h2><ul>
<li><p>barstate.isfirst  当前k线为k线组的第一条k线</p>
</li>
<li><p>barstate.islast  当前k线为k线组的最后一条k线</p>
</li>
<li><p>barstate.ishistory  当前k线为历史k线</p>
</li>
<li><p>batstate.isrealtime 当前k线为实时k线</p>
</li>
<li><p>barstate.isnew 新K线的第一次更新</p>
</li>
<li><p>batstate.isconfirmed =当前k线的最后(关闭)更新 </p>
<blockquote>
<p>不建议在<a href="https://cn.tradingview.com/pine-script-reference/v3/#fun_security" target="_blank" rel="noopener">security</a>表达式中使用<a href="https://cn.tradingview.com/pine-script-reference/v3/#var_barstate{dot}isconfirmed" target="_blank" rel="noopener">barstate.isconfirmed</a></p>
</blockquote>
</li>
</ul>
<p>所有的历史柱线都曾被认为是新的柱线，因为脚本是依次执行的。当柱线第一更开盘价生成的时候，认为此柱线是新的。</p>
<h2 id="会话和时间信息"><a href="#会话和时间信息" class="headerlink" title="会话和时间信息"></a>会话和时间信息</h2><p>Pine 提供方法来生成 交易区间，时间和日期的信息。</p>
<p>time(变量): 返回的是时间戳格式</p>
<p>time(函数)：time(resolution, session) → series 返回的是按照session 格式返回的时间，如果不在session时间段的话便会返回na值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;Time&quot;, overlay=true)</span><br><span class="line">t1 = time(timeframe.period, &quot;0000-0000&quot;)</span><br><span class="line">bgcolor(t1 ? color.blue : na)</span><br></pre></td></tr></table></figure>

<p>session = “0000-0000:23456” 即24h，去除周六日，运行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102203555.png" alt=""></p>
<p>可以看到，周一至周五背景都变成了蓝色，因为t1 不在session的范围内的时候返回na值</p>
<p>交易区间的格式有</p>
<ul>
<li><p>0000-0000:1234567 24小时交易，时间从午夜0点开始</p>
</li>
<li><p>0000-0000:23456 工作日24小时交易</p>
</li>
<li><p>1700-1700：24小时交易，时间从17点开始</p>
</li>
<li><p>0930-1700:146  交易时间为09:30~17:00，交易时间在周日（1），周三（4），周五（6）</p>
</li>
<li><p>24x7 等价于 0000-0000:1234567</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断是否为30min的新柱线</span><br><span class="line">//@version=4</span><br><span class="line">study(&quot;new 30 min bar&quot;)</span><br><span class="line">is_newbar(res) =&gt;</span><br><span class="line">    t = time(res)</span><br><span class="line">    not na(t) and (na(t[1]) or t &gt; t[1])</span><br><span class="line">plot(is_newbar(&quot;30&quot;) ? 1 : 0)</span><br></pre></td></tr></table></figure>

<p>用到的函数变量和类型</p>
<ul>
<li>time：UNIX格式的当前k线时间</li>
<li>timenow：UNIX格式的当前时间</li>
<li>syminfo.timezone：时区</li>
</ul>
<p>当前K线用到的变量</p>
<ul>
<li>year/month/weekofyear</li>
<li>dayofmonth</li>
<li>dayofweek（sunday,monday 等）</li>
<li>hour/minute/second</li>
</ul>
<p>创建时间</p>
<ul>
<li><a href="https://www.tradingview.com/pine-script-reference/v4/#fun_timestamp" target="_blank" rel="noopener">timestamp(year, month, day, hour, minute)</a> </li>
</ul>
<h2 id="策略编写"><a href="#策略编写" class="headerlink" title="策略编写"></a>策略编写</h2><h3 id="backtesting-amp-forwardtesting"><a href="#backtesting-amp-forwardtesting" class="headerlink" title="backtesting &amp; forwardtesting"></a>backtesting &amp; forwardtesting</h3><p>strategy脚本是可以产生交易订单的Pine 脚本。利用strategy 可以做策略回测（backtesting）和 模拟交易（forwardtesting）</p>
<p>无论backtesting 还是forwardtesting，计算都是<strong><u>默认</u></strong>发生在K线收盘的时候，但是在forwardtesting 的时候，可以选择在每一个tick发生的时候，都运行一次。</p>
<p>做法一是调整strategy的 Setting/Properties，或者修改代码，添加<code>strategy(... ,calc_on_every_tick=true )</code> ，此外还可以选择在每笔订单完成之后计算<code>strategy(... , calc_on_order_fills=true)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191102215042.png" alt=""></p>
<h3 id="经纪商模拟"><a href="#经纪商模拟" class="headerlink" title="经纪商模拟"></a>经纪商模拟</h3><p>仅仅只有OHLC数据的话，K线内数据的生成有一套逻辑，如果最高价更接近开盘价，生成顺序是 open-&gt;high-&gt;low-&gt;close，此外还假设价格是没有gaps的</p>
<h3 id="订单生成命令"><a href="#订单生成命令" class="headerlink" title="订单生成命令"></a>订单生成命令</h3><h4 id="strategy-entry-订单生成函数"><a href="#strategy-entry-订单生成函数" class="headerlink" title="strategy.entry 订单生成函数"></a>strategy.entry 订单生成函数</h4><p>这是进入市场的命令。 如果具有相同ID的订单已经挂起，则可修改订单。 如果没有指定ID的订单，则会发出新的订单。 </p>
<p>要取消/停用预挂单，应使用命令<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}cancel" target="_blank" rel="noopener">strategy.cancel</a>或<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}cancel_all" target="_blank" rel="noopener">strategy.cancel_all</a>。 </p>
<p>与函数<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}order" target="_blank" rel="noopener">strategy.order</a>相比，<a href="https://cn.tradingview.com/pine-script-reference/v4/#fun_strategy{dot}entry" target="_blank" rel="noopener">strategy.entry</a>功能受金字塔影响，可以正确反转市场位置。 如果“Limit”和“stop”参数均为“NaN”，则订单类型为市场订单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strategy.entry(id, long, qty, limit, stop, oca_name, oca_type, comment, when) → void</span><br></pre></td></tr></table></figure>

<h4 id="strategy-exit-订单退出函数"><a href="#strategy-exit-订单退出函数" class="headerlink" title="strategy.exit 订单退出函数"></a>strategy.exit 订单退出函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, when) → void</span><br></pre></td></tr></table></figure>

<p>这是一个退出指定进场或整个市场地位的命令，重点区分它和strategy.close 的不同</p>
<ul>
<li>id(string): 订单的标识符。</li>
<li>from_entry(string): 这里填入要平仓的订单的标识符，默认为空。</li>
<li>qty: 平仓手数(弄清楚合约的大小)</li>
<li>qty_percent: 平台的比例</li>
<li>profit: 获利点数(一定搞清楚单位是点还是步)</li>
<li>limit: 与profit 相似，limit约定获利的价格</li>
<li>loss:止损点数</li>
<li>stop:与loss 相似，stop约定止损的价格</li>
<li>tail.*: 指明跟踪指数</li>
</ul>
<h4 id="strategy-order"><a href="#strategy-order" class="headerlink" title="strategy.order"></a>strategy.order</h4><p>这条命令可以生成开仓也可以生成平仓命令，但是它不受金字塔影响。它的作用就是弥补strategy.entry 和 strategy.exit 函数的不灵活星。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是几个例子，可以帮助我们理解strategy函数</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">strategy(&quot;revers demo&quot;)</span><br><span class="line">if bar_index &gt; 4000</span><br><span class="line">    strategy.entry(&quot;buy&quot;, strategy.long, 4, when=strategy.position_size &lt;= 0)</span><br><span class="line">    strategy.entry(&quot;sell&quot;, strategy.short, 6, when=strategy.position_size &gt; 0)</span><br><span class="line">plot(strategy.equity)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191103235510.png" alt=""></p>
<p>当仓位为空头或者无头寸的话，买4。当仓位为多头的话，卖6。</p>
<p>我们可以看到entry中buy 或sell 在交易的时候，会自动平仓，平掉反向的仓位。仓位在+4 –&gt; -6 变化。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">strategy(&quot;Partial exit demo&quot;)</span><br><span class="line">if bar_index &gt; 6500 and bar_index &lt;6550</span><br><span class="line">    strategy.entry(&quot;buy&quot;, strategy.long, 40000, when=strategy.position_size &lt;= 0)</span><br><span class="line">strategy.exit(&quot;bracket1&quot;, &quot;buy&quot;,  20000, profit = 3000,loss = 3000)</span><br><span class="line">strategy.exit(&quot;bracket2&quot;, &quot;buy&quot;,  profit=2000, loss=2000)</span><br><span class="line">plot(strategy.equity)</span><br></pre></td></tr></table></figure>

<p>盈亏曲线</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104151143.png" alt=""></p>
<p>交易逻辑</p>
<ul>
<li>buy：当空仓时候买入，40000笔合约（40000美金）</li>
<li>bracket1：设定平仓对象为buy标识的交易，平仓2000美金，止盈300点（单位为步，3000步=300点）。止损300点</li>
<li>bracket2：止盈止损200点</li>
</ul>
<p>下面结合交易清单具体分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104215413.png" alt=""></p>
<ul>
<li>1：空仓买入4000美金</li>
<li>2：止损200点，亏损20000 * 200 * 0.0001 = $ 400，从图中可以看到是bracket2 先止损</li>
<li>3：价格继续向下，亏损300点，bracket1策略触发，亏损$ 600</li>
<li>4,5,6:同上逻辑</li>
</ul>
<h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><p>strategy.risk.* 一系列函数，可以帮助进行风险管理。当风险管理规则被激活的时候，没有订单会生成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">strategy(&quot;multi risk demo&quot;, overlay=true, pyramiding=10, calc_on_order_fills = true)</span><br><span class="line">if year &gt; 2014</span><br><span class="line">    strategy.entry(&quot;LE&quot;, strategy.long)</span><br><span class="line">strategy.risk.max_intraday_filled_orders(5)</span><br><span class="line">strategy.risk.max_intraday_filled_orders(2)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>strategy.risk.max_intraday_filled_orders(2)</p>
<p>限制一天成交的最大的交易单数，一旦达到，所有未成交订单全部取消，成交订单关闭。并且一直关闭交易直到本交易日结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104172514.png" alt=""></p>
<p>上图中，当第二笔交易生成的时候，同时也是两笔交易关闭的时间。</p>
</li>
<li><p>其余的函数参考手册</p>
</li>
</ul>
<h2 id="指标重绘"><a href="#指标重绘" class="headerlink" title="指标重绘"></a>指标重绘</h2><p>历史数据仅仅包含OHLC，不包含线内的运动。这会导致的问题是，历史数据上的回测和实时数据不一致的情况。</p>
<p>另外一个担心是，未来函数的使用。这里尤其要关注security 函数，此函数可能会错误的引入未来的信息。</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>Pine V4 中存在两种绘图类型：label 和 line。</p>
<blockquote>
<p>注：用户的绘图和 编程绘图是不一样的，编程得到的绘图是不能用鼠标修改的。</p>
</blockquote>
<p>和指标绘图函数(plot,plotshape,plotchar) 不一样的是，绘图函数可以在图表右侧没有K线的地方。</p>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label.new(x, y, text, xloc, yloc, color, style, textcolor, size) → series[label]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;My Script&quot;, overlay=true)</span><br><span class="line">label.new(bar_index, high, style=label.style_none,</span><br><span class="line">          text=&quot;x=&quot; + tostring(bar_index) + &quot;\ny=&quot; + tostring(high))</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20191104175710.png" alt=""></p>
<ul>
<li><p>x的位置是用bar_index 标识的，此时xloc 的默认值为xloc.barindex</p>
</li>
<li><p>y的位置是最高价</p>
</li>
<li><p>xloc取值：xloc.bar_index(默认) 和 xloc.bar_time</p>
</li>
<li><p>yloc取值：</p>
<ul>
<li><p>yloc.price 传入此函数，需要输入y值</p>
</li>
<li><p>yloc.abovebar,yloc.belowbar 启动时，y值会失效。标签在图表上部或者下部</p>
</li>
</ul>
</li>
<li><p>style: 很多种，可能用到比较多的有label.style_none，无底色</p>
</li>
</ul>
<p>label.set_* 一系列函数可以用来对对象进一步的修改。</p>
<h3 id="line"><a href="#line" class="headerlink" title="line"></a>line</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">line.new(x1, y1, x2, y2, xloc, extend, color, style, width) → series[line]</span><br></pre></td></tr></table></figure>

<ul>
<li>extend: extend.none/extend.right/extend.left</li>
</ul>
]]></content>
      <categories>
        <category>量化</category>
        <category>Pine</category>
      </categories>
      <tags>
        <tag>Pine</tag>
        <tag>TradingView</tag>
        <tag>量化</tag>
      </tags>
  </entry>
  <entry>
    <title>Pine Script 学习笔记</title>
    <url>/2019/10/31/Pine%20Script%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Pine-Script-学习笔记——基础语法篇（一）"><a href="#Pine-Script-学习笔记——基础语法篇（一）" class="headerlink" title="Pine Script 学习笔记——基础语法篇（一）"></a>Pine Script 学习笔记——基础语法篇（一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>量化交易平台 <a href="https://www.tradingview.com/" target="_blank" rel="noopener">TrendingView </a> 是一个支持多种资产的投资平台，很多人在上面分享对于股票，外汇，数据货币等资产的投资观点，难得的是在上面能找到很多人的交易策略。</p>
<p>TrendingView 使用的是自己开发的Pine 语言作为脚本，这一点和MT4 开发的mql4 很像。用户可以自己编写脚本和策略，并与其他人分享。Pine 直观给我的印象比Mql4 更加简单，更加关注于策略本身，而不是编程技巧。</p>
<p>此外，Pine语言编辑器没有那么强大的debug 功能，这对于一开始上手练习来说，不是那么方便。不过它一直在更新，发展的很快。</p>
<p>TrendingView 对接了很多经纪商，使得它支持的交易品种很丰富，而且它的图表功能很强大。</p>
<p>下面记录一下自己学习Pine 脚本的一些基础的笔记，权当备忘。主要内容都参考自Pine 的脚本文档</p>
<a id="more"></a>

<h2 id="脚本结构"><a href="#脚本结构" class="headerlink" title="脚本结构"></a>脚本结构</h2><p>指明用的Pine 脚本版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br></pre></td></tr></table></figure>

<p>Pine 可以分为study脚本 和 strategy 脚本（指标&amp;策略）<br>study 脚本必须包含 plot,plotshape,barcolor,line.new  等输出<br>strategy 脚本包含 strategy.* 即交易函数</p>
<h2 id="换行-Line-wrapping"><a href="#换行-Line-wrapping" class="headerlink" title="换行 Line wrapping"></a>换行 Line wrapping</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//例子1 换行需要空格</span><br><span class="line">a = open+</span><br><span class="line">      high+</span><br><span class="line">        low</span><br><span class="line">// 例子2 换行中不能有注释</span><br><span class="line">a = open+</span><br><span class="line">       high // 此处加注释会出问题</span><br><span class="line">// 例子3 函数内换行，空行必须要超过一个Tab（或者4个空格）</span><br><span class="line">label.new(bar_index, na, yloc=yloc.abovebar, text=t,</span><br><span class="line">     color=hist ? color.green : color.red)</span><br><span class="line">// 这里空格必须超过4个</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>算术： + - * / %</p>
<blockquote>
<p>1/2 = 0<br>1/2.0 = 0.5</p>
</blockquote>
</li>
<li><p>比较:  ==  !=</p>
</li>
<li><p>逻辑: not and or</p>
</li>
<li><p>三元运算符：</p>
<ul>
<li>condition ? result1 : result2</li>
<li>iff(condition, result1, result2)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有房？嫁:有车？: 嫁:帅？嫁: 不嫁</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]  运算符(History reference operator)<br>close 代表最新的价格，close[1]代表了历史价格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">close = close[0] //显示的是最新的收盘价</span><br></pre></td></tr></table></figure>
<p>除此之外，Pine脚本里面还有一个变量 bar_index，记录着bar的数目，编号自左向右，从0开始。bar_index = (bar数量)N-1。</p>
<ul>
<li><input disabled="" type="checkbox"> 为什么运行close[bar_index-1] ≠ close[0] ?<br>而close[bar_index-1] 会出错</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Pine 脚本中包含了大量的自建函数，用户还可以自定义函数、</p>
<ul>
<li><p>单行函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x,y) =&gt; x+y</span><br></pre></td></tr></table></figure>

<p>Pine Script 的函数不支持<strong><u>递归</u></strong></p>
<p>即，不允许在函数中再次调用自己本身</p>
</li>
<li><p>多行函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">geom_average(x, y) =&gt;</span><br><span class="line">    a = x*x</span><br><span class="line">    b = y*y</span><br><span class="line">    sqrt(a + b)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Pine Script 需要（一个Tab 或者4空格，TrendingView 会自动用4个空格来替换掉Tab）来划定函数的范围</li>
<li>最后一行的表达式或 变量作为函数的输出结果</li>
</ul>
</blockquote>
</li>
<li><p>输出&gt;=2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun(x,y) =&gt;</span><br><span class="line">	 a = x+y</span><br><span class="line">   b = x-y</span><br><span class="line">   retrun [a,b]</span><br><span class="line">// 调用函数</span><br><span class="line">[a,b] =fun(3,2)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="函数的注意事项"><a href="#函数的注意事项" class="headerlink" title="函数的注意事项"></a>函数的注意事项</h3><p>当在函数块中使用函数或者历史数据信息的时候要注意。因为所使用的历史信息是每一次连续调用生成的。</p>
<p>如果函数并不是在每一根柱线上都调用，那么数据生成就会出现错误。</p>
<ul>
<li><p>例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义两个函数f1,f2</span><br><span class="line">f1(a) =&gt; a[1]</span><br><span class="line">f2() =&gt; close[1]</span><br><span class="line">// 说明下列用法的实际意义</span><br><span class="line">f1(close) 等价于 close[2]</span><br><span class="line">f2() 等价于 close[1]</span><br></pre></td></tr></table></figure>

<div alig=“center”>
<img src="https://www.tradingview.com/pine-script-docs/en/v4/_images/Function_historical_context_1.png">
</div>

<p>f1 传入的close 序列，需要在第一次调用后才能生成，所以f1 的 价格信息实际上比f2 晚一天</p>
</li>
</ul>
<h2 id="变量声明-amp-语句statement"><a href="#变量声明-amp-语句statement" class="headerlink" title="变量声明&amp;语句statement"></a>变量声明&amp;语句statement</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul>
<li><p>Pine 语言中变量定义的方式有两种： = 和 var</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 1 // a为整形</span><br><span class="line">float a = 1 // a为浮点型</span><br><span class="line">var a = 0</span><br><span class="line">var int a = 0</span><br><span class="line">b = na //出错</span><br></pre></td></tr></table></figure>

<p>变量定义的时候，需要指明变量的类型(或者 等式右侧表达式能指明类型亦可)</p>
<p>na 没有特定的类型，所以赋值时会出错</p>
</li>
<li><p>var 关键词</p>
<p>var 是用于分配和一次性初始化变量的关键词。</p>
<p>不含var 关键词的变量在每次数据更新的时候都会覆盖变量的值。使用了var 关键词的变量，在数据更新中，可以“保持状态”。<br>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//@version=4</span><br><span class="line">study(&quot;Var keyword example&quot;)</span><br><span class="line">var a = close</span><br><span class="line">var b = 0.0</span><br><span class="line">var c = 0.0</span><br><span class="line">var green_bars_count = 0</span><br><span class="line">if close &gt; open</span><br><span class="line">	var x = close</span><br><span class="line">	b := x</span><br><span class="line">	green_bars_count := green_bars_count + 1</span><br><span class="line">	if green_bars_count &gt;= 10</span><br><span class="line">		var y = close</span><br><span class="line">		c := y</span><br><span class="line">plot(a)</span><br><span class="line">plot(b)</span><br><span class="line">plot(c)</span><br></pre></td></tr></table></figure>

<p>变量 ‘a’ 保持系列中每个柱线的第一根柱线的收盘价。</p>
<p>变量 ‘b’保持系列中第一个“绿色”价格棒的收盘价。</p>
<p>变量 ‘c’保持系列中第十个“绿色”条的收盘价。</p>
<p>即a,b,c 都是一个常数。</p>
<p>去除var 的话，a,b,c 会随着价格变化而变化</p>
</li>
</ul>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// This code compiles</span><br><span class="line">x = if close &gt; open</span><br><span class="line">    close</span><br><span class="line">else</span><br><span class="line">    open</span><br><span class="line">// This code doesn&apos;t compile</span><br><span class="line">x = if close &gt; open</span><br><span class="line">    close</span><br><span class="line">else</span><br><span class="line">    &quot;open&quot;</span><br></pre></td></tr></table></figure>
<p>  需要注意的是，与python不同，Pine要求，then 和 else语句返回的值的类型是相同的。在上面的第二个例子中，close 和 “open” 一个是float Series，另一个是string，不同类型的话，编译会出错。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  x = if close &gt; open</span><br><span class="line">    close</span><br><span class="line">// If current close &gt; current open, then x = close.</span><br><span class="line">// Otherwise the x = na.</span><br></pre></td></tr></table></figure>
<p>  if 语句中可以忽略else，但是系统会默认赋值（na,false,””）</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i = 1 to length-1</span><br><span class="line">     sum := sum + price[i]</span><br></pre></td></tr></table></figure>



<h2 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h2><p>Pine代码是根据价格信息计算的。但是价格信息并不是完整加载的，用户可以一直向左滑动图表，直到最早的一根柱子（Pro 用户可以在图表上加载10000左右，免费用户可以加载5000根柱子）</p>
<h3 id="实时数据的计算"><a href="#实时数据的计算" class="headerlink" title="实时数据的计算"></a>实时数据的计算</h3><p>Pine指标计算实时数据的时候和计算历史数据略有不同，因为实时数据会有addtional commit(?)和rollback action(?)</p>
<p>在实时数据的处理过程中，柱线的每一次变动都会引起Pine 指标的计算</p>
<ul>
<li>rollback : 在每一根柱线更新时发生</li>
<li>commit : 在每一根柱线关闭时发生</li>
</ul>
<p>对于判断柱线的状态，Pine中有一系列的自建函数 barstate.* 来显示当前柱线的状态。</p>
]]></content>
      <categories>
        <category>量化</category>
        <category>Pine</category>
      </categories>
      <tags>
        <tag>Pine</tag>
        <tag>TradingView</tag>
        <tag>量化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客搭建:个性篇</title>
    <url>/2019/10/27/hexo-blog-build-advanced/</url>
    <content><![CDATA[<p>通过上一篇文章，我们已经搭建好了一个博客的基本功能，已经可以开始编写博客了。<br>下面我们简单写一点Hexo的美化配置</p>
<a id="more"></a>

<h2 id="文章页个性配置"><a href="#文章页个性配置" class="headerlink" title="文章页个性配置"></a>文章页个性配置</h2><p>主题目录下的 themes\next_config.yml 文件负责与主题相关的配置，用户可以通过修改该文件来自定义与主题相关的内容或功能，修改后刷新浏览器即可即时生效。</p>
<h3 id="目录导航设置"><a href="#目录导航设置" class="headerlink" title="目录导航设置"></a>目录导航设置</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>themes\next\_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Table Of Contents in the Sidebar</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true</span><br><span class="line"></span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br></pre></td></tr></table></figure>

<h4 id="展开-隐藏目录层级"><a href="#展开-隐藏目录层级" class="headerlink" title="展开/隐藏目录层级"></a>展开/隐藏目录层级</h4><p>默认情况下，next 的目录是多级折叠的，阅读时只会展开当前目录分支。我们希望目录完全展开，同时为了避免长目录结构，约定只展开到三级目录。三级以下的目录会被隐藏，只有当文章阅读到的时候才会展开。</p>
<p>themes\next\source\css_custom\custom.styl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//TOC目录默认展开三级，这里是指Markdown标签的h3</span><br><span class="line">.post-toc .nav .nav-level-2&gt;.nav-child &#123;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是希望三级以下的目录完全被隐藏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//TOC目录默认只显示两级目录</span><br><span class="line">.nav-level-2 &gt; .nav-child &#123;</span><br><span class="line">  display: none !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="字体美化"><a href="#字体美化" class="headerlink" title="字体美化"></a>字体美化</h3><p>在 <a href="https://www.google.com/fonts" target="_blank" rel="noopener">Google Fonts</a> 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体，我们这里直接使用别人配置好的字体：<a href="http://yearito.cn/posts/hexo-theme-beautify.html#more" target="_blank" rel="noopener">别人的字体</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># themes\next\_config.yml</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line"><span class="attr">  host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line"><span class="attr">  global:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line"><span class="attr">  headings:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line"><span class="attr">  logo:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line"><span class="attr">  codes:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    family:</span></span><br></pre></td></tr></table></figure>



<h3 id="标签图标美化"><a href="#标签图标美化" class="headerlink" title="标签图标美化"></a>标签图标美化</h3><p>默认情况下标签前缀是 <code>#</code> 字符，用户可以通过修改主题源码将标签的字符前缀改为图标前缀</p>
<p>在文章布局模板中找到文末标签相关代码段，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt;</code> 即可：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># themes\next\layout\_macro\post.swig  &lt;footer class="post-footer"&gt;</span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">      &lt;div class="post-tags"&gt;</span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line"><span class="deletion">-          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="addition">+          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/footer&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>电脑基本配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客搭建：基础篇</title>
    <url>/2019/10/27/hexo-blog-build-basic/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200121121438.png" alt=""></p>
<p>Hexo 是一款基于node.js 的静态博库框架，而且可以方便的托管在Github 上， 这里简单记录一下Hexo 的安装配置过程。</p>
<p>本篇博客算是Hexo博客搭建的第一篇文章，以后会陆续写几篇优化的文章。</p>
<a id="more"></a>

<h2 id="从0到1，快速搭建hexo博客"><a href="#从0到1，快速搭建hexo博客" class="headerlink" title="从0到1，快速搭建hexo博客"></a>从0到1，快速搭建hexo博客</h2><h3 id="下载node-js"><a href="#下载node-js" class="headerlink" title="下载node.js"></a>下载node.js</h3><p> 官网下载LTS版本，直接安装。Hexo 是依赖于Node.js 和 git 工具，我们首先需要安装node.js ，然后利用npm去安装一些必要的插件。</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>注意：切换为 root 账号操作，切换淘宝源 cnpm,会更加快npm的速度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>安装hexo <code>cnpm install hexo-cli -g</code> </p>
<p>安装完后用<code>hexo -v</code> 查看一下是否安装成功</p>
<h3 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h3><p>在目录下创建 blog 文件夹  <code>mkdir blog</code> ,进入 <code>cd blog</code></p>
<p><strong>初始化hexo</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>出现 <code>INFO  Start blogging with Hexo!</code>  表示安装完成</p>
<p><strong>启动hexo</strong> </p>
<p>本地启动的博客会在<code>localhost:4000</code>中启动，用户在本地是找不到相对应的Web资源目录。markdown文件修改完后即会调用hexo中的引擎自动渲染。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server/s</span><br></pre></td></tr></table></figure>

<p><strong>清空hexo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo</span><br></pre></td></tr></table></figure>

<p><strong>生成hexo</strong></p>
<p>这一步会生成对应<code>public</code>文件夹，其中包含了页面对应的HTML文件，未来我们部署到服务器上看到的就是<code>public</code>文件夹中的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate / hexo g</span><br></pre></td></tr></table></figure>

<h3 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &apos;my first blog&apos;</span><br></pre></td></tr></table></figure>

<p>该命令会在 <code>/Users/YourUserName/blog/source/_posts/</code> 文件夹下生成对应的 md文件</p>
<p>模板文件在<code>./scaffolds/post.md</code>中找到。</p>
<h2 id="Github-Page-部署"><a href="#Github-Page-部署" class="headerlink" title="Github Page 部署"></a>Github Page 部署</h2><p>传统的博客搭建成本非常高，因为我们需要自己租用服务器，购买域名。现在我们可以将我们的代码托管到github仓库中，并利用Github Page 作为我们博客的页面（同样Github也提供了对应的域名）</p>
<h3 id="第一步：新建仓库"><a href="#第一步：新建仓库" class="headerlink" title="第一步：新建仓库"></a>第一步：新建仓库</h3><blockquote>
<p> 名字必须为自己的用户名+.github.io</p>
</blockquote>
<p>如 PPsteven.github.io</p>
<h3 id="第二步：安装git-插件"><a href="#第二步：安装git-插件" class="headerlink" title="第二步：安装git 插件"></a>第二步：安装git 插件</h3><p>git 插件可以帮助我们方便的把我们的修改提交到我们的仓库中，是一个很方便的插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<h3 id="第三步：在配置文件中添加仓库信息"><a href="#第三步：在配置文件中添加仓库信息" class="headerlink" title="第三步：在配置文件中添加仓库信息"></a>第三步：在配置文件中添加仓库信息</h3><p>在配置文件<code>_config.yml</code>中找到如下代码，添加repo 信息和 branch 信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/PPsteven/PPsteven.github.io.git</span> <span class="comment"># github 仓库地址</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span> <span class="comment"># 提交到的分支</span></span><br></pre></td></tr></table></figure>

<h3 id="第四步：部署hexo"><a href="#第四步：部署hexo" class="headerlink" title="第四步：部署hexo"></a>第四步：部署hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean    #会清除缓存文件db.json及之前生成的静态文件夹public；</span><br><span class="line">hexo g     #会重新生成静态文件夹public；</span><br><span class="line">hexo deploy/ hexo d    #因为之前已经安装了插件并且在博客配置文件中也配置好了，所以这个命令会在博客根目录下生成一个.deploy_git的文件夹，并 把本地生成的静态文件部署到LiLei.github.io这个仓库中的master分支上；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是第一次部署，会提示输入github 账号和密码</p>
</blockquote>
<p><strong>成功！！</strong></p>
<p>远端访问：PPsteven.github.io</p>
<h2 id="Hexo-CheetSheet"><a href="#Hexo-CheetSheet" class="headerlink" title="Hexo CheetSheet"></a>Hexo CheetSheet</h2><ul>
<li><p>初始化目录：<code>hexo init [folder]</code></p>
</li>
<li><p>新建文章：<code>hexo new/n [layout] &lt;title&gt;</code> 或</p>
<ul>
<li>新建草稿：<code>hexo new draft &lt;title&gt;</code></li>
<li>新建页面：<code>hexo new page tags</code></li>
</ul>
</li>
<li><p>将草稿发布为正式文章：<code>hexo publish &lt;title&gt;</code></p>
</li>
<li><p>生成静态文件：<code>hexo generate/g</code></p>
<ul>
<li>监听文件变化：<code>hexo g --watch</code> 或 <code>hexo g -w</code></li>
</ul>
</li>
<li><p>部署：<code>hexo deploy/d</code></p>
<ul>
<li>先生成后部署：<code>hexo d -g</code></li>
<li>等于 <code>hexo g</code> 加 <code>hexo d</code></li>
</ul>
</li>
<li><p>启动本地服务器（服务器会监听文件变化并自动更新）</p>
<ul>
<li><p><code>hexo server/s</code></p>
</li>
<li><p>启动调试：<code>hexo s --debug</code></p>
</li>
<li><p>预览草稿：<code>hexo s --draft</code></p>
</li>
</ul>
</li>
<li><p>清除缓存：<code>hexo clean</code></p>
</li>
</ul>
<h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><h3 id="主题安装教程"><a href="#主题安装教程" class="headerlink" title="主题安装教程"></a>主题安装教程</h3><blockquote>
<p>安装教程： <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT主题官网</a><br>                       <a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">Butterfly主题</a> </p>
</blockquote>
<h3 id="下载主题-amp-启动"><a href="#下载主题-amp-启动" class="headerlink" title="下载主题&amp;启动"></a>下载主题&amp;启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line"><span class="comment"># 编辑_config.yml</span></span><br><span class="line">theme: next</span><br><span class="line"><span class="comment"># theme: Butterfly</span></span><br></pre></td></tr></table></figure>

<h3 id="NexT-主题配置"><a href="#NexT-主题配置" class="headerlink" title="NexT 主题配置"></a>NexT 主题配置</h3><h4 id="设定主题-语言"><a href="#设定主题-语言" class="headerlink" title="设定主题/语言"></a>设定主题/语言</h4><p>主题配置的文件在themes/NexT 文件夹下的_config.yml 中，我们按照官网教程，依次配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure>

<h4 id="添加标签-分类-关于页面"><a href="#添加标签-分类-关于页面" class="headerlink" title="添加标签/分类/关于页面"></a>添加标签/分类/关于页面</h4><p>hexo 新建命令 <code>hexo n [layout] title</code> 中 layout 有三个模板</p>
<p>post创建文章，生成在<code>/source/_posts</code>文件夹下，draft创建草稿，生成在<code>/source/ _drafts</code> 文件夹下，page创建页面，生成在<code>/source/YourPageName</code>文件夹下   </p>
<p>![image-20191027011714501](/Users/ppsteven/Library/Application Support/typora-user-images/image-20191027011714501.png)</p>
<ul>
<li><p>新建页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改菜单（编辑 themes/next/_config.yml）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span> <span class="comment"># 关于页面</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span>  <span class="comment"># 标签页面</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span> <span class="comment"># 分类页面</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span> <span class="comment"># 归档页面</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span> <span class="comment"># 公益404</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h4><p>_config.yml 在blog 文件和 theme/next 文件夹下都有</p>
<p>blog 下的为站点配置文件，主题下的为主题配置文件</p>
<p><code>mkdir themes/next/source/uploads</code> ，放置头像图片（jpg/gif 等）</p>
<p>修改配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># avatar: http://example.com/avatar.png</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/uploads/avatar_1.jpg</span></span><br></pre></td></tr></table></figure>

<h4 id="设置作者昵称"><a href="#设置作者昵称" class="headerlink" title="设置作者昵称"></a>设置作者昵称</h4><p>修改  <strong>站点配置文件</strong> </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">author:</span> <span class="string">Your</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>

<h4 id="设置阅读字数与时长"><a href="#设置阅读字数与时长" class="headerlink" title="设置阅读字数与时长"></a>设置阅读字数与时长</h4><p>需要安装插件，<a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">地址</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="配置搜索服务"><a href="#配置搜索服务" class="headerlink" title="配置搜索服务"></a>配置搜索服务</h4><p>Local Search添加百度/谷歌/本地 自定义站点内容搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>编辑站点配置文件，新增如下代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>编辑主题配置文件，启动本地搜索</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>设置摘要</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>



<h3 id="多端同步"><a href="#多端同步" class="headerlink" title="多端同步"></a>多端同步</h3><p>正常情况下，我们写的博客是备份在本地的，没有上传服务器，但是若是有多台电脑的话。如何保持同步是一个问题。最近用闲置的笔记本搞了一个manjaro 玩耍，需要进行多端同步。</p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>在<code>blog</code>文件夹下，我们用<code>hexo d</code> 命令提交的仅仅是public 文件夹里面的内容，默认的是提交在 master 分支上。为了在同一个repo 下管理我们的博客，我们可以建立新的分支hexo</p>
<ul>
<li><p>github 上创建一个新的分支 hexo。进入仓库在，点击Branch，输入新的分支名回车建立</p>
<p><a href="https://upload-images.jianshu.io/upload_images/4122543-a8884eab55430542.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在本地仓库创建hexo 分支，添加remote 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout -b hexo <span class="comment"># 代表创建并切换</span></span><br><span class="line"><span class="variable">$git</span> remote add origin git@github.com:PPsteven/hexo_source.git </span><br><span class="line"><span class="comment"># 添加远端地址</span></span><br><span class="line"><span class="variable">$git</span> remote -v <span class="comment"># 查看remote 地址</span></span><br><span class="line">origin	git@github.com:PPsteven/PPsteven.github.io.git (fetch)</span><br><span class="line">origin	git@github.com:PPsteven/PPsteven.github.io.git (push)<span class="comment"># 表示添加成功</span></span><br></pre></td></tr></table></figure>

<p>其实有一个取巧的方法，在GitHub上创建新的分支hexo 后，在blog 文件夹中直接将该仓库的hexo 分支克隆到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> -b git@github.com:PPsteven/PPsteven.github.io.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>向本地分支添加文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> add . <span class="comment"># 本地文件添加至暂存区</span></span><br><span class="line"><span class="variable">$git</span> commit -m <span class="string">"blog file backup"</span> <span class="comment"># 暂存区文件提交至本地分支</span></span><br><span class="line"><span class="variable">$git</span> push origin hexo <span class="comment"># 向远端hexo 分支提交文件</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>看到网上讨论，在提交文件的时候，themes 文件夹会出错。原因是themes 下文件夹的主题包含.git 文件，造成了冲突，删除即可。</p>
</blockquote>
<h4 id="同步分支"><a href="#同步分支" class="headerlink" title="同步分支"></a>同步分支</h4><p>进入新的电脑，同步到本地就可以编辑了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> pull origin hexo</span><br></pre></td></tr></table></figure>

<h2 id="参考教程："><a href="#参考教程：" class="headerlink" title="参考教程："></a>参考教程：</h2><blockquote>
<p><a href="http://fangzh.top/2018/2018090715/" target="_blank" rel="noopener">hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2)</a></p>
<p><a href="https://uchuhimo.me/2017/04/11/genesis/#more" target="_blank" rel="noopener">如何使用 Hexo 和 GitHub Pages 搭建这个博客</a></p>
</blockquote>
<p>学习了上面的教程后，基本的搭建和部署已经没有问题了。</p>
]]></content>
      <categories>
        <category>电脑基本配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 入门基础环境搭建</title>
    <url>/2019/10/26/Mac%20%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Homebrew常用命令"><a href="#Homebrew常用命令" class="headerlink" title="Homebrew常用命令"></a>Homebrew常用命令</h2><blockquote>
<p>官网安装 Homebrew</p>
<p><a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">http://mxcl.github.com/homebrew/</a></p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>包管理软件</p>
<p>Win: 360软件管家</p>
<p>Debian/Ubuntu: apt包管理系统 </p>
<p>Redhat/Fedora: yum包管理系统</p>
<p>Mac OS X: Macports,Fink,AppStore</p>
<p>以及   <strong>Homebrew</strong> </p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>brew -v    查询Homebrew版本<br>brew -h    brew帮助<br>brew update    更新Homebrew<br>brew install <pkg_name>    安装任意软件<br>brew uninstall <pkg_name>    卸载任意软件<br>brew search <pkg_name>    查询任意包<br>brew list    列出安装列表<br>brew info <pkg_name>    查看任意包内容信息<br>brew upgrade <pkg_name>    更新任意包<br>brew cleanup <pkg_name>    删除具体旧软件<br>brew cleanup        删除所有旧软件<br>brew outdated        已安装的包是否需要更新</p>
<h2 id="item2-oh-my-zsh"><a href="#item2-oh-my-zsh" class="headerlink" title="item2+oh-my-zsh"></a>item2+oh-my-zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>

<p>chsh -s /bin/zsh. # 命令航切换bash为zsh shell<br>iterm的perference-&gt;profiles-&gt;commond 设置成/bin/zsh # iterm2 界面手动切换</p>
<ul>
<li>更改shell 语言<ol>
<li>cat /etc/shells # 查看所有 shell</li>
<li>chsh -s /bin/zsh #切换为zsh </li>
<li>修改文件<br>vi ~/.zshrc<br>source ~/.zshrc</li>
<li>echo $SHELL # 查看当前shell </li>
</ol>
</li>
</ul>
<h4 id="Iterm2-使用技巧"><a href="#Iterm2-使用技巧" class="headerlink" title="Iterm2 使用技巧"></a>Iterm2 使用技巧</h4><blockquote>
<p>参考 <a href="https://www.cnblogs.com/manastudent/p/7367718.html" target="_blank" rel="noopener">iTerm2常用的快捷键</a></p>
</blockquote>
<p>设置全局打开快捷键</p>
<p>Perferemance -&gt; Keys -&gt;Hotkey -&gt; show/hide all windows with a system-wide hotkey</p>
<p>command + shift + t  # 设置快捷键 打开iterm2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建标签：command + t</span><br><span class="line">关闭标签：command + w</span><br><span class="line">切换全屏：command + enter</span><br><span class="line">查找：command + f</span><br><span class="line">垂直分屏：command + d</span><br><span class="line">垂直上下分屏：command + shift + d</span><br><span class="line">左右 tab 之间来回切换：⌘ + 1 / 2</span><br><span class="line">查看历史命令：command + ; （输入常用命令的前缀后使用该快捷键可以实现补全的功能）</span><br><span class="line">除当前行：ctrl + u / ctrl +c </span><br><span class="line">上一条命令：ctrl + p</span><br><span class="line">搜索命令历史：ctrl + r</span><br><span class="line">清屏：clear</span><br><span class="line">重新打开：command + r</span><br><span class="line">iTerm2 剪切板历史：command + shift + h</span><br></pre></td></tr></table></figure>

<h4 id="zsh-插件配置"><a href="#zsh-插件配置" class="headerlink" title="zsh  插件配置"></a>zsh  插件配置</h4><p>目前已经有的自带插件在官网Github中可以看到，<a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins。" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins。</a><br>凡是这里有的，都可以立刻生效。</p>
<h4 id="参考页面"><a href="#参考页面" class="headerlink" title="参考页面"></a>参考页面</h4><blockquote>
<p><a href="https://blog.e9china.net/lesson/yixieshiyongchangyongchajiantuijianforzshoh-my-zsh.html" target="_blank" rel="noopener">一些实用常用插件推荐 for zsh oh-my-zsh</a></p>
</blockquote>
<h5 id="git-默认自带"><a href="#git-默认自带" class="headerlink" title="git 默认自带"></a>git 默认自带</h5><h5 id="zsh-syntax-highlighting-语法高亮"><a href="#zsh-syntax-highlighting-语法高亮" class="headerlink" title="zsh-syntax-highlighting  语法高亮"></a>zsh-syntax-highlighting  语法高亮</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>将zsh-syntax-highlighting 下载到zsh 的plugins 目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=(其他的插件 zsh-autosuggestions)</span><br></pre></td></tr></table></figure>

<h5 id="zsh-autosuggestions-自动建议"><a href="#zsh-autosuggestions-自动建议" class="headerlink" title="zsh-autosuggestions 自动建议"></a>zsh-autosuggestions 自动建议</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=(其他的插件 zsh-autosuggestions)</span><br></pre></td></tr></table></figure>

<h5 id="sublime-默认自带"><a href="#sublime-默认自带" class="headerlink" title="sublime 默认自带"></a>sublime 默认自带</h5><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>st</td>
<td>打开sublime</td>
</tr>
<tr>
<td>st + 文件夹</td>
<td>打开文件夹</td>
</tr>
<tr>
<td>st + 文件</td>
<td>打开文件</td>
</tr>
<tr>
<td>stt</td>
<td>打开当前文件夹 ，等价于 st .</td>
</tr>
<tr>
<td>sst</td>
<td>管理员权限 相当于 sudo st</td>
</tr>
</tbody></table>
<h5 id="z-默认自带"><a href="#z-默认自带" class="headerlink" title="z 默认自带"></a>z 默认自带</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">z -x 无效路径</span><br><span class="line">z 目录名称</span><br></pre></td></tr></table></figure>

<h5 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install autojump </span><br><span class="line">plugins=(其他的插件 autojump)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是linux 系统可能比较麻烦一点，需要从github 上下源码安装（当然也可以保证是最新的）</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:wting/autojump.git  autojump</span><br><span class="line">$ <span class="built_in">cd</span> autojump</span><br><span class="line">$ ./install.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行完毕后就会出现如下信息</span></span><br><span class="line">Please manually add the following line(s) to ~/.zshrc:</span><br><span class="line"></span><br><span class="line">	[[ -s /home/ppsteven/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; <span class="built_in">source</span> /home/ppsteven/.autojump/etc/profile.d/autojump.sh</span><br><span class="line"></span><br><span class="line">	<span class="built_in">autoload</span> -U compinit &amp;&amp; compinit -u</span><br><span class="line"></span><br><span class="line">Please restart terminal(s) before running autojump.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照操作在 .zshrc 中添加，我是乖乖添加了，其实我们可以直接在plugins 中添加的</span></span><br><span class="line">plugins=(其他的插件 autojump)</span><br></pre></td></tr></table></figure>

<h4 id="附录-zshrc配置"><a href="#附录-zshrc配置" class="headerlink" title="附录.zshrc配置"></a>附录<code>.zshrc</code>配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="comment"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">"/Users/ppsteven/.oh-my-zsh"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set name of the theme to load --- if set to "random", it will</span></span><br><span class="line"><span class="comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"><span class="comment"># See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span></span><br><span class="line"><span class="comment"># ZSH_THEME="agnoster"</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set list of themes to pick from when loading at random</span></span><br><span class="line"><span class="comment"># Setting this variable when ZSH_THEME=random will cause zsh to load</span></span><br><span class="line"><span class="comment"># a theme from this variable instead of looking in ~/.oh-my-zsh/themes/</span></span><br><span class="line"><span class="comment"># If set to an empty array, this variable will have no effect.</span></span><br><span class="line"><span class="comment"># ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use case-sensitive completion.</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use hyphen-insensitive completion.</span></span><br><span class="line"><span class="comment"># Case-sensitive completion must be off. _ and - will be interchangeable.</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable bi-weekly auto-update checks.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_UPDATE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to automatically update without prompting.</span></span><br><span class="line"><span class="comment"># DISABLE_UPDATE_PROMPT="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to change how often to auto-update (in days).</span></span><br><span class="line"><span class="comment"># export UPDATE_ZSH_DAYS=13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if pasting URLs and other text is messed up.</span></span><br><span class="line"><span class="comment"># DISABLE_MAGIC_FUNCTIONS=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable colors in ls.</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable auto-setting terminal title.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to enable command auto-correction.</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to display red dots whilst waiting for completion.</span></span><br><span class="line"><span class="comment"># COMPLETION_WAITING_DOTS="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to change the command execution time</span></span><br><span class="line"><span class="comment"># stamp shown in the history command output.</span></span><br><span class="line"><span class="comment"># You can set one of the optional three formats:</span></span><br><span class="line"><span class="comment"># "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"</span></span><br><span class="line"><span class="comment"># or set a custom format using the strftime function format specifications,</span></span><br><span class="line"><span class="comment"># see 'man strftime' for details.</span></span><br><span class="line"><span class="comment"># HIST_STAMPS="mm/dd/yyyy"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load?</span></span><br><span class="line"><span class="comment"># Standard plugins can be found in ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">          git</span><br><span class="line"><span class="comment">#          zsh-syntax-highlighting</span></span><br><span class="line">          zsh-autosuggestions</span><br><span class="line">	        sublime</span><br><span class="line">	        autojump </span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export MANPATH="/usr/local/man:$MANPATH"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="comment"># export LANG=en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR='vim'</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR='mvim'</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># added by Anaconda3 2019.07 installer</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; conda init &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by 'conda init' !!</span></span><br><span class="line">__conda_setup=<span class="string">"<span class="variable">$(CONDA_REPORT_ERRORS=false '/Users/ppsteven/anaconda3/bin/conda' shell.bash hook 2&gt; /dev/null)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    \<span class="built_in">eval</span> <span class="string">"<span class="variable">$__conda_setup</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"/Users/ppsteven/anaconda3/etc/profile.d/conda.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">"/Users/ppsteven/anaconda3/etc/profile.d/conda.sh"</span></span><br><span class="line">        CONDA_CHANGEPS1=<span class="literal">false</span> conda activate base</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        \<span class="built_in">export</span> PATH=<span class="string">"/Users/ppsteven/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda init &lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS="-arch x86_64"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="built_in">alias</span> zshconfig=<span class="string">"vim ~/.zshrc"</span></span><br><span class="line"><span class="comment"># alias ohmyzsh="mate ~/.oh-my-zsh"</span></span><br></pre></td></tr></table></figure>



<h2 id="解压软件"><a href="#解压软件" class="headerlink" title="解压软件"></a>解压软件</h2><h3 id="解压软件-unrar"><a href="#解压软件-unrar" class="headerlink" title="解压软件 unrar"></a>解压软件 unrar</h3><p>brew install unrar</p>
<p>使用方法</p>
<p>unrar x test.rar # 解压到当前目录</p>
<h3 id="解压软件-7z"><a href="#解压软件-7z" class="headerlink" title="解压软件 7z"></a>解压软件 7z</h3><p>brew search 7z   # p7zip</p>
<p>brew install p7zip</p>
<p>使用方法</p>
<p>7z e filename.7z</p>
<h2 id="图床软件PicGo"><a href="#图床软件PicGo" class="headerlink" title="图床软件PicGo"></a>图床软件PicGo</h2><p>安装教程</p>
<blockquote>
<p><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p>
<p>看完上面的配置才发现也是找工作的学生，真是厉害</p>
</blockquote>
<p>Github 图床配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PPsteven/pictures</span><br><span class="line">master</span><br><span class="line">Token:XXXXX</span><br><span class="line">img/</span><br><span class="line">https://cdn.jsdelivr.net/gh/PPsteven/pictures</span><br></pre></td></tr></table></figure>

<h2 id="设置-ssh-远程连接超时"><a href="#设置-ssh-远程连接超时" class="headerlink" title="设置 ssh 远程连接超时"></a>设置 ssh 远程连接超时</h2><p>为了解决 ssh 连接一段时间后会断开，我们需要在 <code>服务端</code> 和 <code>客户端</code> 做出以下操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/ssh/sshd_config # 服务端配置</span><br><span class="line">/etc/ssh/ssh_config # 客户端配置</span><br></pre></td></tr></table></figure>

<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line">ClientAliveInterval 30 <span class="comment"># 客户端每隔多少秒向服务发送一个心跳数据</span></span><br><span class="line">ClientAliveCountMax 86400 <span class="comment"># 客户端多少秒没有相应，服务器自动断掉连接</span></span><br></pre></td></tr></table></figure>

<p>最后重启 sshd 服务 (centos7+)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ServerAliveInterval 60 <span class="comment"># 每分钟发送一次, 然后客户端响应, 从而保持长连接;</span></span><br><span class="line">ServerAliveCountMax 3 <span class="comment"># 表示服务器发出请求后客户端没有响应的次数达到3次, 就自动断开</span></span><br></pre></td></tr></table></figure>



<h2 id="Charles破解教程"><a href="#Charles破解教程" class="headerlink" title="Charles破解教程"></a>Charles破解教程</h2><blockquote>
<p>参考教程：<a href="https://www.jianshu.com/p/0bc767840e42" target="_blank" rel="noopener">Charles mac 破解教程</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 工具栏中的 help --&gt; register</span><br><span class="line">Registered Name: https://zhile.io</span><br><span class="line">License Key: 48891cf209c6d32bf4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Charles设置指南：<a href="https://www.jianshu.com/p/4e748e481a1a" target="_blank" rel="noopener">Charles使用指南</a></p>
</blockquote>
]]></content>
      <categories>
        <category>电脑基本配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
